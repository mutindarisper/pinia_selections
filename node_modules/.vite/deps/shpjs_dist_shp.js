import {
  __commonJS,
  __require
} from "./chunk-S5KM4IGW.js";

// node_modules/shpjs/dist/shp.js
var require_shp = __commonJS({
  "node_modules/shpjs/dist/shp.js"(exports, module) {
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.shp = f();
      }
    })(function() {
      var define2, module2, exports2;
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof __require && __require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof __require && __require, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module3, exports3) {
        "use strict";
        const Promise2 = require2("lie");
        const combine = require2("./combine");
        const Buffer = require2("buffer").Buffer;
        module3.exports = binaryAjax;
        function binaryAjax(_url, type) {
          return new Promise2(function(resolve, reject) {
            const url = combine(_url, type);
            const ajax = new XMLHttpRequest();
            ajax.open("GET", url, true);
            if (type !== "prj" && type !== "cpg") {
              ajax.responseType = "arraybuffer";
            }
            ajax.addEventListener("load", function() {
              if (ajax.status > 399) {
                if (type === "prj" || type === "cpg") {
                  return resolve(false);
                } else {
                  return reject(new Error(ajax.status));
                }
              }
              if (type !== "prj" && type !== "cpg") {
                return resolve(Buffer.from(ajax.response));
              } else {
                return resolve(ajax.response);
              }
            }, false);
            ajax.send();
          });
        }
      }, { "./combine": 3, "buffer": 8, "lie": 12 }], 2: [function(require2, module3, exports3) {
        (function(global2) {
          (function() {
            "use strict";
            const fallback = require2("./binaryajax-browser");
            const combine = require2("./combine");
            const Buffer = require2("buffer").Buffer;
            module3.exports = async function binaryAjax(_url, type) {
              if (!global2.fetch) {
                return fallback(_url, type);
              }
              const url = combine(_url, type);
              const isOptionalTxt = type === "prj" || type === "cpg";
              try {
                const resp = await fetch(url);
                if (resp.status > 399) {
                  throw new Error(resp.statusText);
                }
                if (isOptionalTxt) {
                  return resp.text();
                }
                const parsed = await resp.arrayBuffer();
                return Buffer.from(parsed);
              } catch (e) {
                console.log("ERROR", e, type);
                if (isOptionalTxt || type === "dbf") {
                  return false;
                }
                throw e;
              }
            };
          }).call(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./binaryajax-browser": 1, "./combine": 3, "buffer": 8 }], 3: [function(require2, module3, exports3) {
        (function(global2) {
          (function() {
            const URL = global2.URL;
            module3.exports = (base, type) => {
              if (!type) {
                return base;
              }
              const url = new URL(base);
              url.pathname = `${url.pathname}.${type}`;
              return url.href;
            };
          }).call(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 4: [function(require2, module3, exports3) {
        "use strict";
        function isClockWise(array) {
          let sum = 0;
          let i = 1;
          const len = array.length;
          let prev, cur;
          while (i < len) {
            prev = cur || array[0];
            cur = array[i];
            sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
            i++;
          }
          return sum > 0;
        }
        function polyReduce(a, b) {
          if (isClockWise(b) || !a.length) {
            a.push([b]);
          } else {
            a[a.length - 1].push(b);
          }
          return a;
        }
        ParseShp.prototype.parsePoint = function(data) {
          return {
            type: "Point",
            coordinates: this.parseCoord(data, 0)
          };
        };
        ParseShp.prototype.parseZPoint = function(data) {
          const pointXY = this.parsePoint(data);
          pointXY.coordinates.push(data.readDoubleLE(16));
          return pointXY;
        };
        ParseShp.prototype.parsePointArray = function(data, offset, num) {
          const out = [];
          let done = 0;
          while (done < num) {
            out.push(this.parseCoord(data, offset));
            offset += 16;
            done++;
          }
          return out;
        };
        ParseShp.prototype.parseZPointArray = function(data, zOffset, num, coordinates) {
          let i = 0;
          while (i < num) {
            coordinates[i].push(data.readDoubleLE(zOffset));
            i++;
            zOffset += 8;
          }
          return coordinates;
        };
        ParseShp.prototype.parseArrayGroup = function(data, offset, partOffset, num, tot) {
          const out = [];
          let done = 0;
          let curNum;
          let nextNum = 0;
          let pointNumber;
          while (done < num) {
            done++;
            partOffset += 4;
            curNum = nextNum;
            if (done === num) {
              nextNum = tot;
            } else {
              nextNum = data.readInt32LE(partOffset);
            }
            pointNumber = nextNum - curNum;
            if (!pointNumber) {
              continue;
            }
            out.push(this.parsePointArray(data, offset, pointNumber));
            offset += pointNumber << 4;
          }
          return out;
        };
        ParseShp.prototype.parseZArrayGroup = function(data, zOffset, num, coordinates) {
          let i = 0;
          while (i < num) {
            coordinates[i] = this.parseZPointArray(data, zOffset, coordinates[i].length, coordinates[i]);
            zOffset += coordinates[i].length << 3;
            i++;
          }
          return coordinates;
        };
        ParseShp.prototype.parseMultiPoint = function(data) {
          const out = {};
          const num = data.readInt32LE(32, true);
          if (!num) {
            return null;
          }
          const mins = this.parseCoord(data, 0);
          const maxs = this.parseCoord(data, 16);
          out.bbox = [
            mins[0],
            mins[1],
            maxs[0],
            maxs[1]
          ];
          const offset = 36;
          if (num === 1) {
            out.type = "Point";
            out.coordinates = this.parseCoord(data, offset);
          } else {
            out.type = "MultiPoint";
            out.coordinates = this.parsePointArray(data, offset, num);
          }
          return out;
        };
        ParseShp.prototype.parseZMultiPoint = function(data) {
          const geoJson = this.parseMultiPoint(data);
          if (!geoJson) {
            return null;
          }
          let num;
          if (geoJson.type === "Point") {
            geoJson.coordinates.push(data.readDoubleLE(72));
            return geoJson;
          } else {
            num = geoJson.coordinates.length;
          }
          const zOffset = 52 + (num << 4);
          geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);
          return geoJson;
        };
        ParseShp.prototype.parsePolyline = function(data) {
          const out = {};
          const numParts = data.readInt32LE(32);
          if (!numParts) {
            return null;
          }
          const mins = this.parseCoord(data, 0);
          const maxs = this.parseCoord(data, 16);
          out.bbox = [
            mins[0],
            mins[1],
            maxs[0],
            maxs[1]
          ];
          const num = data.readInt32LE(36);
          let offset, partOffset;
          if (numParts === 1) {
            out.type = "LineString";
            offset = 44;
            out.coordinates = this.parsePointArray(data, offset, num);
          } else {
            out.type = "MultiLineString";
            offset = 40 + (numParts << 2);
            partOffset = 40;
            out.coordinates = this.parseArrayGroup(data, offset, partOffset, numParts, num);
          }
          return out;
        };
        ParseShp.prototype.parseZPolyline = function(data) {
          const geoJson = this.parsePolyline(data);
          if (!geoJson) {
            return null;
          }
          const num = geoJson.coordinates.length;
          let zOffset;
          if (geoJson.type === "LineString") {
            zOffset = 60 + (num << 4);
            geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);
            return geoJson;
          } else {
            const totalPoints = geoJson.coordinates.reduce(function(a, v) {
              return a + v.length;
            }, 0);
            zOffset = 56 + (totalPoints << 4) + (num << 2);
            geoJson.coordinates = this.parseZArrayGroup(data, zOffset, num, geoJson.coordinates);
            return geoJson;
          }
        };
        ParseShp.prototype.polyFuncs = function(out) {
          if (!out) {
            return out;
          }
          if (out.type === "LineString") {
            out.type = "Polygon";
            out.coordinates = [out.coordinates];
            return out;
          } else {
            out.coordinates = out.coordinates.reduce(polyReduce, []);
            if (out.coordinates.length === 1) {
              out.type = "Polygon";
              out.coordinates = out.coordinates[0];
              return out;
            } else {
              out.type = "MultiPolygon";
              return out;
            }
          }
        };
        ParseShp.prototype.parsePolygon = function(data) {
          return this.polyFuncs(this.parsePolyline(data));
        };
        ParseShp.prototype.parseZPolygon = function(data) {
          return this.polyFuncs(this.parseZPolyline(data));
        };
        const shpFuncObj = {
          1: "parsePoint",
          3: "parsePolyline",
          5: "parsePolygon",
          8: "parseMultiPoint",
          11: "parseZPoint",
          13: "parseZPolyline",
          15: "parseZPolygon",
          18: "parseZMultiPoint"
        };
        function makeParseCoord(trans) {
          if (trans) {
            return function(data, offset) {
              const args = [data.readDoubleLE(offset), data.readDoubleLE(offset + 8)];
              return trans.inverse(args);
            };
          } else {
            return function(data, offset) {
              return [data.readDoubleLE(offset), data.readDoubleLE(offset + 8)];
            };
          }
        }
        function ParseShp(buffer, trans) {
          if (!(this instanceof ParseShp)) {
            return new ParseShp(buffer, trans);
          }
          this.buffer = buffer;
          this.headers = this.parseHeader();
          if (this.headers.length < this.buffer.byteLength) {
            this.buffer = this.buffer.slice(0, this.headers.length);
          }
          this.shpFuncs(trans);
          this.rows = this.getRows();
        }
        ParseShp.prototype.shpFuncs = function(tran) {
          let num = this.headers.shpCode;
          if (num > 20) {
            num -= 20;
          }
          if (!(num in shpFuncObj)) {
            throw new Error("I don't know that shp type");
          }
          this.parseFunc = this[shpFuncObj[num]];
          this.parseCoord = makeParseCoord(tran);
        };
        ParseShp.prototype.getShpCode = function() {
          return this.parseHeader().shpCode;
        };
        ParseShp.prototype.parseHeader = function() {
          const view = this.buffer.slice(0, 100);
          return {
            length: view.readInt32BE(6 << 2) << 1,
            version: view.readInt32LE(7 << 2),
            shpCode: view.readInt32LE(8 << 2),
            bbox: [
              view.readDoubleLE(9 << 2),
              view.readDoubleLE(11 << 2),
              view.readDoubleLE(13 << 2),
              view.readDoubleLE(13 << 2)
            ]
          };
        };
        ParseShp.prototype.getRows = function() {
          let offset = 100;
          const len = this.buffer.byteLength;
          const out = [];
          let current;
          while (offset < len) {
            current = this.getRow(offset);
            if (!current) {
              break;
            }
            offset += 8;
            offset += current.len;
            if (current.type) {
              out.push(this.parseFunc(current.data));
            } else {
              out.push(null);
            }
          }
          return out;
        };
        ParseShp.prototype.getRow = function(offset) {
          const view = this.buffer.slice(offset, offset + 12);
          const len = view.readInt32BE(4) << 1;
          const id = view.readInt32BE(0);
          if (len === 0) {
            return {
              id,
              len,
              type: 0
            };
          }
          return {
            id,
            len,
            data: this.buffer.slice(offset + 12, offset + len + 8),
            type: view.readInt32LE(8)
          };
        };
        module3.exports = function(buffer, trans) {
          return new ParseShp(buffer, trans).rows;
        };
      }, {}], 5: [function(require2, module3, exports3) {
        "use strict";
        const JSZip = require2("jszip");
        module3.exports = async (buffer) => {
          const zip = new JSZip();
          await zip.loadAsync(buffer);
          const files = zip.file(/.+/);
          const out = {};
          await Promise.all(files.map(async (a) => {
            let result;
            if (a.name.slice(-3).toLowerCase() === "shp" || a.name.slice(-3).toLowerCase() === "dbf") {
              result = await a.async("nodebuffer");
            } else {
              result = await a.async("text");
            }
            out[a.name] = result;
          }));
          return out;
        };
      }, { "jszip": 11 }], 6: [function(require2, module3, exports3) {
        "use strict";
        exports3.byteLength = byteLength;
        exports3.toByteArray = toByteArray;
        exports3.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
          var len2 = b64.length;
          if (len2 % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          var validLen = b64.indexOf("=");
          if (validLen === -1)
            validLen = len2;
          var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
          return [validLen, placeHoldersLen];
        }
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
          var curByte = 0;
          var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i2;
          for (i2 = 0; i2 < len2; i2 += 4) {
            tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 2) {
            tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 1) {
            tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i2 = start; i2 < end; i2 += 3) {
            tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len2 = uint8.length;
          var extraBytes = len2 % 3;
          var parts = [];
          var maxChunkLength = 16383;
          for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
            parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len2 - 1];
            parts.push(
              lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
            );
          } else if (extraBytes === 2) {
            tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
            parts.push(
              lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
            );
          }
          return parts.join("");
        }
      }, {}], 7: [function(require2, module3, exports3) {
      }, {}], 8: [function(require2, module3, exports3) {
        (function(Buffer) {
          (function() {
            "use strict";
            var base64 = require2("base64-js");
            var ieee754 = require2("ieee754");
            exports3.Buffer = Buffer2;
            exports3.SlowBuffer = SlowBuffer;
            exports3.INSPECT_MAX_BYTES = 50;
            var K_MAX_LENGTH = 2147483647;
            exports3.kMaxLength = K_MAX_LENGTH;
            Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
              console.error(
                "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
              );
            }
            function typedArraySupport() {
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } };
                return arr.foo() === 42;
              } catch (e) {
                return false;
              }
            }
            Object.defineProperty(Buffer2.prototype, "parent", {
              enumerable: true,
              get: function() {
                if (!Buffer2.isBuffer(this))
                  return void 0;
                return this.buffer;
              }
            });
            Object.defineProperty(Buffer2.prototype, "offset", {
              enumerable: true,
              get: function() {
                if (!Buffer2.isBuffer(this))
                  return void 0;
                return this.byteOffset;
              }
            });
            function createBuffer(length) {
              if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
              }
              var buf = new Uint8Array(length);
              buf.__proto__ = Buffer2.prototype;
              return buf;
            }
            function Buffer2(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                }
                return allocUnsafe(arg);
              }
              return from(arg, encodingOrOffset, length);
            }
            if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer2[Symbol.species] === Buffer2) {
              Object.defineProperty(Buffer2, Symbol.species, {
                value: null,
                configurable: true,
                enumerable: false,
                writable: false
              });
            }
            Buffer2.poolSize = 8192;
            function from(value, encodingOrOffset, length) {
              if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
              }
              if (ArrayBuffer.isView(value)) {
                return fromArrayLike(value);
              }
              if (value == null) {
                throw TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
                );
              }
              if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }
              if (typeof value === "number") {
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              }
              var valueOf = value.valueOf && value.valueOf();
              if (valueOf != null && valueOf !== value) {
                return Buffer2.from(valueOf, encodingOrOffset, length);
              }
              var b = fromObject(value);
              if (b)
                return b;
              if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                return Buffer2.from(
                  value[Symbol.toPrimitive]("string"),
                  encodingOrOffset,
                  length
                );
              }
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
              );
            }
            Buffer2.from = function(value, encodingOrOffset, length) {
              return from(value, encodingOrOffset, length);
            };
            Buffer2.prototype.__proto__ = Uint8Array.prototype;
            Buffer2.__proto__ = Uint8Array;
            function assertSize(size) {
              if (typeof size !== "number") {
                throw new TypeError('"size" argument must be of type number');
              } else if (size < 0) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
            }
            function alloc(size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(size);
              }
              if (fill !== void 0) {
                return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
              }
              return createBuffer(size);
            }
            Buffer2.alloc = function(size, fill, encoding) {
              return alloc(size, fill, encoding);
            };
            function allocUnsafe(size) {
              assertSize(size);
              return createBuffer(size < 0 ? 0 : checked(size) | 0);
            }
            Buffer2.allocUnsafe = function(size) {
              return allocUnsafe(size);
            };
            Buffer2.allocUnsafeSlow = function(size) {
              return allocUnsafe(size);
            };
            function fromString(string, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }
              if (!Buffer2.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              var length = byteLength(string, encoding) | 0;
              var buf = createBuffer(length);
              var actual = buf.write(string, encoding);
              if (actual !== length) {
                buf = buf.slice(0, actual);
              }
              return buf;
            }
            function fromArrayLike(array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              var buf = createBuffer(length);
              for (var i = 0; i < length; i += 1) {
                buf[i] = array[i] & 255;
              }
              return buf;
            }
            function fromArrayBuffer(array, byteOffset, length) {
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
              }
              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
              }
              var buf;
              if (byteOffset === void 0 && length === void 0) {
                buf = new Uint8Array(array);
              } else if (length === void 0) {
                buf = new Uint8Array(array, byteOffset);
              } else {
                buf = new Uint8Array(array, byteOffset, length);
              }
              buf.__proto__ = Buffer2.prototype;
              return buf;
            }
            function fromObject(obj) {
              if (Buffer2.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                var buf = createBuffer(len);
                if (buf.length === 0) {
                  return buf;
                }
                obj.copy(buf, 0, 0, len);
                return buf;
              }
              if (obj.length !== void 0) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                  return createBuffer(0);
                }
                return fromArrayLike(obj);
              }
              if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
              }
            }
            function checked(length) {
              if (length >= K_MAX_LENGTH) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
              }
              return length | 0;
            }
            function SlowBuffer(length) {
              if (+length != length) {
                length = 0;
              }
              return Buffer2.alloc(+length);
            }
            Buffer2.isBuffer = function isBuffer(b) {
              return b != null && b._isBuffer === true && b !== Buffer2.prototype;
            };
            Buffer2.compare = function compare(a, b) {
              if (isInstance(a, Uint8Array))
                a = Buffer2.from(a, a.offset, a.byteLength);
              if (isInstance(b, Uint8Array))
                b = Buffer2.from(b, b.offset, b.byteLength);
              if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
                throw new TypeError(
                  'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                );
              }
              if (a === b)
                return 0;
              var x = a.length;
              var y = b.length;
              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            Buffer2.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };
            Buffer2.concat = function concat(list, length) {
              if (!Array.isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              if (list.length === 0) {
                return Buffer2.alloc(0);
              }
              var i;
              if (length === void 0) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }
              var buffer = Buffer2.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (isInstance(buf, Uint8Array)) {
                  buf = Buffer2.from(buf);
                }
                if (!Buffer2.isBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer;
            };
            function byteLength(string, encoding) {
              if (Buffer2.isBuffer(string)) {
                return string.length;
              }
              if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                return string.byteLength;
              }
              if (typeof string !== "string") {
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
                );
              }
              var len = string.length;
              var mustMatch = arguments.length > 2 && arguments[2] === true;
              if (!mustMatch && len === 0)
                return 0;
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase) {
                      return mustMatch ? -1 : utf8ToBytes(string).length;
                    }
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.byteLength = byteLength;
            function slowToString(encoding, start, end) {
              var loweredCase = false;
              if (start === void 0 || start < 0) {
                start = 0;
              }
              if (start > this.length) {
                return "";
              }
              if (end === void 0 || end > this.length) {
                end = this.length;
              }
              if (end <= 0) {
                return "";
              }
              end >>>= 0;
              start >>>= 0;
              if (end <= start) {
                return "";
              }
              if (!encoding)
                encoding = "utf8";
              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);
                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);
                  case "ascii":
                    return asciiSlice(this, start, end);
                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);
                  case "base64":
                    return base64Slice(this, start, end);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.prototype._isBuffer = true;
            function swap(b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }
            Buffer2.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this;
            };
            Buffer2.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this;
            };
            Buffer2.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this;
            };
            Buffer2.prototype.toString = function toString() {
              var length = this.length;
              if (length === 0)
                return "";
              if (arguments.length === 0)
                return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };
            Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
            Buffer2.prototype.equals = function equals(b) {
              if (!Buffer2.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              if (this === b)
                return true;
              return Buffer2.compare(this, b) === 0;
            };
            Buffer2.prototype.inspect = function inspect() {
              var str = "";
              var max = exports3.INSPECT_MAX_BYTES;
              str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
              if (this.length > max)
                str += " ... ";
              return "<Buffer " + str + ">";
            };
            Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
              if (isInstance(target, Uint8Array)) {
                target = Buffer2.from(target, target.offset, target.byteLength);
              }
              if (!Buffer2.isBuffer(target)) {
                throw new TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
                );
              }
              if (start === void 0) {
                start = 0;
              }
              if (end === void 0) {
                end = target ? target.length : 0;
              }
              if (thisStart === void 0) {
                thisStart = 0;
              }
              if (thisEnd === void 0) {
                thisEnd = this.length;
              }
              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
              }
              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }
              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target)
                return 0;
              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);
              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);
              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
              if (buffer.length === 0)
                return -1;
              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
              } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
              }
              byteOffset = +byteOffset;
              if (numberIsNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
              }
              if (byteOffset < 0)
                byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir)
                  return -1;
                else
                  byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir)
                  byteOffset = 0;
                else
                  return -1;
              }
              if (typeof val === "string") {
                val = Buffer2.from(val, encoding);
              }
              if (Buffer2.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 255;
                if (typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }
              throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;
              if (encoding !== void 0) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }
              function read(buf, i2) {
                if (indexSize === 1) {
                  return buf[i2];
                } else {
                  return buf.readUInt16BE(i2 * indexSize);
                }
              }
              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1)
                      foundIndex = i;
                    if (i - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1)
                      i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }
                  if (found)
                    return i;
                }
              }
              return -1;
            }
            Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };
            Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };
            function hexWrite(buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }
              var strLen = string.length;
              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (numberIsNaN(parsed))
                  return i;
                buf[offset + i] = parsed;
              }
              return i;
            }
            function utf8Write(buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }
            function asciiWrite(buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length);
            }
            function latin1Write(buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length);
            }
            function base64Write(buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length);
            }
            function ucs2Write(buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }
            Buffer2.prototype.write = function write(string, offset, length, encoding) {
              if (offset === void 0) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
              } else if (length === void 0 && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
              } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                  length = length >>> 0;
                  if (encoding === void 0)
                    encoding = "utf8";
                } else {
                  encoding = length;
                  length = void 0;
                }
              } else {
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              }
              var remaining = this.length - offset;
              if (length === void 0 || length > remaining)
                length = remaining;
              if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }
              if (!encoding)
                encoding = "utf8";
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);
                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);
                  case "ascii":
                    return asciiWrite(this, string, offset, length);
                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset, length);
                  case "base64":
                    return base64Write(this, string, offset, length);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };
            Buffer2.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            };
            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }
            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];
              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;
                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 128) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }
                if (codePoint === null) {
                  codePoint = 65533;
                  bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                  codePoint -= 65536;
                  res.push(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i += bytesPerSequence;
              }
              return decodeCodePointsArray(res);
            }
            var MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }
              var res = "";
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res;
            }
            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 127);
              }
              return ret;
            }
            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret;
            }
            function hexSlice(buf, start, end) {
              var len = buf.length;
              if (!start || start < 0)
                start = 0;
              if (!end || end < 0 || end > len)
                end = len;
              var out = "";
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out;
            }
            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res;
            }
            Buffer2.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === void 0 ? len : ~~end;
              if (start < 0) {
                start += len;
                if (start < 0)
                  start = 0;
              } else if (start > len) {
                start = len;
              }
              if (end < 0) {
                end += len;
                if (end < 0)
                  end = 0;
              } else if (end > len) {
                end = len;
              }
              if (end < start)
                end = start;
              var newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer2.prototype;
              return newBuf;
            };
            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0)
                throw new RangeError("offset is not uint");
              if (offset + ext > length)
                throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength2 && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                checkOffset(offset, byteLength2, this.length);
              }
              var val = this[offset + --byteLength2];
              var mul = 1;
              while (byteLength2 > 0 && (mul *= 256)) {
                val += this[offset + --byteLength2] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              return this[offset];
            };
            Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] | this[offset + 1] << 8;
            };
            Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] << 8 | this[offset + 1];
            };
            Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
            };
            Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
            };
            Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength2 && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var i = byteLength2;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              if (!(this[offset] & 128))
                return this[offset];
              return (255 - this[offset] + 1) * -1;
            };
            Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              var val = this[offset] | this[offset + 1] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | this[offset] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
            };
            Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
            };
            Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };
            Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };
            Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };
            Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };
            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer2.isBuffer(buf))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (value > max || value < min)
                throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
            }
            Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              var mul = 1;
              var i = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              var i = byteLength2 - 1;
              var mul = 1;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 255, 0);
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
              return offset + 4;
            };
            Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              var i = byteLength2 - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 127, -128);
              if (value < 0)
                value = 255 + value + 1;
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
              return offset + 4;
            };
            Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              if (value < 0)
                value = 4294967295 + value + 1;
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset < 0)
                throw new RangeError("Index out of range");
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
              }
              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }
            Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert);
            };
            Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert);
            };
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
              }
              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }
            Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert);
            };
            Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert);
            };
            Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
              if (!Buffer2.isBuffer(target))
                throw new TypeError("argument should be a Buffer");
              if (!start)
                start = 0;
              if (!end && end !== 0)
                end = this.length;
              if (targetStart >= target.length)
                targetStart = target.length;
              if (!targetStart)
                targetStart = 0;
              if (end > 0 && end < start)
                end = start;
              if (end === start)
                return 0;
              if (target.length === 0 || this.length === 0)
                return 0;
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length)
                throw new RangeError("Index out of range");
              if (end < 0)
                throw new RangeError("sourceEnd out of bounds");
              if (end > this.length)
                end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }
              var len = end - start;
              if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                this.copyWithin(targetStart, start, end);
              } else if (this === target && start < targetStart && targetStart < end) {
                for (var i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, end),
                  targetStart
                );
              }
              return len;
            };
            Buffer2.prototype.fill = function fill(val, start, end, encoding) {
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }
                if (encoding !== void 0 && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                    val = code;
                  }
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }
              if (end <= start) {
                return this;
              }
              start = start >>> 0;
              end = end === void 0 ? this.length : end >>> 0;
              if (!val)
                val = 0;
              var i;
              if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
                var len = bytes.length;
                if (len === 0) {
                  throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }
              return this;
            };
            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
              str = str.split("=")[0];
              str = str.trim().replace(INVALID_BASE64_RE, "");
              if (str.length < 2)
                return "";
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }
            function toHex(n) {
              if (n < 16)
                return "0" + n.toString(16);
              return n.toString(16);
            }
            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];
              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                  if (!leadSurrogate) {
                    if (codePoint > 56319) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    } else if (i + 1 === length) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    }
                    leadSurrogate = codePoint;
                    continue;
                  }
                  if (codePoint < 56320) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    leadSurrogate = codePoint;
                    continue;
                  }
                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                  if ((units -= 1) < 0)
                    break;
                  bytes.push(codePoint);
                } else if (codePoint < 2048) {
                  if ((units -= 2) < 0)
                    break;
                  bytes.push(
                    codePoint >> 6 | 192,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 65536) {
                  if ((units -= 3) < 0)
                    break;
                  bytes.push(
                    codePoint >> 12 | 224,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 1114112) {
                  if ((units -= 4) < 0)
                    break;
                  bytes.push(
                    codePoint >> 18 | 240,
                    codePoint >> 12 & 63 | 128,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else {
                  throw new Error("Invalid code point");
                }
              }
              return bytes;
            }
            function asciiToBytes(str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 255);
              }
              return byteArray;
            }
            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0)
                  break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }
              return byteArray;
            }
            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length)
                  break;
                dst[i + offset] = src[i];
              }
              return i;
            }
            function isInstance(obj, type) {
              return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
            }
            function numberIsNaN(obj) {
              return obj !== obj;
            }
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "base64-js": 6, "buffer": 8, "ieee754": 9 }], 9: [function(require2, module3, exports3) {
        exports3.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports3.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      }, {}], 10: [function(require2, module3, exports3) {
        (function(global2) {
          (function() {
            "use strict";
            var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
            var scheduleDrain;
            {
              if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick);
                var element = global2.document.createTextNode("");
                observer.observe(element, {
                  characterData: true
                });
                scheduleDrain = function() {
                  element.data = called = ++called % 2;
                };
              } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
                var channel = new global2.MessageChannel();
                channel.port1.onmessage = nextTick;
                scheduleDrain = function() {
                  channel.port2.postMessage(0);
                };
              } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
                scheduleDrain = function() {
                  var scriptEl = global2.document.createElement("script");
                  scriptEl.onreadystatechange = function() {
                    nextTick();
                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                  };
                  global2.document.documentElement.appendChild(scriptEl);
                };
              } else {
                scheduleDrain = function() {
                  setTimeout(nextTick, 0);
                };
              }
            }
            var draining;
            var queue = [];
            function nextTick() {
              draining = true;
              var i, oldQueue;
              var len = queue.length;
              while (len) {
                oldQueue = queue;
                queue = [];
                i = -1;
                while (++i < len) {
                  oldQueue[i]();
                }
                len = queue.length;
              }
              draining = false;
            }
            module3.exports = immediate;
            function immediate(task) {
              if (queue.push(task) === 1 && !draining) {
                scheduleDrain();
              }
            }
          }).call(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 11: [function(require2, module3, exports3) {
        (function(global2, Buffer, setImmediate) {
          (function() {
            !function(e) {
              if ("object" == typeof exports3 && "undefined" != typeof module3)
                module3.exports = e();
              else if ("function" == typeof define2 && define2.amd)
                define2([], e);
              else {
                ("undefined" != typeof window ? window : "undefined" != typeof global2 ? global2 : "undefined" != typeof self ? self : this).JSZip = e();
              }
            }(function() {
              return function s(a, o, u) {
                function h(r, e2) {
                  if (!o[r]) {
                    if (!a[r]) {
                      var t = "function" == typeof require2 && require2;
                      if (!e2 && t)
                        return t(r, true);
                      if (f)
                        return f(r, true);
                      var n = new Error("Cannot find module '" + r + "'");
                      throw n.code = "MODULE_NOT_FOUND", n;
                    }
                    var i = o[r] = { exports: {} };
                    a[r][0].call(i.exports, function(e3) {
                      var t2 = a[r][1][e3];
                      return h(t2 || e3);
                    }, i, i.exports, s, a, o, u);
                  }
                  return o[r].exports;
                }
                for (var f = "function" == typeof require2 && require2, e = 0; e < u.length; e++)
                  h(u[e]);
                return h;
              }({ 1: [function(l, t, n) {
                (function(r) {
                  !function(e) {
                    "object" == typeof n && void 0 !== t ? t.exports = e() : ("undefined" != typeof window ? window : void 0 !== r ? r : "undefined" != typeof self ? self : this).JSZip = e();
                  }(function() {
                    return function s(a, o, u) {
                      function h(t2, e2) {
                        if (!o[t2]) {
                          if (!a[t2]) {
                            var r2 = "function" == typeof l && l;
                            if (!e2 && r2)
                              return r2(t2, true);
                            if (f)
                              return f(t2, true);
                            var n2 = new Error("Cannot find module '" + t2 + "'");
                            throw n2.code = "MODULE_NOT_FOUND", n2;
                          }
                          var i = o[t2] = { exports: {} };
                          a[t2][0].call(i.exports, function(e3) {
                            return h(a[t2][1][e3] || e3);
                          }, i, i.exports, s, a, o, u);
                        }
                        return o[t2].exports;
                      }
                      for (var f = "function" == typeof l && l, e = 0; e < u.length; e++)
                        h(u[e]);
                      return h;
                    }({ 1: [function(l2, t2, n2) {
                      (function(r2) {
                        !function(e) {
                          "object" == typeof n2 && void 0 !== t2 ? t2.exports = e() : ("undefined" != typeof window ? window : void 0 !== r2 ? r2 : "undefined" != typeof self ? self : this).JSZip = e();
                        }(function() {
                          return function s(a, o, u) {
                            function h(t3, e2) {
                              if (!o[t3]) {
                                if (!a[t3]) {
                                  var r3 = "function" == typeof l2 && l2;
                                  if (!e2 && r3)
                                    return r3(t3, true);
                                  if (f)
                                    return f(t3, true);
                                  var n3 = new Error("Cannot find module '" + t3 + "'");
                                  throw n3.code = "MODULE_NOT_FOUND", n3;
                                }
                                var i = o[t3] = { exports: {} };
                                a[t3][0].call(i.exports, function(e3) {
                                  return h(a[t3][1][e3] || e3);
                                }, i, i.exports, s, a, o, u);
                              }
                              return o[t3].exports;
                            }
                            for (var f = "function" == typeof l2 && l2, e = 0; e < u.length; e++)
                              h(u[e]);
                            return h;
                          }({ 1: [function(l3, t3, n3) {
                            (function(r3) {
                              !function(e) {
                                "object" == typeof n3 && void 0 !== t3 ? t3.exports = e() : ("undefined" != typeof window ? window : void 0 !== r3 ? r3 : "undefined" != typeof self ? self : this).JSZip = e();
                              }(function() {
                                return function s(a, o, u) {
                                  function h(t4, e2) {
                                    if (!o[t4]) {
                                      if (!a[t4]) {
                                        var r4 = "function" == typeof l3 && l3;
                                        if (!e2 && r4)
                                          return r4(t4, true);
                                        if (f)
                                          return f(t4, true);
                                        var n4 = new Error("Cannot find module '" + t4 + "'");
                                        throw n4.code = "MODULE_NOT_FOUND", n4;
                                      }
                                      var i = o[t4] = { exports: {} };
                                      a[t4][0].call(i.exports, function(e3) {
                                        return h(a[t4][1][e3] || e3);
                                      }, i, i.exports, s, a, o, u);
                                    }
                                    return o[t4].exports;
                                  }
                                  for (var f = "function" == typeof l3 && l3, e = 0; e < u.length; e++)
                                    h(u[e]);
                                  return h;
                                }({ 1: [function(l4, t4, n4) {
                                  (function(r4) {
                                    !function(e) {
                                      "object" == typeof n4 && void 0 !== t4 ? t4.exports = e() : ("undefined" != typeof window ? window : void 0 !== r4 ? r4 : "undefined" != typeof self ? self : this).JSZip = e();
                                    }(function() {
                                      return function s(a, o, u) {
                                        function h(t5, e2) {
                                          if (!o[t5]) {
                                            if (!a[t5]) {
                                              var r5 = "function" == typeof l4 && l4;
                                              if (!e2 && r5)
                                                return r5(t5, true);
                                              if (f)
                                                return f(t5, true);
                                              var n5 = new Error("Cannot find module '" + t5 + "'");
                                              throw n5.code = "MODULE_NOT_FOUND", n5;
                                            }
                                            var i = o[t5] = { exports: {} };
                                            a[t5][0].call(i.exports, function(e3) {
                                              return h(a[t5][1][e3] || e3);
                                            }, i, i.exports, s, a, o, u);
                                          }
                                          return o[t5].exports;
                                        }
                                        for (var f = "function" == typeof l4 && l4, e = 0; e < u.length; e++)
                                          h(u[e]);
                                        return h;
                                      }({ 1: [function(l5, t5, n5) {
                                        (function(r5) {
                                          !function(e) {
                                            "object" == typeof n5 && void 0 !== t5 ? t5.exports = e() : ("undefined" != typeof window ? window : void 0 !== r5 ? r5 : "undefined" != typeof self ? self : this).JSZip = e();
                                          }(function() {
                                            return function s(a, o, u) {
                                              function h(t6, e2) {
                                                if (!o[t6]) {
                                                  if (!a[t6]) {
                                                    var r6 = "function" == typeof l5 && l5;
                                                    if (!e2 && r6)
                                                      return r6(t6, true);
                                                    if (f)
                                                      return f(t6, true);
                                                    var n6 = new Error("Cannot find module '" + t6 + "'");
                                                    throw n6.code = "MODULE_NOT_FOUND", n6;
                                                  }
                                                  var i = o[t6] = { exports: {} };
                                                  a[t6][0].call(i.exports, function(e3) {
                                                    return h(a[t6][1][e3] || e3);
                                                  }, i, i.exports, s, a, o, u);
                                                }
                                                return o[t6].exports;
                                              }
                                              for (var f = "function" == typeof l5 && l5, e = 0; e < u.length; e++)
                                                h(u[e]);
                                              return h;
                                            }({ 1: [function(e, t6, r6) {
                                              "use strict";
                                              var c = e("./utils"), l6 = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                                              r6.encode = function(e2) {
                                                for (var t7, r7, n6, i, s, a, o, u = [], h = 0, f = e2.length, l7 = f, d = "string" !== c.getTypeOf(e2); h < e2.length; )
                                                  l7 = f - h, n6 = d ? (t7 = e2[h++], r7 = h < f ? e2[h++] : 0, h < f ? e2[h++] : 0) : (t7 = e2.charCodeAt(h++), r7 = h < f ? e2.charCodeAt(h++) : 0, h < f ? e2.charCodeAt(h++) : 0), i = t7 >> 2, s = (3 & t7) << 4 | r7 >> 4, a = 1 < l7 ? (15 & r7) << 2 | n6 >> 6 : 64, o = 2 < l7 ? 63 & n6 : 64, u.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
                                                return u.join("");
                                              }, r6.decode = function(e2) {
                                                var t7, r7, n6, i, s, a, o = 0, u = 0;
                                                if ("data:" === e2.substr(0, "data:".length))
                                                  throw new Error("Invalid base64 input, it looks like a data url.");
                                                var h, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
                                                if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
                                                  throw new Error("Invalid base64 input, bad content length.");
                                                for (h = l6.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
                                                  t7 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r7 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n6 = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), h[u++] = t7, 64 !== s && (h[u++] = r7), 64 !== a && (h[u++] = n6);
                                                return h;
                                              };
                                            }, { "./support": 30, "./utils": 32 }], 2: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
                                              function o(e2, t7, r7, n7, i2) {
                                                this.compressedSize = e2, this.uncompressedSize = t7, this.crc32 = r7, this.compression = n7, this.compressedContent = i2;
                                              }
                                              o.prototype = { getContentWorker: function() {
                                                var e2 = new i(n6.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t7 = this;
                                                return e2.on("end", function() {
                                                  if (this.streamInfo.data_length !== t7.uncompressedSize)
                                                    throw new Error("Bug : uncompressed data size mismatch");
                                                }), e2;
                                              }, getCompressedWorker: function() {
                                                return new i(n6.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                                              } }, o.createWorkerFrom = function(e2, t7, r7) {
                                                return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t7.compressWorker(r7)).pipe(new a("compressedSize")).withStreamInfo("compression", t7);
                                              }, t6.exports = o;
                                            }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./stream/GenericWorker");
                                              r6.STORE = { magic: "\0\0", compressWorker: function(e2) {
                                                return new n6("STORE compression");
                                              }, uncompressWorker: function() {
                                                return new n6("STORE decompression");
                                              } }, r6.DEFLATE = e("./flate");
                                            }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./utils"), a = function() {
                                                for (var e2, t7 = [], r7 = 0; r7 < 256; r7++) {
                                                  e2 = r7;
                                                  for (var n7 = 0; n7 < 8; n7++)
                                                    e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
                                                  t7[r7] = e2;
                                                }
                                                return t7;
                                              }();
                                              t6.exports = function(e2, t7) {
                                                return void 0 !== e2 && e2.length ? "string" !== n6.getTypeOf(e2) ? function(e3, t8, r7) {
                                                  var n7 = a, i = 0 + r7;
                                                  e3 ^= -1;
                                                  for (var s = 0; s < i; s++)
                                                    e3 = e3 >>> 8 ^ n7[255 & (e3 ^ t8[s])];
                                                  return -1 ^ e3;
                                                }(0 | t7, e2, e2.length) : function(e3, t8, r7) {
                                                  var n7 = a, i = 0 + r7;
                                                  e3 ^= -1;
                                                  for (var s = 0; s < i; s++)
                                                    e3 = e3 >>> 8 ^ n7[255 & (e3 ^ t8.charCodeAt(s))];
                                                  return -1 ^ e3;
                                                }(0 | t7, e2, e2.length) : 0;
                                              };
                                            }, { "./utils": 32 }], 5: [function(e, t6, r6) {
                                              "use strict";
                                              r6.base64 = false, r6.binary = false, r6.dir = false, r6.createFolders = true, r6.date = null, r6.compression = null, r6.compressionOptions = null, r6.comment = null, r6.unixPermissions = null, r6.dosPermissions = null;
                                            }, {}], 6: [function(e, t6, r6) {
                                              "use strict";
                                              var n6;
                                              n6 = "undefined" != typeof Promise ? Promise : e("lie"), t6.exports = { Promise: n6 };
                                            }, { lie: 37 }], 7: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n6 ? "uint8array" : "array";
                                              function u(e2, t7) {
                                                a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t7, this.meta = {};
                                              }
                                              r6.magic = "\b\0", s.inherits(u, a), u.prototype.processChunk = function(e2) {
                                                this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
                                              }, u.prototype.flush = function() {
                                                a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
                                              }, u.prototype.cleanUp = function() {
                                                a.prototype.cleanUp.call(this), this._pako = null;
                                              }, u.prototype._createPako = function() {
                                                this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
                                                var t7 = this;
                                                this._pako.onData = function(e2) {
                                                  t7.push({ data: e2, meta: t7.meta });
                                                };
                                              }, r6.compressWorker = function(e2) {
                                                return new u("Deflate", e2);
                                              }, r6.uncompressWorker = function() {
                                                return new u("Inflate", {});
                                              };
                                            }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t6, r6) {
                                              "use strict";
                                              function I(e2, t7) {
                                                var r7, n7 = "";
                                                for (r7 = 0; r7 < t7; r7++)
                                                  n7 += String.fromCharCode(255 & e2), e2 >>>= 8;
                                                return n7;
                                              }
                                              function i(e2, t7, r7, n7, i2, s2) {
                                                var a, o, u = e2.file, h = e2.compression, f = s2 !== B.utf8encode, l6 = O.transformTo("string", s2(u.name)), d = O.transformTo("string", B.utf8encode(u.name)), c = u.comment, p = O.transformTo("string", s2(c)), m = O.transformTo("string", B.utf8encode(c)), _ = d.length !== u.name.length, g = m.length !== c.length, v = "", b = "", w = "", y = u.dir, k = u.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
                                                t7 && !r7 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
                                                var S = 0;
                                                t7 && (S |= 8), f || !_ && !g || (S |= 2048);
                                                var z, E = 0, C = 0;
                                                y && (E |= 16), "UNIX" === i2 ? (C = 798, E |= ((z = u.unixPermissions) || (z = y ? 16893 : 33204), (65535 & z) << 16)) : (C = 20, E |= 63 & (u.dosPermissions || 0)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v += "up" + I((b = I(1, 1) + I(T(l6), 4) + d).length, 2) + b), g && (v += "uc" + I((w = I(1, 1) + I(T(p), 4) + m).length, 2) + w);
                                                var A = "";
                                                return A += "\n\0", A += I(S, 2), A += h.magic, A += I(a, 2), A += I(o, 2), A += I(x.crc32, 4), A += I(x.compressedSize, 4), A += I(x.uncompressedSize, 4), A += I(l6.length, 2), A += I(v.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + A + l6 + v, dirRecord: R.CENTRAL_FILE_HEADER + I(C, 2) + A + I(p.length, 2) + "\0\0\0\0" + I(E, 4) + I(n7, 4) + l6 + v + p };
                                              }
                                              var O = e("../utils"), s = e("../stream/GenericWorker"), B = e("../utf8"), T = e("../crc32"), R = e("../signature");
                                              function n6(e2, t7, r7, n7) {
                                                s.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t7, this.zipPlatform = r7, this.encodeFileName = n7, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
                                              }
                                              O.inherits(n6, s), n6.prototype.push = function(e2) {
                                                var t7 = e2.meta.percent || 0, r7 = this.entriesCount, n7 = this._sources.length;
                                                this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, s.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r7 ? (t7 + 100 * (r7 - n7 - 1)) / r7 : 100 } }));
                                              }, n6.prototype.openedSource = function(e2) {
                                                this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
                                                var t7 = this.streamFiles && !e2.file.dir;
                                                if (t7) {
                                                  var r7 = i(e2, t7, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                                                  this.push({ data: r7.fileRecord, meta: { percent: 0 } });
                                                } else
                                                  this.accumulate = true;
                                              }, n6.prototype.closedSource = function(e2) {
                                                this.accumulate = false;
                                                var t7, r7 = this.streamFiles && !e2.file.dir, n7 = i(e2, r7, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                                                if (this.dirRecords.push(n7.dirRecord), r7)
                                                  this.push({ data: (t7 = e2, R.DATA_DESCRIPTOR + I(t7.crc32, 4) + I(t7.compressedSize, 4) + I(t7.uncompressedSize, 4)), meta: { percent: 100 } });
                                                else
                                                  for (this.push({ data: n7.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                                                    this.push(this.contentBuffer.shift());
                                                this.currentFile = null;
                                              }, n6.prototype.flush = function() {
                                                for (var e2 = this.bytesWritten, t7 = 0; t7 < this.dirRecords.length; t7++)
                                                  this.push({ data: this.dirRecords[t7], meta: { percent: 100 } });
                                                var r7, n7, i2, s2, a, o, u = this.bytesWritten - e2, h = (r7 = this.dirRecords.length, n7 = u, i2 = e2, s2 = this.zipComment, a = this.encodeFileName, o = O.transformTo("string", a(s2)), R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + I(r7, 2) + I(r7, 2) + I(n7, 4) + I(i2, 4) + I(o.length, 2) + o);
                                                this.push({ data: h, meta: { percent: 100 } });
                                              }, n6.prototype.prepareNextSource = function() {
                                                this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
                                              }, n6.prototype.registerPrevious = function(e2) {
                                                this._sources.push(e2);
                                                var t7 = this;
                                                return e2.on("data", function(e3) {
                                                  t7.processChunk(e3);
                                                }), e2.on("end", function() {
                                                  t7.closedSource(t7.previous.streamInfo), t7._sources.length ? t7.prepareNextSource() : t7.end();
                                                }), e2.on("error", function(e3) {
                                                  t7.error(e3);
                                                }), this;
                                              }, n6.prototype.resume = function() {
                                                return !!s.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
                                              }, n6.prototype.error = function(e2) {
                                                var t7 = this._sources;
                                                if (!s.prototype.error.call(this, e2))
                                                  return false;
                                                for (var r7 = 0; r7 < t7.length; r7++)
                                                  try {
                                                    t7[r7].error(e2);
                                                  } catch (e3) {
                                                  }
                                                return true;
                                              }, n6.prototype.lock = function() {
                                                s.prototype.lock.call(this);
                                                for (var e2 = this._sources, t7 = 0; t7 < e2.length; t7++)
                                                  e2[t7].lock();
                                              }, t6.exports = n6;
                                            }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t6, r6) {
                                              "use strict";
                                              var h = e("../compressions"), n6 = e("./ZipFileWorker");
                                              r6.generateWorker = function(e2, a, t7) {
                                                var o = new n6(a.streamFiles, t7, a.platform, a.encodeFileName), u = 0;
                                                try {
                                                  e2.forEach(function(e3, t8) {
                                                    u++;
                                                    var r7 = function(e4, t9) {
                                                      var r8 = e4 || t9, n8 = h[r8];
                                                      if (!n8)
                                                        throw new Error(r8 + " is not a valid compression method !");
                                                      return n8;
                                                    }(t8.options.compression, a.compression), n7 = t8.options.compressionOptions || a.compressionOptions || {}, i = t8.dir, s = t8.date;
                                                    t8._compressWorker(r7, n7).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t8.comment || "", unixPermissions: t8.unixPermissions, dosPermissions: t8.dosPermissions }).pipe(o);
                                                  }), o.entriesCount = u;
                                                } catch (e3) {
                                                  o.error(e3);
                                                }
                                                return o;
                                              };
                                            }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t6, r6) {
                                              "use strict";
                                              function n6() {
                                                if (!(this instanceof n6))
                                                  return new n6();
                                                if (arguments.length)
                                                  throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                                                this.files = {}, this.comment = null, this.root = "", this.clone = function() {
                                                  var e2 = new n6();
                                                  for (var t7 in this)
                                                    "function" != typeof this[t7] && (e2[t7] = this[t7]);
                                                  return e2;
                                                };
                                              }
                                              (n6.prototype = e("./object")).loadAsync = e("./load"), n6.support = e("./support"), n6.defaults = e("./defaults"), n6.version = "3.5.0", n6.loadAsync = function(e2, t7) {
                                                return new n6().loadAsync(e2, t7);
                                              }, n6.external = e("./external"), t6.exports = n6;
                                            }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./utils"), i = e("./external"), o = e("./utf8"), u = e("./zipEntries"), s = e("./stream/Crc32Probe"), h = e("./nodejsUtils");
                                              function f(n7) {
                                                return new i.Promise(function(e2, t7) {
                                                  var r7 = n7.decompressed.getContentWorker().pipe(new s());
                                                  r7.on("error", function(e3) {
                                                    t7(e3);
                                                  }).on("end", function() {
                                                    r7.streamInfo.crc32 !== n7.decompressed.crc32 ? t7(new Error("Corrupted zip : CRC32 mismatch")) : e2();
                                                  }).resume();
                                                });
                                              }
                                              t6.exports = function(e2, s2) {
                                                var a = this;
                                                return s2 = n6.extend(s2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: o.utf8decode }), h.isNode && h.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n6.prepareContent("the loaded zip file", e2, true, s2.optimizedBinaryString, s2.base64).then(function(e3) {
                                                  var t7 = new u(s2);
                                                  return t7.load(e3), t7;
                                                }).then(function(e3) {
                                                  var t7 = [i.Promise.resolve(e3)], r7 = e3.files;
                                                  if (s2.checkCRC32)
                                                    for (var n7 = 0; n7 < r7.length; n7++)
                                                      t7.push(f(r7[n7]));
                                                  return i.Promise.all(t7);
                                                }).then(function(e3) {
                                                  for (var t7 = e3.shift(), r7 = t7.files, n7 = 0; n7 < r7.length; n7++) {
                                                    var i2 = r7[n7];
                                                    a.file(i2.fileNameStr, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: s2.createFolders });
                                                  }
                                                  return t7.zipComment.length && (a.comment = t7.zipComment), a;
                                                });
                                              };
                                            }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("../utils"), i = e("../stream/GenericWorker");
                                              function s(e2, t7) {
                                                i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t7);
                                              }
                                              n6.inherits(s, i), s.prototype._bindStream = function(e2) {
                                                var t7 = this;
                                                (this._stream = e2).pause(), e2.on("data", function(e3) {
                                                  t7.push({ data: e3, meta: { percent: 0 } });
                                                }).on("error", function(e3) {
                                                  t7.isPaused ? this.generatedError = e3 : t7.error(e3);
                                                }).on("end", function() {
                                                  t7.isPaused ? t7._upstreamEnded = true : t7.end();
                                                });
                                              }, s.prototype.pause = function() {
                                                return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
                                              }, s.prototype.resume = function() {
                                                return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
                                              }, t6.exports = s;
                                            }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t6, r6) {
                                              "use strict";
                                              var i = e("readable-stream").Readable;
                                              function n6(e2, t7, r7) {
                                                i.call(this, t7), this._helper = e2;
                                                var n7 = this;
                                                e2.on("data", function(e3, t8) {
                                                  n7.push(e3) || n7._helper.pause(), r7 && r7(t8);
                                                }).on("error", function(e3) {
                                                  n7.emit("error", e3);
                                                }).on("end", function() {
                                                  n7.push(null);
                                                });
                                              }
                                              e("../utils").inherits(n6, i), n6.prototype._read = function() {
                                                this._helper.resume();
                                              }, t6.exports = n6;
                                            }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t6, r6) {
                                              "use strict";
                                              t6.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t7) {
                                                if (Buffer.from && Buffer.from !== Uint8Array.from)
                                                  return Buffer.from(e2, t7);
                                                if ("number" == typeof e2)
                                                  throw new Error('The "data" argument must not be a number');
                                                return new Buffer(e2, t7);
                                              }, allocBuffer: function(e2) {
                                                if (Buffer.alloc)
                                                  return Buffer.alloc(e2);
                                                var t7 = new Buffer(e2);
                                                return t7.fill(0), t7;
                                              }, isBuffer: function(e2) {
                                                return Buffer.isBuffer(e2);
                                              }, isStream: function(e2) {
                                                return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
                                              } };
                                            }, {}], 15: [function(e, t6, r6) {
                                              "use strict";
                                              function s(e2, t7, r7) {
                                                var n7, i2 = f.getTypeOf(t7), s2 = f.extend(r7 || {}, d);
                                                s2.date = s2.date || new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = h(e2)), s2.createFolders && (n7 = function(e3) {
                                                  "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
                                                  var t8 = e3.lastIndexOf("/");
                                                  return 0 < t8 ? e3.substring(0, t8) : "";
                                                }(e2)) && g.call(this, n7, true);
                                                var a2, o2 = "string" === i2 && false === s2.binary && false === s2.base64;
                                                r7 && void 0 !== r7.binary || (s2.binary = !o2), (t7 instanceof c && 0 === t7.uncompressedSize || s2.dir || !t7 || 0 === t7.length) && (s2.base64 = false, s2.binary = true, t7 = "", s2.compression = "STORE", i2 = "string"), a2 = t7 instanceof c || t7 instanceof l6 ? t7 : m.isNode && m.isStream(t7) ? new _(e2, t7) : f.prepareContent(e2, t7, s2.binary, s2.optimizedBinaryString, s2.base64);
                                                var u2 = new p(e2, a2, s2);
                                                this.files[e2] = u2;
                                              }
                                              function h(e2) {
                                                return "/" !== e2.slice(-1) && (e2 += "/"), e2;
                                              }
                                              var i = e("./utf8"), f = e("./utils"), l6 = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), d = e("./defaults"), c = e("./compressedObject"), p = e("./zipObject"), o = e("./generate"), m = e("./nodejsUtils"), _ = e("./nodejs/NodejsStreamInputAdapter"), g = function(e2, t7) {
                                                return t7 = void 0 !== t7 ? t7 : d.createFolders, e2 = h(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t7 }), this.files[e2];
                                              };
                                              function u(e2) {
                                                return "[object RegExp]" === Object.prototype.toString.call(e2);
                                              }
                                              var n6 = { load: function() {
                                                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                                              }, forEach: function(e2) {
                                                var t7, r7, n7;
                                                for (t7 in this.files)
                                                  this.files.hasOwnProperty(t7) && (n7 = this.files[t7], (r7 = t7.slice(this.root.length, t7.length)) && t7.slice(0, this.root.length) === this.root && e2(r7, n7));
                                              }, filter: function(r7) {
                                                var n7 = [];
                                                return this.forEach(function(e2, t7) {
                                                  r7(e2, t7) && n7.push(t7);
                                                }), n7;
                                              }, file: function(e2, t7, r7) {
                                                if (1 !== arguments.length)
                                                  return e2 = this.root + e2, s.call(this, e2, t7, r7), this;
                                                if (u(e2)) {
                                                  var n7 = e2;
                                                  return this.filter(function(e3, t8) {
                                                    return !t8.dir && n7.test(e3);
                                                  });
                                                }
                                                var i2 = this.files[this.root + e2];
                                                return i2 && !i2.dir ? i2 : null;
                                              }, folder: function(r7) {
                                                if (!r7)
                                                  return this;
                                                if (u(r7))
                                                  return this.filter(function(e3, t8) {
                                                    return t8.dir && r7.test(e3);
                                                  });
                                                var e2 = this.root + r7, t7 = g.call(this, e2), n7 = this.clone();
                                                return n7.root = t7.name, n7;
                                              }, remove: function(r7) {
                                                r7 = this.root + r7;
                                                var e2 = this.files[r7];
                                                if (e2 || ("/" !== r7.slice(-1) && (r7 += "/"), e2 = this.files[r7]), e2 && !e2.dir)
                                                  delete this.files[r7];
                                                else
                                                  for (var t7 = this.filter(function(e3, t8) {
                                                    return t8.name.slice(0, r7.length) === r7;
                                                  }), n7 = 0; n7 < t7.length; n7++)
                                                    delete this.files[t7[n7].name];
                                                return this;
                                              }, generate: function(e2) {
                                                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                                              }, generateInternalStream: function(e2) {
                                                var t7, r7 = {};
                                                try {
                                                  if ((r7 = f.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r7.type.toLowerCase(), r7.compression = r7.compression.toUpperCase(), "binarystring" === r7.type && (r7.type = "string"), !r7.type)
                                                    throw new Error("No output type specified.");
                                                  f.checkSupport(r7.type), "darwin" !== r7.platform && "freebsd" !== r7.platform && "linux" !== r7.platform && "sunos" !== r7.platform || (r7.platform = "UNIX"), "win32" === r7.platform && (r7.platform = "DOS");
                                                  var n7 = r7.comment || this.comment || "";
                                                  t7 = o.generateWorker(this, r7, n7);
                                                } catch (e3) {
                                                  (t7 = new l6("error")).error(e3);
                                                }
                                                return new a(t7, r7.type || "string", r7.mimeType);
                                              }, generateAsync: function(e2, t7) {
                                                return this.generateInternalStream(e2).accumulate(t7);
                                              }, generateNodeStream: function(e2, t7) {
                                                return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t7);
                                              } };
                                              t6.exports = n6;
                                            }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t6, r6) {
                                              t6.exports = e("stream");
                                            }, { stream: void 0 }], 17: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./DataReader");
                                              function i(e2) {
                                                n6.call(this, e2);
                                                for (var t7 = 0; t7 < this.data.length; t7++)
                                                  e2[t7] = 255 & e2[t7];
                                              }
                                              e("../utils").inherits(i, n6), i.prototype.byteAt = function(e2) {
                                                return this.data[this.zero + e2];
                                              }, i.prototype.lastIndexOfSignature = function(e2) {
                                                for (var t7 = e2.charCodeAt(0), r7 = e2.charCodeAt(1), n7 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
                                                  if (this.data[s] === t7 && this.data[s + 1] === r7 && this.data[s + 2] === n7 && this.data[s + 3] === i2)
                                                    return s - this.zero;
                                                return -1;
                                              }, i.prototype.readAndCheckSignature = function(e2) {
                                                var t7 = e2.charCodeAt(0), r7 = e2.charCodeAt(1), n7 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
                                                return t7 === s[0] && r7 === s[1] && n7 === s[2] && i2 === s[3];
                                              }, i.prototype.readData = function(e2) {
                                                if (this.checkOffset(e2), 0 === e2)
                                                  return [];
                                                var t7 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
                                                return this.index += e2, t7;
                                              }, t6.exports = i;
                                            }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("../utils");
                                              function i(e2) {
                                                this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
                                              }
                                              i.prototype = { checkOffset: function(e2) {
                                                this.checkIndex(this.index + e2);
                                              }, checkIndex: function(e2) {
                                                if (this.length < this.zero + e2 || e2 < 0)
                                                  throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
                                              }, setIndex: function(e2) {
                                                this.checkIndex(e2), this.index = e2;
                                              }, skip: function(e2) {
                                                this.setIndex(this.index + e2);
                                              }, byteAt: function(e2) {
                                              }, readInt: function(e2) {
                                                var t7, r7 = 0;
                                                for (this.checkOffset(e2), t7 = this.index + e2 - 1; t7 >= this.index; t7--)
                                                  r7 = (r7 << 8) + this.byteAt(t7);
                                                return this.index += e2, r7;
                                              }, readString: function(e2) {
                                                return n6.transformTo("string", this.readData(e2));
                                              }, readData: function(e2) {
                                              }, lastIndexOfSignature: function(e2) {
                                              }, readAndCheckSignature: function(e2) {
                                              }, readDate: function() {
                                                var e2 = this.readInt(4);
                                                return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
                                              } }, t6.exports = i;
                                            }, { "../utils": 32 }], 19: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./Uint8ArrayReader");
                                              function i(e2) {
                                                n6.call(this, e2);
                                              }
                                              e("../utils").inherits(i, n6), i.prototype.readData = function(e2) {
                                                this.checkOffset(e2);
                                                var t7 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
                                                return this.index += e2, t7;
                                              }, t6.exports = i;
                                            }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./DataReader");
                                              function i(e2) {
                                                n6.call(this, e2);
                                              }
                                              e("../utils").inherits(i, n6), i.prototype.byteAt = function(e2) {
                                                return this.data.charCodeAt(this.zero + e2);
                                              }, i.prototype.lastIndexOfSignature = function(e2) {
                                                return this.data.lastIndexOf(e2) - this.zero;
                                              }, i.prototype.readAndCheckSignature = function(e2) {
                                                return e2 === this.readData(4);
                                              }, i.prototype.readData = function(e2) {
                                                this.checkOffset(e2);
                                                var t7 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
                                                return this.index += e2, t7;
                                              }, t6.exports = i;
                                            }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./ArrayReader");
                                              function i(e2) {
                                                n6.call(this, e2);
                                              }
                                              e("../utils").inherits(i, n6), i.prototype.readData = function(e2) {
                                                if (this.checkOffset(e2), 0 === e2)
                                                  return new Uint8Array(0);
                                                var t7 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
                                                return this.index += e2, t7;
                                              }, t6.exports = i;
                                            }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), u = e("./Uint8ArrayReader");
                                              t6.exports = function(e2) {
                                                var t7 = n6.getTypeOf(e2);
                                                return n6.checkSupport(t7), "string" !== t7 || i.uint8array ? "nodebuffer" === t7 ? new o(e2) : i.uint8array ? new u(n6.transformTo("uint8array", e2)) : new s(n6.transformTo("array", e2)) : new a(e2);
                                              };
                                            }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t6, r6) {
                                              "use strict";
                                              r6.LOCAL_FILE_HEADER = "PK", r6.CENTRAL_FILE_HEADER = "PK", r6.CENTRAL_DIRECTORY_END = "PK", r6.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r6.ZIP64_CENTRAL_DIRECTORY_END = "PK", r6.DATA_DESCRIPTOR = "PK\x07\b";
                                            }, {}], 24: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./GenericWorker"), i = e("../utils");
                                              function s(e2) {
                                                n6.call(this, "ConvertWorker to " + e2), this.destType = e2;
                                              }
                                              i.inherits(s, n6), s.prototype.processChunk = function(e2) {
                                                this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
                                              }, t6.exports = s;
                                            }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./GenericWorker"), i = e("../crc32");
                                              function s() {
                                                n6.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                                              }
                                              e("../utils").inherits(s, n6), s.prototype.processChunk = function(e2) {
                                                this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
                                              }, t6.exports = s;
                                            }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("../utils"), i = e("./GenericWorker");
                                              function s(e2) {
                                                i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
                                              }
                                              n6.inherits(s, i), s.prototype.processChunk = function(e2) {
                                                if (e2) {
                                                  var t7 = this.streamInfo[this.propName] || 0;
                                                  this.streamInfo[this.propName] = t7 + e2.data.length;
                                                }
                                                i.prototype.processChunk.call(this, e2);
                                              }, t6.exports = s;
                                            }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("../utils"), i = e("./GenericWorker");
                                              function s(e2) {
                                                i.call(this, "DataWorker");
                                                var t7 = this;
                                                this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
                                                  t7.dataIsReady = true, t7.data = e3, t7.max = e3 && e3.length || 0, t7.type = n6.getTypeOf(e3), t7.isPaused || t7._tickAndRepeat();
                                                }, function(e3) {
                                                  t7.error(e3);
                                                });
                                              }
                                              n6.inherits(s, i), s.prototype.cleanUp = function() {
                                                i.prototype.cleanUp.call(this), this.data = null;
                                              }, s.prototype.resume = function() {
                                                return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n6.delay(this._tickAndRepeat, [], this)), true);
                                              }, s.prototype._tickAndRepeat = function() {
                                                this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n6.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
                                              }, s.prototype._tick = function() {
                                                if (this.isPaused || this.isFinished)
                                                  return false;
                                                var e2 = null, t7 = Math.min(this.max, this.index + 16384);
                                                if (this.index >= this.max)
                                                  return this.end();
                                                switch (this.type) {
                                                  case "string":
                                                    e2 = this.data.substring(this.index, t7);
                                                    break;
                                                  case "uint8array":
                                                    e2 = this.data.subarray(this.index, t7);
                                                    break;
                                                  case "array":
                                                  case "nodebuffer":
                                                    e2 = this.data.slice(this.index, t7);
                                                }
                                                return this.index = t7, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
                                              }, t6.exports = s;
                                            }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t6, r6) {
                                              "use strict";
                                              function n6(e2) {
                                                this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
                                              }
                                              n6.prototype = { push: function(e2) {
                                                this.emit("data", e2);
                                              }, end: function() {
                                                if (this.isFinished)
                                                  return false;
                                                this.flush();
                                                try {
                                                  this.emit("end"), this.cleanUp(), this.isFinished = true;
                                                } catch (e2) {
                                                  this.emit("error", e2);
                                                }
                                                return true;
                                              }, error: function(e2) {
                                                return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
                                              }, on: function(e2, t7) {
                                                return this._listeners[e2].push(t7), this;
                                              }, cleanUp: function() {
                                                this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                                              }, emit: function(e2, t7) {
                                                if (this._listeners[e2])
                                                  for (var r7 = 0; r7 < this._listeners[e2].length; r7++)
                                                    this._listeners[e2][r7].call(this, t7);
                                              }, pipe: function(e2) {
                                                return e2.registerPrevious(this);
                                              }, registerPrevious: function(e2) {
                                                if (this.isLocked)
                                                  throw new Error("The stream '" + this + "' has already been used.");
                                                this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
                                                var t7 = this;
                                                return e2.on("data", function(e3) {
                                                  t7.processChunk(e3);
                                                }), e2.on("end", function() {
                                                  t7.end();
                                                }), e2.on("error", function(e3) {
                                                  t7.error(e3);
                                                }), this;
                                              }, pause: function() {
                                                return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
                                              }, resume: function() {
                                                if (!this.isPaused || this.isFinished)
                                                  return false;
                                                var e2 = this.isPaused = false;
                                                return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
                                              }, flush: function() {
                                              }, processChunk: function(e2) {
                                                this.push(e2);
                                              }, withStreamInfo: function(e2, t7) {
                                                return this.extraStreamInfo[e2] = t7, this.mergeStreamInfo(), this;
                                              }, mergeStreamInfo: function() {
                                                for (var e2 in this.extraStreamInfo)
                                                  this.extraStreamInfo.hasOwnProperty(e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
                                              }, lock: function() {
                                                if (this.isLocked)
                                                  throw new Error("The stream '" + this + "' has already been used.");
                                                this.isLocked = true, this.previous && this.previous.lock();
                                              }, toString: function() {
                                                var e2 = "Worker " + this.name;
                                                return this.previous ? this.previous + " -> " + e2 : e2;
                                              } }, t6.exports = n6;
                                            }, {}], 29: [function(e, t6, r6) {
                                              "use strict";
                                              var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), f = e("../base64"), n6 = e("../support"), a = e("../external"), o = null;
                                              if (n6.nodestream)
                                                try {
                                                  o = e("../nodejs/NodejsStreamOutputAdapter");
                                                } catch (e2) {
                                                }
                                              function u(e2, t7, r7) {
                                                var n7 = t7;
                                                switch (t7) {
                                                  case "blob":
                                                  case "arraybuffer":
                                                    n7 = "uint8array";
                                                    break;
                                                  case "base64":
                                                    n7 = "string";
                                                }
                                                try {
                                                  this._internalType = n7, this._outputType = t7, this._mimeType = r7, h.checkSupport(n7), this._worker = e2.pipe(new i(n7)), e2.lock();
                                                } catch (e3) {
                                                  this._worker = new s("error"), this._worker.error(e3);
                                                }
                                              }
                                              u.prototype = { accumulate: function(e2) {
                                                return o2 = this, u2 = e2, new a.Promise(function(t7, r7) {
                                                  var n7 = [], i2 = o2._internalType, s2 = o2._outputType, a2 = o2._mimeType;
                                                  o2.on("data", function(e3, t8) {
                                                    n7.push(e3), u2 && u2(t8);
                                                  }).on("error", function(e3) {
                                                    n7 = [], r7(e3);
                                                  }).on("end", function() {
                                                    try {
                                                      var e3 = function(e4, t8, r8) {
                                                        switch (e4) {
                                                          case "blob":
                                                            return h.newBlob(h.transformTo("arraybuffer", t8), r8);
                                                          case "base64":
                                                            return f.encode(t8);
                                                          default:
                                                            return h.transformTo(e4, t8);
                                                        }
                                                      }(s2, function(e4, t8) {
                                                        var r8, n8 = 0, i3 = null, s3 = 0;
                                                        for (r8 = 0; r8 < t8.length; r8++)
                                                          s3 += t8[r8].length;
                                                        switch (e4) {
                                                          case "string":
                                                            return t8.join("");
                                                          case "array":
                                                            return Array.prototype.concat.apply([], t8);
                                                          case "uint8array":
                                                            for (i3 = new Uint8Array(s3), r8 = 0; r8 < t8.length; r8++)
                                                              i3.set(t8[r8], n8), n8 += t8[r8].length;
                                                            return i3;
                                                          case "nodebuffer":
                                                            return Buffer.concat(t8);
                                                          default:
                                                            throw new Error("concat : unsupported type '" + e4 + "'");
                                                        }
                                                      }(i2, n7), a2);
                                                      t7(e3);
                                                    } catch (e4) {
                                                      r7(e4);
                                                    }
                                                    n7 = [];
                                                  }).resume();
                                                });
                                                var o2, u2;
                                              }, on: function(e2, t7) {
                                                var r7 = this;
                                                return "data" === e2 ? this._worker.on(e2, function(e3) {
                                                  t7.call(r7, e3.data, e3.meta);
                                                }) : this._worker.on(e2, function() {
                                                  h.delay(t7, arguments, r7);
                                                }), this;
                                              }, resume: function() {
                                                return h.delay(this._worker.resume, [], this._worker), this;
                                              }, pause: function() {
                                                return this._worker.pause(), this;
                                              }, toNodejsStream: function(e2) {
                                                if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
                                                  throw new Error(this._outputType + " is not supported by this method");
                                                return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
                                              } }, t6.exports = u;
                                            }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t6, r6) {
                                              "use strict";
                                              if (r6.base64 = true, r6.array = true, r6.string = true, r6.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r6.nodebuffer = "undefined" != typeof Buffer, r6.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
                                                r6.blob = false;
                                              else {
                                                var n6 = new ArrayBuffer(0);
                                                try {
                                                  r6.blob = 0 === new Blob([n6], { type: "application/zip" }).size;
                                                } catch (e2) {
                                                  try {
                                                    var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                                                    i.append(n6), r6.blob = 0 === i.getBlob("application/zip").size;
                                                  } catch (e3) {
                                                    r6.blob = false;
                                                  }
                                                }
                                              }
                                              try {
                                                r6.nodestream = !!e("readable-stream").Readable;
                                              } catch (e2) {
                                                r6.nodestream = false;
                                              }
                                            }, { "readable-stream": 16 }], 31: [function(e, t6, s) {
                                              "use strict";
                                              for (var o = e("./utils"), u = e("./support"), r6 = e("./nodejsUtils"), n6 = e("./stream/GenericWorker"), h = new Array(256), i = 0; i < 256; i++)
                                                h[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
                                              function a() {
                                                n6.call(this, "utf-8 decode"), this.leftOver = null;
                                              }
                                              function f() {
                                                n6.call(this, "utf-8 encode");
                                              }
                                              h[254] = h[254] = 1, s.utf8encode = function(e2) {
                                                return u.nodebuffer ? r6.newBufferFrom(e2, "utf-8") : function(e3) {
                                                  var t7, r7, n7, i2, s2, a2 = e3.length, o2 = 0;
                                                  for (i2 = 0; i2 < a2; i2++)
                                                    55296 == (64512 & (r7 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n7 = e3.charCodeAt(i2 + 1))) && (r7 = 65536 + (r7 - 55296 << 10) + (n7 - 56320), i2++), o2 += r7 < 128 ? 1 : r7 < 2048 ? 2 : r7 < 65536 ? 3 : 4;
                                                  for (t7 = u.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
                                                    55296 == (64512 & (r7 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n7 = e3.charCodeAt(i2 + 1))) && (r7 = 65536 + (r7 - 55296 << 10) + (n7 - 56320), i2++), r7 < 128 ? t7[s2++] = r7 : (r7 < 2048 ? t7[s2++] = 192 | r7 >>> 6 : (r7 < 65536 ? t7[s2++] = 224 | r7 >>> 12 : (t7[s2++] = 240 | r7 >>> 18, t7[s2++] = 128 | r7 >>> 12 & 63), t7[s2++] = 128 | r7 >>> 6 & 63), t7[s2++] = 128 | 63 & r7);
                                                  return t7;
                                                }(e2);
                                              }, s.utf8decode = function(e2) {
                                                return u.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
                                                  var t7, r7, n7, i2, s2 = e3.length, a2 = new Array(2 * s2);
                                                  for (t7 = r7 = 0; t7 < s2; )
                                                    if ((n7 = e3[t7++]) < 128)
                                                      a2[r7++] = n7;
                                                    else if (4 < (i2 = h[n7]))
                                                      a2[r7++] = 65533, t7 += i2 - 1;
                                                    else {
                                                      for (n7 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t7 < s2; )
                                                        n7 = n7 << 6 | 63 & e3[t7++], i2--;
                                                      1 < i2 ? a2[r7++] = 65533 : n7 < 65536 ? a2[r7++] = n7 : (n7 -= 65536, a2[r7++] = 55296 | n7 >> 10 & 1023, a2[r7++] = 56320 | 1023 & n7);
                                                    }
                                                  return a2.length !== r7 && (a2.subarray ? a2 = a2.subarray(0, r7) : a2.length = r7), o.applyFromCharCode(a2);
                                                }(e2 = o.transformTo(u.uint8array ? "uint8array" : "array", e2));
                                              }, o.inherits(a, n6), a.prototype.processChunk = function(e2) {
                                                var t7 = o.transformTo(u.uint8array ? "uint8array" : "array", e2.data);
                                                if (this.leftOver && this.leftOver.length) {
                                                  if (u.uint8array) {
                                                    var r7 = t7;
                                                    (t7 = new Uint8Array(r7.length + this.leftOver.length)).set(this.leftOver, 0), t7.set(r7, this.leftOver.length);
                                                  } else
                                                    t7 = this.leftOver.concat(t7);
                                                  this.leftOver = null;
                                                }
                                                var n7 = function(e3, t8) {
                                                  var r8;
                                                  for ((t8 = t8 || e3.length) > e3.length && (t8 = e3.length), r8 = t8 - 1; 0 <= r8 && 128 == (192 & e3[r8]); )
                                                    r8--;
                                                  return r8 < 0 ? t8 : 0 === r8 ? t8 : r8 + h[e3[r8]] > t8 ? r8 : t8;
                                                }(t7), i2 = t7;
                                                n7 !== t7.length && (u.uint8array ? (i2 = t7.subarray(0, n7), this.leftOver = t7.subarray(n7, t7.length)) : (i2 = t7.slice(0, n7), this.leftOver = t7.slice(n7, t7.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
                                              }, a.prototype.flush = function() {
                                                this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
                                              }, s.Utf8DecodeWorker = a, o.inherits(f, n6), f.prototype.processChunk = function(e2) {
                                                this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
                                              }, s.Utf8EncodeWorker = f;
                                            }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t6, o) {
                                              "use strict";
                                              var u = e("./support"), h = e("./base64"), r6 = e("./nodejsUtils"), n6 = e("set-immediate-shim"), f = e("./external");
                                              function i(e2) {
                                                return e2;
                                              }
                                              function l6(e2, t7) {
                                                for (var r7 = 0; r7 < e2.length; ++r7)
                                                  t7[r7] = 255 & e2.charCodeAt(r7);
                                                return t7;
                                              }
                                              o.newBlob = function(t7, r7) {
                                                o.checkSupport("blob");
                                                try {
                                                  return new Blob([t7], { type: r7 });
                                                } catch (e2) {
                                                  try {
                                                    var n7 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                                                    return n7.append(t7), n7.getBlob(r7);
                                                  } catch (e3) {
                                                    throw new Error("Bug : can't construct the Blob.");
                                                  }
                                                }
                                              };
                                              var s = { stringifyByChunk: function(e2, t7, r7) {
                                                var n7 = [], i2 = 0, s2 = e2.length;
                                                if (s2 <= r7)
                                                  return String.fromCharCode.apply(null, e2);
                                                for (; i2 < s2; )
                                                  "array" === t7 || "nodebuffer" === t7 ? n7.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r7, s2)))) : n7.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r7, s2)))), i2 += r7;
                                                return n7.join("");
                                              }, stringifyByChar: function(e2) {
                                                for (var t7 = "", r7 = 0; r7 < e2.length; r7++)
                                                  t7 += String.fromCharCode(e2[r7]);
                                                return t7;
                                              }, applyCanBeUsed: { uint8array: function() {
                                                try {
                                                  return u.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
                                                } catch (e2) {
                                                  return false;
                                                }
                                              }(), nodebuffer: function() {
                                                try {
                                                  return u.nodebuffer && 1 === String.fromCharCode.apply(null, r6.allocBuffer(1)).length;
                                                } catch (e2) {
                                                  return false;
                                                }
                                              }() } };
                                              function a(e2) {
                                                var t7 = 65536, r7 = o.getTypeOf(e2), n7 = true;
                                                if ("uint8array" === r7 ? n7 = s.applyCanBeUsed.uint8array : "nodebuffer" === r7 && (n7 = s.applyCanBeUsed.nodebuffer), n7)
                                                  for (; 1 < t7; )
                                                    try {
                                                      return s.stringifyByChunk(e2, r7, t7);
                                                    } catch (e3) {
                                                      t7 = Math.floor(t7 / 2);
                                                    }
                                                return s.stringifyByChar(e2);
                                              }
                                              function d(e2, t7) {
                                                for (var r7 = 0; r7 < e2.length; r7++)
                                                  t7[r7] = e2[r7];
                                                return t7;
                                              }
                                              o.applyFromCharCode = a;
                                              var c = {};
                                              c.string = { string: i, array: function(e2) {
                                                return l6(e2, new Array(e2.length));
                                              }, arraybuffer: function(e2) {
                                                return c.string.uint8array(e2).buffer;
                                              }, uint8array: function(e2) {
                                                return l6(e2, new Uint8Array(e2.length));
                                              }, nodebuffer: function(e2) {
                                                return l6(e2, r6.allocBuffer(e2.length));
                                              } }, c.array = { string: a, array: i, arraybuffer: function(e2) {
                                                return new Uint8Array(e2).buffer;
                                              }, uint8array: function(e2) {
                                                return new Uint8Array(e2);
                                              }, nodebuffer: function(e2) {
                                                return r6.newBufferFrom(e2);
                                              } }, c.arraybuffer = { string: function(e2) {
                                                return a(new Uint8Array(e2));
                                              }, array: function(e2) {
                                                return d(new Uint8Array(e2), new Array(e2.byteLength));
                                              }, arraybuffer: i, uint8array: function(e2) {
                                                return new Uint8Array(e2);
                                              }, nodebuffer: function(e2) {
                                                return r6.newBufferFrom(new Uint8Array(e2));
                                              } }, c.uint8array = { string: a, array: function(e2) {
                                                return d(e2, new Array(e2.length));
                                              }, arraybuffer: function(e2) {
                                                return e2.buffer;
                                              }, uint8array: i, nodebuffer: function(e2) {
                                                return r6.newBufferFrom(e2);
                                              } }, c.nodebuffer = { string: a, array: function(e2) {
                                                return d(e2, new Array(e2.length));
                                              }, arraybuffer: function(e2) {
                                                return c.nodebuffer.uint8array(e2).buffer;
                                              }, uint8array: function(e2) {
                                                return d(e2, new Uint8Array(e2.length));
                                              }, nodebuffer: i }, o.transformTo = function(e2, t7) {
                                                if (t7 = t7 || "", !e2)
                                                  return t7;
                                                o.checkSupport(e2);
                                                var r7 = o.getTypeOf(t7);
                                                return c[r7][e2](t7);
                                              }, o.getTypeOf = function(e2) {
                                                return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : u.nodebuffer && r6.isBuffer(e2) ? "nodebuffer" : u.uint8array && e2 instanceof Uint8Array ? "uint8array" : u.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
                                              }, o.checkSupport = function(e2) {
                                                if (!u[e2.toLowerCase()])
                                                  throw new Error(e2 + " is not supported by this platform");
                                              }, o.MAX_VALUE_16BITS = 65535, o.MAX_VALUE_32BITS = -1, o.pretty = function(e2) {
                                                var t7, r7, n7 = "";
                                                for (r7 = 0; r7 < (e2 || "").length; r7++)
                                                  n7 += "\\x" + ((t7 = e2.charCodeAt(r7)) < 16 ? "0" : "") + t7.toString(16).toUpperCase();
                                                return n7;
                                              }, o.delay = function(e2, t7, r7) {
                                                n6(function() {
                                                  e2.apply(r7 || null, t7 || []);
                                                });
                                              }, o.inherits = function(e2, t7) {
                                                function r7() {
                                                }
                                                r7.prototype = t7.prototype, e2.prototype = new r7();
                                              }, o.extend = function() {
                                                var e2, t7, r7 = {};
                                                for (e2 = 0; e2 < arguments.length; e2++)
                                                  for (t7 in arguments[e2])
                                                    arguments[e2].hasOwnProperty(t7) && void 0 === r7[t7] && (r7[t7] = arguments[e2][t7]);
                                                return r7;
                                              }, o.prepareContent = function(n7, e2, i2, s2, a2) {
                                                return f.Promise.resolve(e2).then(function(n8) {
                                                  return u.blob && (n8 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n8))) && "undefined" != typeof FileReader ? new f.Promise(function(t7, r7) {
                                                    var e3 = new FileReader();
                                                    e3.onload = function(e4) {
                                                      t7(e4.target.result);
                                                    }, e3.onerror = function(e4) {
                                                      r7(e4.target.error);
                                                    }, e3.readAsArrayBuffer(n8);
                                                  }) : n8;
                                                }).then(function(e3) {
                                                  var t7, r7 = o.getTypeOf(e3);
                                                  return r7 ? ("arraybuffer" === r7 ? e3 = o.transformTo("uint8array", e3) : "string" === r7 && (a2 ? e3 = h.decode(e3) : i2 && true !== s2 && (e3 = l6(t7 = e3, u.uint8array ? new Uint8Array(t7.length) : new Array(t7.length)))), e3) : f.Promise.reject(new Error("Can't read the data of '" + n7 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                                                });
                                              };
                                            }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = (e("./utf8"), e("./support"));
                                              function u(e2) {
                                                this.files = [], this.loadOptions = e2;
                                              }
                                              u.prototype = { checkSignature: function(e2) {
                                                if (!this.reader.readAndCheckSignature(e2)) {
                                                  this.reader.index -= 4;
                                                  var t7 = this.reader.readString(4);
                                                  throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t7) + ", expected " + i.pretty(e2) + ")");
                                                }
                                              }, isSignature: function(e2, t7) {
                                                var r7 = this.reader.index;
                                                this.reader.setIndex(e2);
                                                var n7 = this.reader.readString(4) === t7;
                                                return this.reader.setIndex(r7), n7;
                                              }, readBlockEndOfCentral: function() {
                                                this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                                                var e2 = this.reader.readData(this.zipCommentLength), t7 = o.uint8array ? "uint8array" : "array", r7 = i.transformTo(t7, e2);
                                                this.zipComment = this.loadOptions.decodeFileName(r7);
                                              }, readBlockZip64EndOfCentral: function() {
                                                this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                                                for (var e2, t7, r7, n7 = this.zip64EndOfCentralSize - 44; 0 < n7; )
                                                  e2 = this.reader.readInt(2), t7 = this.reader.readInt(4), r7 = this.reader.readData(t7), this.zip64ExtensibleData[e2] = { id: e2, length: t7, value: r7 };
                                              }, readBlockZip64EndOfCentralLocator: function() {
                                                if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
                                                  throw new Error("Multi-volumes zip are not supported");
                                              }, readLocalFiles: function() {
                                                var e2, t7;
                                                for (e2 = 0; e2 < this.files.length; e2++)
                                                  t7 = this.files[e2], this.reader.setIndex(t7.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t7.readLocalPart(this.reader), t7.handleUTF8(), t7.processAttributes();
                                              }, readCentralDir: function() {
                                                var e2;
                                                for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
                                                  (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
                                                if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
                                                  throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                                              }, readEndOfCentral: function() {
                                                var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
                                                if (e2 < 0)
                                                  throw this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                                                this.reader.setIndex(e2);
                                                var t7 = e2;
                                                if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
                                                  if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                                                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                                                  if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                                                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                                                  this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                                                }
                                                var r7 = this.centralDirOffset + this.centralDirSize;
                                                this.zip64 && (r7 += 20, r7 += 12 + this.zip64EndOfCentralSize);
                                                var n7 = t7 - r7;
                                                if (0 < n7)
                                                  this.isSignature(t7, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n7);
                                                else if (n7 < 0)
                                                  throw new Error("Corrupted zip: missing " + Math.abs(n7) + " bytes.");
                                              }, prepareReader: function(e2) {
                                                this.reader = n6(e2);
                                              }, load: function(e2) {
                                                this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                                              } }, t6.exports = u;
                                            }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), u = e("./compressions"), h = e("./support");
                                              function f(e2, t7) {
                                                this.options = e2, this.loadOptions = t7;
                                              }
                                              f.prototype = { isEncrypted: function() {
                                                return 1 == (1 & this.bitFlag);
                                              }, useUTF8: function() {
                                                return 2048 == (2048 & this.bitFlag);
                                              }, readLocalPart: function(e2) {
                                                var t7, r7;
                                                if (e2.skip(22), this.fileNameLength = e2.readInt(2), r7 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r7), -1 === this.compressedSize || -1 === this.uncompressedSize)
                                                  throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                                                if (null === (t7 = function(e3) {
                                                  for (var t8 in u)
                                                    if (u.hasOwnProperty(t8) && u[t8].magic === e3)
                                                      return u[t8];
                                                  return null;
                                                }(this.compressionMethod)))
                                                  throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
                                                this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t7, e2.readData(this.compressedSize));
                                              }, readCentralPart: function(e2) {
                                                this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
                                                var t7 = e2.readInt(2);
                                                if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
                                                  throw new Error("Encrypted zip are not supported");
                                                e2.skip(t7), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
                                              }, processAttributes: function() {
                                                this.unixPermissions = null, this.dosPermissions = null;
                                                var e2 = this.versionMadeBy >> 8;
                                                this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
                                              }, parseZIP64ExtraField: function(e2) {
                                                if (this.extraFields[1]) {
                                                  var t7 = n6(this.extraFields[1].value);
                                                  this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = t7.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = t7.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = t7.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = t7.readInt(4));
                                                }
                                              }, readExtraFields: function(e2) {
                                                var t7, r7, n7, i2 = e2.index + this.extraFieldsLength;
                                                for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
                                                  t7 = e2.readInt(2), r7 = e2.readInt(2), n7 = e2.readData(r7), this.extraFields[t7] = { id: t7, length: r7, value: n7 };
                                                e2.setIndex(i2);
                                              }, handleUTF8: function() {
                                                var e2 = h.uint8array ? "uint8array" : "array";
                                                if (this.useUTF8())
                                                  this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
                                                else {
                                                  var t7 = this.findExtraFieldUnicodePath();
                                                  if (null !== t7)
                                                    this.fileNameStr = t7;
                                                  else {
                                                    var r7 = s.transformTo(e2, this.fileName);
                                                    this.fileNameStr = this.loadOptions.decodeFileName(r7);
                                                  }
                                                  var n7 = this.findExtraFieldUnicodeComment();
                                                  if (null !== n7)
                                                    this.fileCommentStr = n7;
                                                  else {
                                                    var i2 = s.transformTo(e2, this.fileComment);
                                                    this.fileCommentStr = this.loadOptions.decodeFileName(i2);
                                                  }
                                                }
                                              }, findExtraFieldUnicodePath: function() {
                                                var e2 = this.extraFields[28789];
                                                if (e2) {
                                                  var t7 = n6(e2.value);
                                                  return 1 !== t7.readInt(1) ? null : a(this.fileName) !== t7.readInt(4) ? null : o.utf8decode(t7.readData(e2.length - 5));
                                                }
                                                return null;
                                              }, findExtraFieldUnicodeComment: function() {
                                                var e2 = this.extraFields[25461];
                                                if (e2) {
                                                  var t7 = n6(e2.value);
                                                  return 1 !== t7.readInt(1) ? null : a(this.fileComment) !== t7.readInt(4) ? null : o.utf8decode(t7.readData(e2.length - 5));
                                                }
                                                return null;
                                              } }, t6.exports = f;
                                            }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t6, r6) {
                                              "use strict";
                                              function n6(e2, t7, r7) {
                                                this.name = e2, this.dir = r7.dir, this.date = r7.date, this.comment = r7.comment, this.unixPermissions = r7.unixPermissions, this.dosPermissions = r7.dosPermissions, this._data = t7, this._dataBinary = r7.binary, this.options = { compression: r7.compression, compressionOptions: r7.compressionOptions };
                                              }
                                              var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), u = e("./stream/GenericWorker");
                                              n6.prototype = { internalStream: function(e2) {
                                                var t7 = null, r7 = "string";
                                                try {
                                                  if (!e2)
                                                    throw new Error("No output type specified.");
                                                  var n7 = "string" === (r7 = e2.toLowerCase()) || "text" === r7;
                                                  "binarystring" !== r7 && "text" !== r7 || (r7 = "string"), t7 = this._decompressWorker();
                                                  var i2 = !this._dataBinary;
                                                  i2 && !n7 && (t7 = t7.pipe(new a.Utf8EncodeWorker())), !i2 && n7 && (t7 = t7.pipe(new a.Utf8DecodeWorker()));
                                                } catch (e3) {
                                                  (t7 = new u("error")).error(e3);
                                                }
                                                return new s(t7, r7, "");
                                              }, async: function(e2, t7) {
                                                return this.internalStream(e2).accumulate(t7);
                                              }, nodeStream: function(e2, t7) {
                                                return this.internalStream(e2 || "nodebuffer").toNodejsStream(t7);
                                              }, _compressWorker: function(e2, t7) {
                                                if (this._data instanceof o && this._data.compression.magic === e2.magic)
                                                  return this._data.getCompressedWorker();
                                                var r7 = this._decompressWorker();
                                                return this._dataBinary || (r7 = r7.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r7, e2, t7);
                                              }, _decompressWorker: function() {
                                                return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof u ? this._data : new i(this._data);
                                              } };
                                              for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
                                                throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                                              }, l6 = 0; l6 < h.length; l6++)
                                                n6.prototype[h[l6]] = f;
                                              t6.exports = n6;
                                            }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, f, t6) {
                                              (function(t7) {
                                                "use strict";
                                                var r6, n6, e2 = t7.MutationObserver || t7.WebKitMutationObserver;
                                                if (e2) {
                                                  var i = 0, s = new e2(h), a = t7.document.createTextNode("");
                                                  s.observe(a, { characterData: true }), r6 = function() {
                                                    a.data = i = ++i % 2;
                                                  };
                                                } else if (t7.setImmediate || void 0 === t7.MessageChannel)
                                                  r6 = "document" in t7 && "onreadystatechange" in t7.document.createElement("script") ? function() {
                                                    var e3 = t7.document.createElement("script");
                                                    e3.onreadystatechange = function() {
                                                      h(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
                                                    }, t7.document.documentElement.appendChild(e3);
                                                  } : function() {
                                                    setTimeout(h, 0);
                                                  };
                                                else {
                                                  var o = new t7.MessageChannel();
                                                  o.port1.onmessage = h, r6 = function() {
                                                    o.port2.postMessage(0);
                                                  };
                                                }
                                                var u = [];
                                                function h() {
                                                  var e3, t8;
                                                  n6 = true;
                                                  for (var r7 = u.length; r7; ) {
                                                    for (t8 = u, u = [], e3 = -1; ++e3 < r7; )
                                                      t8[e3]();
                                                    r7 = u.length;
                                                  }
                                                  n6 = false;
                                                }
                                                f.exports = function(e3) {
                                                  1 !== u.push(e3) || n6 || r6();
                                                };
                                              }).call(this, void 0 !== r5 ? r5 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                                            }, {}], 37: [function(e, t6, r6) {
                                              "use strict";
                                              var i = e("immediate");
                                              function h() {
                                              }
                                              var f = {}, s = ["REJECTED"], a = ["FULFILLED"], n6 = ["PENDING"];
                                              function o(e2) {
                                                if ("function" != typeof e2)
                                                  throw new TypeError("resolver must be a function");
                                                this.state = n6, this.queue = [], this.outcome = void 0, e2 !== h && c(this, e2);
                                              }
                                              function u(e2, t7, r7) {
                                                this.promise = e2, "function" == typeof t7 && (this.onFulfilled = t7, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r7 && (this.onRejected = r7, this.callRejected = this.otherCallRejected);
                                              }
                                              function l6(t7, r7, n7) {
                                                i(function() {
                                                  var e2;
                                                  try {
                                                    e2 = r7(n7);
                                                  } catch (e3) {
                                                    return f.reject(t7, e3);
                                                  }
                                                  e2 === t7 ? f.reject(t7, new TypeError("Cannot resolve promise with itself")) : f.resolve(t7, e2);
                                                });
                                              }
                                              function d(e2) {
                                                var t7 = e2 && e2.then;
                                                if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t7)
                                                  return function() {
                                                    t7.apply(e2, arguments);
                                                  };
                                              }
                                              function c(t7, e2) {
                                                var r7 = false;
                                                function n7(e3) {
                                                  r7 || (r7 = true, f.reject(t7, e3));
                                                }
                                                function i2(e3) {
                                                  r7 || (r7 = true, f.resolve(t7, e3));
                                                }
                                                var s2 = p(function() {
                                                  e2(i2, n7);
                                                });
                                                "error" === s2.status && n7(s2.value);
                                              }
                                              function p(e2, t7) {
                                                var r7 = {};
                                                try {
                                                  r7.value = e2(t7), r7.status = "success";
                                                } catch (e3) {
                                                  r7.status = "error", r7.value = e3;
                                                }
                                                return r7;
                                              }
                                              (t6.exports = o).prototype.finally = function(t7) {
                                                if ("function" != typeof t7)
                                                  return this;
                                                var r7 = this.constructor;
                                                return this.then(function(e2) {
                                                  return r7.resolve(t7()).then(function() {
                                                    return e2;
                                                  });
                                                }, function(e2) {
                                                  return r7.resolve(t7()).then(function() {
                                                    throw e2;
                                                  });
                                                });
                                              }, o.prototype.catch = function(e2) {
                                                return this.then(null, e2);
                                              }, o.prototype.then = function(e2, t7) {
                                                if ("function" != typeof e2 && this.state === a || "function" != typeof t7 && this.state === s)
                                                  return this;
                                                var r7 = new this.constructor(h);
                                                return this.state !== n6 ? l6(r7, this.state === a ? e2 : t7, this.outcome) : this.queue.push(new u(r7, e2, t7)), r7;
                                              }, u.prototype.callFulfilled = function(e2) {
                                                f.resolve(this.promise, e2);
                                              }, u.prototype.otherCallFulfilled = function(e2) {
                                                l6(this.promise, this.onFulfilled, e2);
                                              }, u.prototype.callRejected = function(e2) {
                                                f.reject(this.promise, e2);
                                              }, u.prototype.otherCallRejected = function(e2) {
                                                l6(this.promise, this.onRejected, e2);
                                              }, f.resolve = function(e2, t7) {
                                                var r7 = p(d, t7);
                                                if ("error" === r7.status)
                                                  return f.reject(e2, r7.value);
                                                var n7 = r7.value;
                                                if (n7)
                                                  c(e2, n7);
                                                else {
                                                  e2.state = a, e2.outcome = t7;
                                                  for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
                                                    e2.queue[i2].callFulfilled(t7);
                                                }
                                                return e2;
                                              }, f.reject = function(e2, t7) {
                                                e2.state = s, e2.outcome = t7;
                                                for (var r7 = -1, n7 = e2.queue.length; ++r7 < n7; )
                                                  e2.queue[r7].callRejected(t7);
                                                return e2;
                                              }, o.resolve = function(e2) {
                                                return e2 instanceof this ? e2 : f.resolve(new this(h), e2);
                                              }, o.reject = function(e2) {
                                                var t7 = new this(h);
                                                return f.reject(t7, e2);
                                              }, o.all = function(e2) {
                                                var r7 = this;
                                                if ("[object Array]" !== Object.prototype.toString.call(e2))
                                                  return this.reject(new TypeError("must be an array"));
                                                var n7 = e2.length, i2 = false;
                                                if (!n7)
                                                  return this.resolve([]);
                                                for (var s2 = new Array(n7), a2 = 0, t7 = -1, o2 = new this(h); ++t7 < n7; )
                                                  u2(e2[t7], t7);
                                                return o2;
                                                function u2(e3, t8) {
                                                  r7.resolve(e3).then(function(e4) {
                                                    s2[t8] = e4, ++a2 !== n7 || i2 || (i2 = true, f.resolve(o2, s2));
                                                  }, function(e4) {
                                                    i2 || (i2 = true, f.reject(o2, e4));
                                                  });
                                                }
                                              }, o.race = function(e2) {
                                                if ("[object Array]" !== Object.prototype.toString.call(e2))
                                                  return this.reject(new TypeError("must be an array"));
                                                var t7 = e2.length, r7 = false;
                                                if (!t7)
                                                  return this.resolve([]);
                                                for (var n7, i2 = -1, s2 = new this(h); ++i2 < t7; )
                                                  n7 = e2[i2], this.resolve(n7).then(function(e3) {
                                                    r7 || (r7 = true, f.resolve(s2, e3));
                                                  }, function(e3) {
                                                    r7 || (r7 = true, f.reject(s2, e3));
                                                  });
                                                return s2;
                                              };
                                            }, { immediate: 36 }], 38: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = {};
                                              (0, e("./lib/utils/common").assign)(n6, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t6.exports = n6;
                                            }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t6, r6) {
                                              "use strict";
                                              var a = e("./zlib/deflate"), o = e("./utils/common"), u = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), h = Object.prototype.toString, f = 0, l6 = -1, d = 0, c = 8;
                                              function p(e2) {
                                                if (!(this instanceof p))
                                                  return new p(e2);
                                                this.options = o.assign({ level: l6, method: c, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, e2 || {});
                                                var t7 = this.options;
                                                t7.raw && 0 < t7.windowBits ? t7.windowBits = -t7.windowBits : t7.gzip && 0 < t7.windowBits && t7.windowBits < 16 && (t7.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
                                                var r7 = a.deflateInit2(this.strm, t7.level, t7.method, t7.windowBits, t7.memLevel, t7.strategy);
                                                if (r7 !== f)
                                                  throw new Error(i[r7]);
                                                if (t7.header && a.deflateSetHeader(this.strm, t7.header), t7.dictionary) {
                                                  var n7;
                                                  if (n7 = "string" == typeof t7.dictionary ? u.string2buf(t7.dictionary) : "[object ArrayBuffer]" === h.call(t7.dictionary) ? new Uint8Array(t7.dictionary) : t7.dictionary, (r7 = a.deflateSetDictionary(this.strm, n7)) !== f)
                                                    throw new Error(i[r7]);
                                                  this._dict_set = true;
                                                }
                                              }
                                              function n6(e2, t7) {
                                                var r7 = new p(t7);
                                                if (r7.push(e2, true), r7.err)
                                                  throw r7.msg || i[r7.err];
                                                return r7.result;
                                              }
                                              p.prototype.push = function(e2, t7) {
                                                var r7, n7, i2 = this.strm, s2 = this.options.chunkSize;
                                                if (this.ended)
                                                  return false;
                                                n7 = t7 === ~~t7 ? t7 : true === t7 ? 4 : 0, "string" == typeof e2 ? i2.input = u.string2buf(e2) : "[object ArrayBuffer]" === h.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
                                                do {
                                                  if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r7 = a.deflate(i2, n7)) && r7 !== f)
                                                    return this.onEnd(r7), !(this.ended = true);
                                                  0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n7 && 2 !== n7) || ("string" === this.options.to ? this.onData(u.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
                                                } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r7);
                                                return 4 === n7 ? (r7 = a.deflateEnd(this.strm), this.onEnd(r7), this.ended = true, r7 === f) : 2 !== n7 || (this.onEnd(f), !(i2.avail_out = 0));
                                              }, p.prototype.onData = function(e2) {
                                                this.chunks.push(e2);
                                              }, p.prototype.onEnd = function(e2) {
                                                e2 === f && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
                                              }, r6.Deflate = p, r6.deflate = n6, r6.deflateRaw = function(e2, t7) {
                                                return (t7 = t7 || {}).raw = true, n6(e2, t7);
                                              }, r6.gzip = function(e2, t7) {
                                                return (t7 = t7 || {}).gzip = true, n6(e2, t7);
                                              };
                                            }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t6, r6) {
                                              "use strict";
                                              var d = e("./zlib/inflate"), c = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n6 = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
                                              function a(e2) {
                                                if (!(this instanceof a))
                                                  return new a(e2);
                                                this.options = c.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
                                                var t7 = this.options;
                                                t7.raw && 0 <= t7.windowBits && t7.windowBits < 16 && (t7.windowBits = -t7.windowBits, 0 === t7.windowBits && (t7.windowBits = -15)), !(0 <= t7.windowBits && t7.windowBits < 16) || e2 && e2.windowBits || (t7.windowBits += 32), 15 < t7.windowBits && t7.windowBits < 48 && 0 == (15 & t7.windowBits) && (t7.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
                                                var r7 = d.inflateInit2(this.strm, t7.windowBits);
                                                if (r7 !== m.Z_OK)
                                                  throw new Error(n6[r7]);
                                                this.header = new s(), d.inflateGetHeader(this.strm, this.header);
                                              }
                                              function o(e2, t7) {
                                                var r7 = new a(t7);
                                                if (r7.push(e2, true), r7.err)
                                                  throw r7.msg || n6[r7.err];
                                                return r7.result;
                                              }
                                              a.prototype.push = function(e2, t7) {
                                                var r7, n7, i2, s2, a2, o2, u = this.strm, h = this.options.chunkSize, f = this.options.dictionary, l6 = false;
                                                if (this.ended)
                                                  return false;
                                                n7 = t7 === ~~t7 ? t7 : true === t7 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? u.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? u.input = new Uint8Array(e2) : u.input = e2, u.next_in = 0, u.avail_in = u.input.length;
                                                do {
                                                  if (0 === u.avail_out && (u.output = new c.Buf8(h), u.next_out = 0, u.avail_out = h), (r7 = d.inflate(u, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && f && (o2 = "string" == typeof f ? p.string2buf(f) : "[object ArrayBuffer]" === _.call(f) ? new Uint8Array(f) : f, r7 = d.inflateSetDictionary(this.strm, o2)), r7 === m.Z_BUF_ERROR && true === l6 && (r7 = m.Z_OK, l6 = false), r7 !== m.Z_STREAM_END && r7 !== m.Z_OK)
                                                    return this.onEnd(r7), !(this.ended = true);
                                                  u.next_out && (0 !== u.avail_out && r7 !== m.Z_STREAM_END && (0 !== u.avail_in || n7 !== m.Z_FINISH && n7 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(u.output, u.next_out), s2 = u.next_out - i2, a2 = p.buf2string(u.output, i2), u.next_out = s2, u.avail_out = h - s2, s2 && c.arraySet(u.output, u.output, i2, s2, 0), this.onData(a2)) : this.onData(c.shrinkBuf(u.output, u.next_out)))), 0 === u.avail_in && 0 === u.avail_out && (l6 = true);
                                                } while ((0 < u.avail_in || 0 === u.avail_out) && r7 !== m.Z_STREAM_END);
                                                return r7 === m.Z_STREAM_END && (n7 = m.Z_FINISH), n7 === m.Z_FINISH ? (r7 = d.inflateEnd(this.strm), this.onEnd(r7), this.ended = true, r7 === m.Z_OK) : n7 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(u.avail_out = 0));
                                              }, a.prototype.onData = function(e2) {
                                                this.chunks.push(e2);
                                              }, a.prototype.onEnd = function(e2) {
                                                e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = c.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
                                              }, r6.Inflate = a, r6.inflate = o, r6.inflateRaw = function(e2, t7) {
                                                return (t7 = t7 || {}).raw = true, o(e2, t7);
                                              }, r6.ungzip = o;
                                            }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t6, r6) {
                                              "use strict";
                                              var n6 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
                                              r6.assign = function(e2) {
                                                for (var t7 = Array.prototype.slice.call(arguments, 1); t7.length; ) {
                                                  var r7 = t7.shift();
                                                  if (r7) {
                                                    if ("object" != typeof r7)
                                                      throw new TypeError(r7 + "must be non-object");
                                                    for (var n7 in r7)
                                                      r7.hasOwnProperty(n7) && (e2[n7] = r7[n7]);
                                                  }
                                                }
                                                return e2;
                                              }, r6.shrinkBuf = function(e2, t7) {
                                                return e2.length === t7 ? e2 : e2.subarray ? e2.subarray(0, t7) : (e2.length = t7, e2);
                                              };
                                              var i = { arraySet: function(e2, t7, r7, n7, i2) {
                                                if (t7.subarray && e2.subarray)
                                                  e2.set(t7.subarray(r7, r7 + n7), i2);
                                                else
                                                  for (var s2 = 0; s2 < n7; s2++)
                                                    e2[i2 + s2] = t7[r7 + s2];
                                              }, flattenChunks: function(e2) {
                                                var t7, r7, n7, i2, s2, a;
                                                for (t7 = n7 = 0, r7 = e2.length; t7 < r7; t7++)
                                                  n7 += e2[t7].length;
                                                for (a = new Uint8Array(n7), t7 = i2 = 0, r7 = e2.length; t7 < r7; t7++)
                                                  s2 = e2[t7], a.set(s2, i2), i2 += s2.length;
                                                return a;
                                              } }, s = { arraySet: function(e2, t7, r7, n7, i2) {
                                                for (var s2 = 0; s2 < n7; s2++)
                                                  e2[i2 + s2] = t7[r7 + s2];
                                              }, flattenChunks: function(e2) {
                                                return [].concat.apply([], e2);
                                              } };
                                              r6.setTyped = function(e2) {
                                                e2 ? (r6.Buf8 = Uint8Array, r6.Buf16 = Uint16Array, r6.Buf32 = Int32Array, r6.assign(r6, i)) : (r6.Buf8 = Array, r6.Buf16 = Array, r6.Buf32 = Array, r6.assign(r6, s));
                                              }, r6.setTyped(n6);
                                            }, {}], 42: [function(e, t6, r6) {
                                              "use strict";
                                              var u = e("./common"), i = true, s = true;
                                              try {
                                                String.fromCharCode.apply(null, [0]);
                                              } catch (e2) {
                                                i = false;
                                              }
                                              try {
                                                String.fromCharCode.apply(null, new Uint8Array(1));
                                              } catch (e2) {
                                                s = false;
                                              }
                                              for (var h = new u.Buf8(256), n6 = 0; n6 < 256; n6++)
                                                h[n6] = 252 <= n6 ? 6 : 248 <= n6 ? 5 : 240 <= n6 ? 4 : 224 <= n6 ? 3 : 192 <= n6 ? 2 : 1;
                                              function f(e2, t7) {
                                                if (t7 < 65537 && (e2.subarray && s || !e2.subarray && i))
                                                  return String.fromCharCode.apply(null, u.shrinkBuf(e2, t7));
                                                for (var r7 = "", n7 = 0; n7 < t7; n7++)
                                                  r7 += String.fromCharCode(e2[n7]);
                                                return r7;
                                              }
                                              h[254] = h[254] = 1, r6.string2buf = function(e2) {
                                                var t7, r7, n7, i2, s2, a = e2.length, o = 0;
                                                for (i2 = 0; i2 < a; i2++)
                                                  55296 == (64512 & (r7 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n7 = e2.charCodeAt(i2 + 1))) && (r7 = 65536 + (r7 - 55296 << 10) + (n7 - 56320), i2++), o += r7 < 128 ? 1 : r7 < 2048 ? 2 : r7 < 65536 ? 3 : 4;
                                                for (t7 = new u.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
                                                  55296 == (64512 & (r7 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n7 = e2.charCodeAt(i2 + 1))) && (r7 = 65536 + (r7 - 55296 << 10) + (n7 - 56320), i2++), r7 < 128 ? t7[s2++] = r7 : (r7 < 2048 ? t7[s2++] = 192 | r7 >>> 6 : (r7 < 65536 ? t7[s2++] = 224 | r7 >>> 12 : (t7[s2++] = 240 | r7 >>> 18, t7[s2++] = 128 | r7 >>> 12 & 63), t7[s2++] = 128 | r7 >>> 6 & 63), t7[s2++] = 128 | 63 & r7);
                                                return t7;
                                              }, r6.buf2binstring = function(e2) {
                                                return f(e2, e2.length);
                                              }, r6.binstring2buf = function(e2) {
                                                for (var t7 = new u.Buf8(e2.length), r7 = 0, n7 = t7.length; r7 < n7; r7++)
                                                  t7[r7] = e2.charCodeAt(r7);
                                                return t7;
                                              }, r6.buf2string = function(e2, t7) {
                                                var r7, n7, i2, s2, a = t7 || e2.length, o = new Array(2 * a);
                                                for (r7 = n7 = 0; r7 < a; )
                                                  if ((i2 = e2[r7++]) < 128)
                                                    o[n7++] = i2;
                                                  else if (4 < (s2 = h[i2]))
                                                    o[n7++] = 65533, r7 += s2 - 1;
                                                  else {
                                                    for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r7 < a; )
                                                      i2 = i2 << 6 | 63 & e2[r7++], s2--;
                                                    1 < s2 ? o[n7++] = 65533 : i2 < 65536 ? o[n7++] = i2 : (i2 -= 65536, o[n7++] = 55296 | i2 >> 10 & 1023, o[n7++] = 56320 | 1023 & i2);
                                                  }
                                                return f(o, n7);
                                              }, r6.utf8border = function(e2, t7) {
                                                var r7;
                                                for ((t7 = t7 || e2.length) > e2.length && (t7 = e2.length), r7 = t7 - 1; 0 <= r7 && 128 == (192 & e2[r7]); )
                                                  r7--;
                                                return r7 < 0 ? t7 : 0 === r7 ? t7 : r7 + h[e2[r7]] > t7 ? r7 : t7;
                                              };
                                            }, { "./common": 41 }], 43: [function(e, t6, r6) {
                                              "use strict";
                                              t6.exports = function(e2, t7, r7, n6) {
                                                for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r7; ) {
                                                  for (r7 -= a = 2e3 < r7 ? 2e3 : r7; s = s + (i = i + t7[n6++] | 0) | 0, --a; )
                                                    ;
                                                  i %= 65521, s %= 65521;
                                                }
                                                return i | s << 16 | 0;
                                              };
                                            }, {}], 44: [function(e, t6, r6) {
                                              "use strict";
                                              t6.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
                                            }, {}], 45: [function(e, t6, r6) {
                                              "use strict";
                                              var o = function() {
                                                for (var e2, t7 = [], r7 = 0; r7 < 256; r7++) {
                                                  e2 = r7;
                                                  for (var n6 = 0; n6 < 8; n6++)
                                                    e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
                                                  t7[r7] = e2;
                                                }
                                                return t7;
                                              }();
                                              t6.exports = function(e2, t7, r7, n6) {
                                                var i = o, s = n6 + r7;
                                                e2 ^= -1;
                                                for (var a = n6; a < s; a++)
                                                  e2 = e2 >>> 8 ^ i[255 & (e2 ^ t7[a])];
                                                return -1 ^ e2;
                                              };
                                            }, {}], 46: [function(e, t6, r6) {
                                              "use strict";
                                              var u, d = e("../utils/common"), h = e("./trees"), c = e("./adler32"), p = e("./crc32"), n6 = e("./messages"), f = 0, l6 = 0, m = -2, i = 2, _ = 8, s = 286, a = 30, o = 19, g = 2 * s + 1, v = 15, b = 3, w = 258, y = w + b + 1, k = 42, x = 113;
                                              function S(e2, t7) {
                                                return e2.msg = n6[t7], t7;
                                              }
                                              function z(e2) {
                                                return (e2 << 1) - (4 < e2 ? 9 : 0);
                                              }
                                              function E(e2) {
                                                for (var t7 = e2.length; 0 <= --t7; )
                                                  e2[t7] = 0;
                                              }
                                              function C(e2) {
                                                var t7 = e2.state, r7 = t7.pending;
                                                r7 > e2.avail_out && (r7 = e2.avail_out), 0 !== r7 && (d.arraySet(e2.output, t7.pending_buf, t7.pending_out, r7, e2.next_out), e2.next_out += r7, t7.pending_out += r7, e2.total_out += r7, e2.avail_out -= r7, t7.pending -= r7, 0 === t7.pending && (t7.pending_out = 0));
                                              }
                                              function A(e2, t7) {
                                                h._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t7), e2.block_start = e2.strstart, C(e2.strm);
                                              }
                                              function I(e2, t7) {
                                                e2.pending_buf[e2.pending++] = t7;
                                              }
                                              function O(e2, t7) {
                                                e2.pending_buf[e2.pending++] = t7 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t7;
                                              }
                                              function B(e2, t7) {
                                                var r7, n7, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, u2 = e2.strstart > e2.w_size - y ? e2.strstart - (e2.w_size - y) : 0, h2 = e2.window, f2 = e2.w_mask, l7 = e2.prev, d2 = e2.strstart + w, c2 = h2[s2 + a2 - 1], p2 = h2[s2 + a2];
                                                e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
                                                do {
                                                  if (h2[(r7 = t7) + a2] === p2 && h2[r7 + a2 - 1] === c2 && h2[r7] === h2[s2] && h2[++r7] === h2[s2 + 1]) {
                                                    s2 += 2, r7++;
                                                    do {
                                                    } while (h2[++s2] === h2[++r7] && h2[++s2] === h2[++r7] && h2[++s2] === h2[++r7] && h2[++s2] === h2[++r7] && h2[++s2] === h2[++r7] && h2[++s2] === h2[++r7] && h2[++s2] === h2[++r7] && h2[++s2] === h2[++r7] && s2 < d2);
                                                    if (n7 = w - (d2 - s2), s2 = d2 - w, a2 < n7) {
                                                      if (e2.match_start = t7, o2 <= (a2 = n7))
                                                        break;
                                                      c2 = h2[s2 + a2 - 1], p2 = h2[s2 + a2];
                                                    }
                                                  }
                                                } while ((t7 = l7[t7 & f2]) > u2 && 0 != --i2);
                                                return a2 <= e2.lookahead ? a2 : e2.lookahead;
                                              }
                                              function T(e2) {
                                                var t7, r7, n7, i2, s2, a2, o2, u2, h2, f2, l7 = e2.w_size;
                                                do {
                                                  if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= l7 + (l7 - y)) {
                                                    for (d.arraySet(e2.window, e2.window, l7, l7, 0), e2.match_start -= l7, e2.strstart -= l7, e2.block_start -= l7, t7 = r7 = e2.hash_size; n7 = e2.head[--t7], e2.head[t7] = l7 <= n7 ? n7 - l7 : 0, --r7; )
                                                      ;
                                                    for (t7 = r7 = l7; n7 = e2.prev[--t7], e2.prev[t7] = l7 <= n7 ? n7 - l7 : 0, --r7; )
                                                      ;
                                                    i2 += l7;
                                                  }
                                                  if (0 === e2.strm.avail_in)
                                                    break;
                                                  if (a2 = e2.strm, o2 = e2.window, u2 = e2.strstart + e2.lookahead, f2 = void 0, (h2 = i2) < (f2 = a2.avail_in) && (f2 = h2), r7 = 0 === f2 ? 0 : (a2.avail_in -= f2, d.arraySet(o2, a2.input, a2.next_in, f2, u2), 1 === a2.state.wrap ? a2.adler = c(a2.adler, o2, f2, u2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, f2, u2)), a2.next_in += f2, a2.total_in += f2, f2), e2.lookahead += r7, e2.lookahead + e2.insert >= b)
                                                    for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + b - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < b)); )
                                                      ;
                                                } while (e2.lookahead < y && 0 !== e2.strm.avail_in);
                                              }
                                              function R(e2, t7) {
                                                for (var r7, n7; ; ) {
                                                  if (e2.lookahead < y) {
                                                    if (T(e2), e2.lookahead < y && t7 === f)
                                                      return 1;
                                                    if (0 === e2.lookahead)
                                                      break;
                                                  }
                                                  if (r7 = 0, e2.lookahead >= b && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + b - 1]) & e2.hash_mask, r7 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r7 && e2.strstart - r7 <= e2.w_size - y && (e2.match_length = B(e2, r7)), e2.match_length >= b)
                                                    if (n7 = h._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - b), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= b) {
                                                      for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + b - 1]) & e2.hash_mask, r7 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                                                        ;
                                                      e2.strstart++;
                                                    } else
                                                      e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
                                                  else
                                                    n7 = h._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
                                                  if (n7 && (A(e2, false), 0 === e2.strm.avail_out))
                                                    return 1;
                                                }
                                                return e2.insert = e2.strstart < b - 1 ? e2.strstart : b - 1, 4 === t7 ? (A(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.last_lit && (A(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
                                              }
                                              function D(e2, t7) {
                                                for (var r7, n7, i2; ; ) {
                                                  if (e2.lookahead < y) {
                                                    if (T(e2), e2.lookahead < y && t7 === f)
                                                      return 1;
                                                    if (0 === e2.lookahead)
                                                      break;
                                                  }
                                                  if (r7 = 0, e2.lookahead >= b && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + b - 1]) & e2.hash_mask, r7 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = b - 1, 0 !== r7 && e2.prev_length < e2.max_lazy_match && e2.strstart - r7 <= e2.w_size - y && (e2.match_length = B(e2, r7), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === b && 4096 < e2.strstart - e2.match_start) && (e2.match_length = b - 1)), e2.prev_length >= b && e2.match_length <= e2.prev_length) {
                                                    for (i2 = e2.strstart + e2.lookahead - b, n7 = h._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - b), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + b - 1]) & e2.hash_mask, r7 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                                                      ;
                                                    if (e2.match_available = 0, e2.match_length = b - 1, e2.strstart++, n7 && (A(e2, false), 0 === e2.strm.avail_out))
                                                      return 1;
                                                  } else if (e2.match_available) {
                                                    if ((n7 = h._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && A(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                                                      return 1;
                                                  } else
                                                    e2.match_available = 1, e2.strstart++, e2.lookahead--;
                                                }
                                                return e2.match_available && (n7 = h._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < b - 1 ? e2.strstart : b - 1, 4 === t7 ? (A(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.last_lit && (A(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
                                              }
                                              function F(e2, t7, r7, n7, i2) {
                                                this.good_length = e2, this.max_lazy = t7, this.nice_length = r7, this.max_chain = n7, this.func = i2;
                                              }
                                              function N() {
                                                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = _, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new d.Buf16(2 * g), this.dyn_dtree = new d.Buf16(2 * (2 * a + 1)), this.bl_tree = new d.Buf16(2 * (2 * o + 1)), E(this.dyn_ltree), E(this.dyn_dtree), E(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new d.Buf16(v + 1), this.heap = new d.Buf16(2 * s + 1), E(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new d.Buf16(2 * s + 1), E(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
                                              }
                                              function U(e2) {
                                                var t7;
                                                return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t7 = e2.state).pending = 0, t7.pending_out = 0, t7.wrap < 0 && (t7.wrap = -t7.wrap), t7.status = t7.wrap ? k : x, e2.adler = 2 === t7.wrap ? 0 : 1, t7.last_flush = f, h._tr_init(t7), l6) : S(e2, m);
                                              }
                                              function P(e2) {
                                                var t7, r7 = U(e2);
                                                return r7 === l6 && ((t7 = e2.state).window_size = 2 * t7.w_size, E(t7.head), t7.max_lazy_match = u[t7.level].max_lazy, t7.good_match = u[t7.level].good_length, t7.nice_match = u[t7.level].nice_length, t7.max_chain_length = u[t7.level].max_chain, t7.strstart = 0, t7.block_start = 0, t7.lookahead = 0, t7.insert = 0, t7.match_length = t7.prev_length = b - 1, t7.match_available = 0, t7.ins_h = 0), r7;
                                              }
                                              function L(e2, t7, r7, n7, i2, s2) {
                                                if (!e2)
                                                  return m;
                                                var a2 = 1;
                                                if (-1 === t7 && (t7 = 6), n7 < 0 ? (a2 = 0, n7 = -n7) : 15 < n7 && (a2 = 2, n7 -= 16), i2 < 1 || 9 < i2 || r7 !== _ || n7 < 8 || 15 < n7 || t7 < 0 || 9 < t7 || s2 < 0 || 4 < s2)
                                                  return S(e2, m);
                                                8 === n7 && (n7 = 9);
                                                var o2 = new N();
                                                return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n7, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + b - 1) / b), o2.window = new d.Buf8(2 * o2.w_size), o2.head = new d.Buf16(o2.hash_size), o2.prev = new d.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new d.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t7, o2.strategy = s2, o2.method = r7, P(e2);
                                              }
                                              u = [new F(0, 0, 0, 0, function(e2, t7) {
                                                var r7 = 65535;
                                                for (r7 > e2.pending_buf_size - 5 && (r7 = e2.pending_buf_size - 5); ; ) {
                                                  if (e2.lookahead <= 1) {
                                                    if (T(e2), 0 === e2.lookahead && t7 === f)
                                                      return 1;
                                                    if (0 === e2.lookahead)
                                                      break;
                                                  }
                                                  e2.strstart += e2.lookahead, e2.lookahead = 0;
                                                  var n7 = e2.block_start + r7;
                                                  if ((0 === e2.strstart || e2.strstart >= n7) && (e2.lookahead = e2.strstart - n7, e2.strstart = n7, A(e2, false), 0 === e2.strm.avail_out))
                                                    return 1;
                                                  if (e2.strstart - e2.block_start >= e2.w_size - y && (A(e2, false), 0 === e2.strm.avail_out))
                                                    return 1;
                                                }
                                                return e2.insert = 0, 4 === t7 ? (A(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : (e2.strstart > e2.block_start && (A(e2, false), e2.strm.avail_out), 1);
                                              }), new F(4, 4, 8, 4, R), new F(4, 5, 16, 8, R), new F(4, 6, 32, 32, R), new F(4, 4, 16, 16, D), new F(8, 16, 32, 32, D), new F(8, 16, 128, 128, D), new F(8, 32, 128, 256, D), new F(32, 128, 258, 1024, D), new F(32, 258, 258, 4096, D)], r6.deflateInit = function(e2, t7) {
                                                return L(e2, t7, _, 15, 8, 0);
                                              }, r6.deflateInit2 = L, r6.deflateReset = P, r6.deflateResetKeep = U, r6.deflateSetHeader = function(e2, t7) {
                                                return e2 && e2.state ? 2 !== e2.state.wrap ? m : (e2.state.gzhead = t7, l6) : m;
                                              }, r6.deflate = function(e2, t7) {
                                                var r7, n7, i2, s2;
                                                if (!e2 || !e2.state || 5 < t7 || t7 < 0)
                                                  return e2 ? S(e2, m) : m;
                                                if (n7 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n7.status && 4 !== t7)
                                                  return S(e2, 0 === e2.avail_out ? -5 : m);
                                                if (n7.strm = e2, r7 = n7.last_flush, n7.last_flush = t7, n7.status === k)
                                                  if (2 === n7.wrap)
                                                    e2.adler = 0, I(n7, 31), I(n7, 139), I(n7, 8), n7.gzhead ? (I(n7, (n7.gzhead.text ? 1 : 0) + (n7.gzhead.hcrc ? 2 : 0) + (n7.gzhead.extra ? 4 : 0) + (n7.gzhead.name ? 8 : 0) + (n7.gzhead.comment ? 16 : 0)), I(n7, 255 & n7.gzhead.time), I(n7, n7.gzhead.time >> 8 & 255), I(n7, n7.gzhead.time >> 16 & 255), I(n7, n7.gzhead.time >> 24 & 255), I(n7, 9 === n7.level ? 2 : 2 <= n7.strategy || n7.level < 2 ? 4 : 0), I(n7, 255 & n7.gzhead.os), n7.gzhead.extra && n7.gzhead.extra.length && (I(n7, 255 & n7.gzhead.extra.length), I(n7, n7.gzhead.extra.length >> 8 & 255)), n7.gzhead.hcrc && (e2.adler = p(e2.adler, n7.pending_buf, n7.pending, 0)), n7.gzindex = 0, n7.status = 69) : (I(n7, 0), I(n7, 0), I(n7, 0), I(n7, 0), I(n7, 0), I(n7, 9 === n7.level ? 2 : 2 <= n7.strategy || n7.level < 2 ? 4 : 0), I(n7, 3), n7.status = x);
                                                  else {
                                                    var a2 = _ + (n7.w_bits - 8 << 4) << 8;
                                                    a2 |= (2 <= n7.strategy || n7.level < 2 ? 0 : n7.level < 6 ? 1 : 6 === n7.level ? 2 : 3) << 6, 0 !== n7.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n7.status = x, O(n7, a2), 0 !== n7.strstart && (O(n7, e2.adler >>> 16), O(n7, 65535 & e2.adler)), e2.adler = 1;
                                                  }
                                                if (69 === n7.status)
                                                  if (n7.gzhead.extra) {
                                                    for (i2 = n7.pending; n7.gzindex < (65535 & n7.gzhead.extra.length) && (n7.pending !== n7.pending_buf_size || (n7.gzhead.hcrc && n7.pending > i2 && (e2.adler = p(e2.adler, n7.pending_buf, n7.pending - i2, i2)), C(e2), i2 = n7.pending, n7.pending !== n7.pending_buf_size)); )
                                                      I(n7, 255 & n7.gzhead.extra[n7.gzindex]), n7.gzindex++;
                                                    n7.gzhead.hcrc && n7.pending > i2 && (e2.adler = p(e2.adler, n7.pending_buf, n7.pending - i2, i2)), n7.gzindex === n7.gzhead.extra.length && (n7.gzindex = 0, n7.status = 73);
                                                  } else
                                                    n7.status = 73;
                                                if (73 === n7.status)
                                                  if (n7.gzhead.name) {
                                                    i2 = n7.pending;
                                                    do {
                                                      if (n7.pending === n7.pending_buf_size && (n7.gzhead.hcrc && n7.pending > i2 && (e2.adler = p(e2.adler, n7.pending_buf, n7.pending - i2, i2)), C(e2), i2 = n7.pending, n7.pending === n7.pending_buf_size)) {
                                                        s2 = 1;
                                                        break;
                                                      }
                                                      s2 = n7.gzindex < n7.gzhead.name.length ? 255 & n7.gzhead.name.charCodeAt(n7.gzindex++) : 0, I(n7, s2);
                                                    } while (0 !== s2);
                                                    n7.gzhead.hcrc && n7.pending > i2 && (e2.adler = p(e2.adler, n7.pending_buf, n7.pending - i2, i2)), 0 === s2 && (n7.gzindex = 0, n7.status = 91);
                                                  } else
                                                    n7.status = 91;
                                                if (91 === n7.status)
                                                  if (n7.gzhead.comment) {
                                                    i2 = n7.pending;
                                                    do {
                                                      if (n7.pending === n7.pending_buf_size && (n7.gzhead.hcrc && n7.pending > i2 && (e2.adler = p(e2.adler, n7.pending_buf, n7.pending - i2, i2)), C(e2), i2 = n7.pending, n7.pending === n7.pending_buf_size)) {
                                                        s2 = 1;
                                                        break;
                                                      }
                                                      s2 = n7.gzindex < n7.gzhead.comment.length ? 255 & n7.gzhead.comment.charCodeAt(n7.gzindex++) : 0, I(n7, s2);
                                                    } while (0 !== s2);
                                                    n7.gzhead.hcrc && n7.pending > i2 && (e2.adler = p(e2.adler, n7.pending_buf, n7.pending - i2, i2)), 0 === s2 && (n7.status = 103);
                                                  } else
                                                    n7.status = 103;
                                                if (103 === n7.status && (n7.gzhead.hcrc ? (n7.pending + 2 > n7.pending_buf_size && C(e2), n7.pending + 2 <= n7.pending_buf_size && (I(n7, 255 & e2.adler), I(n7, e2.adler >> 8 & 255), e2.adler = 0, n7.status = x)) : n7.status = x), 0 !== n7.pending) {
                                                  if (C(e2), 0 === e2.avail_out)
                                                    return n7.last_flush = -1, l6;
                                                } else if (0 === e2.avail_in && z(t7) <= z(r7) && 4 !== t7)
                                                  return S(e2, -5);
                                                if (666 === n7.status && 0 !== e2.avail_in)
                                                  return S(e2, -5);
                                                if (0 !== e2.avail_in || 0 !== n7.lookahead || t7 !== f && 666 !== n7.status) {
                                                  var o2 = 2 === n7.strategy ? function(e3, t8) {
                                                    for (var r8; ; ) {
                                                      if (0 === e3.lookahead && (T(e3), 0 === e3.lookahead)) {
                                                        if (t8 === f)
                                                          return 1;
                                                        break;
                                                      }
                                                      if (e3.match_length = 0, r8 = h._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r8 && (A(e3, false), 0 === e3.strm.avail_out))
                                                        return 1;
                                                    }
                                                    return e3.insert = 0, 4 === t8 ? (A(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (A(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
                                                  }(n7, t7) : 3 === n7.strategy ? function(e3, t8) {
                                                    for (var r8, n8, i3, s3, a3 = e3.window; ; ) {
                                                      if (e3.lookahead <= w) {
                                                        if (T(e3), e3.lookahead <= w && t8 === f)
                                                          return 1;
                                                        if (0 === e3.lookahead)
                                                          break;
                                                      }
                                                      if (e3.match_length = 0, e3.lookahead >= b && 0 < e3.strstart && (n8 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n8 === a3[++i3] && n8 === a3[++i3]) {
                                                        s3 = e3.strstart + w;
                                                        do {
                                                        } while (n8 === a3[++i3] && n8 === a3[++i3] && n8 === a3[++i3] && n8 === a3[++i3] && n8 === a3[++i3] && n8 === a3[++i3] && n8 === a3[++i3] && n8 === a3[++i3] && i3 < s3);
                                                        e3.match_length = w - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                                                      }
                                                      if (e3.match_length >= b ? (r8 = h._tr_tally(e3, 1, e3.match_length - b), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r8 = h._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r8 && (A(e3, false), 0 === e3.strm.avail_out))
                                                        return 1;
                                                    }
                                                    return e3.insert = 0, 4 === t8 ? (A(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (A(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
                                                  }(n7, t7) : u[n7.level].func(n7, t7);
                                                  if (3 !== o2 && 4 !== o2 || (n7.status = 666), 1 === o2 || 3 === o2)
                                                    return 0 === e2.avail_out && (n7.last_flush = -1), l6;
                                                  if (2 === o2 && (1 === t7 ? h._tr_align(n7) : 5 !== t7 && (h._tr_stored_block(n7, 0, 0, false), 3 === t7 && (E(n7.head), 0 === n7.lookahead && (n7.strstart = 0, n7.block_start = 0, n7.insert = 0))), C(e2), 0 === e2.avail_out))
                                                    return n7.last_flush = -1, l6;
                                                }
                                                return 4 !== t7 ? l6 : n7.wrap <= 0 ? 1 : (2 === n7.wrap ? (I(n7, 255 & e2.adler), I(n7, e2.adler >> 8 & 255), I(n7, e2.adler >> 16 & 255), I(n7, e2.adler >> 24 & 255), I(n7, 255 & e2.total_in), I(n7, e2.total_in >> 8 & 255), I(n7, e2.total_in >> 16 & 255), I(n7, e2.total_in >> 24 & 255)) : (O(n7, e2.adler >>> 16), O(n7, 65535 & e2.adler)), C(e2), 0 < n7.wrap && (n7.wrap = -n7.wrap), 0 !== n7.pending ? l6 : 1);
                                              }, r6.deflateEnd = function(e2) {
                                                var t7;
                                                return e2 && e2.state ? (t7 = e2.state.status) !== k && 69 !== t7 && 73 !== t7 && 91 !== t7 && 103 !== t7 && t7 !== x && 666 !== t7 ? S(e2, m) : (e2.state = null, t7 === x ? S(e2, -3) : l6) : m;
                                              }, r6.deflateSetDictionary = function(e2, t7) {
                                                var r7, n7, i2, s2, a2, o2, u2, h2, f2 = t7.length;
                                                if (!e2 || !e2.state)
                                                  return m;
                                                if (2 === (s2 = (r7 = e2.state).wrap) || 1 === s2 && r7.status !== k || r7.lookahead)
                                                  return m;
                                                for (1 === s2 && (e2.adler = c(e2.adler, t7, f2, 0)), r7.wrap = 0, f2 >= r7.w_size && (0 === s2 && (E(r7.head), r7.strstart = 0, r7.block_start = 0, r7.insert = 0), h2 = new d.Buf8(r7.w_size), d.arraySet(h2, t7, f2 - r7.w_size, r7.w_size, 0), t7 = h2, f2 = r7.w_size), a2 = e2.avail_in, o2 = e2.next_in, u2 = e2.input, e2.avail_in = f2, e2.next_in = 0, e2.input = t7, T(r7); r7.lookahead >= b; ) {
                                                  for (n7 = r7.strstart, i2 = r7.lookahead - (b - 1); r7.ins_h = (r7.ins_h << r7.hash_shift ^ r7.window[n7 + b - 1]) & r7.hash_mask, r7.prev[n7 & r7.w_mask] = r7.head[r7.ins_h], r7.head[r7.ins_h] = n7, n7++, --i2; )
                                                    ;
                                                  r7.strstart = n7, r7.lookahead = b - 1, T(r7);
                                                }
                                                return r7.strstart += r7.lookahead, r7.block_start = r7.strstart, r7.insert = r7.lookahead, r7.lookahead = 0, r7.match_length = r7.prev_length = b - 1, r7.match_available = 0, e2.next_in = o2, e2.input = u2, e2.avail_in = a2, r7.wrap = s2, l6;
                                              }, r6.deflateInfo = "pako deflate (from Nodeca project)";
                                            }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t6, r6) {
                                              "use strict";
                                              t6.exports = function() {
                                                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
                                              };
                                            }, {}], 48: [function(e, t6, r6) {
                                              "use strict";
                                              t6.exports = function(e2, t7) {
                                                var r7, n6, i, s, a, o, u, h, f, l6, d, c, p, m, _, g, v, b, w, y, k, x, S, z, E;
                                                r7 = e2.state, n6 = e2.next_in, z = e2.input, i = n6 + (e2.avail_in - 5), s = e2.next_out, E = e2.output, a = s - (t7 - e2.avail_out), o = s + (e2.avail_out - 257), u = r7.dmax, h = r7.wsize, f = r7.whave, l6 = r7.wnext, d = r7.window, c = r7.hold, p = r7.bits, m = r7.lencode, _ = r7.distcode, g = (1 << r7.lenbits) - 1, v = (1 << r7.distbits) - 1;
                                                e:
                                                  do {
                                                    p < 15 && (c += z[n6++] << p, p += 8, c += z[n6++] << p, p += 8), b = m[c & g];
                                                    t:
                                                      for (; ; ) {
                                                        if (c >>>= w = b >>> 24, p -= w, 0 == (w = b >>> 16 & 255))
                                                          E[s++] = 65535 & b;
                                                        else {
                                                          if (!(16 & w)) {
                                                            if (0 == (64 & w)) {
                                                              b = m[(65535 & b) + (c & (1 << w) - 1)];
                                                              continue t;
                                                            }
                                                            if (32 & w) {
                                                              r7.mode = 12;
                                                              break e;
                                                            }
                                                            e2.msg = "invalid literal/length code", r7.mode = 30;
                                                            break e;
                                                          }
                                                          y = 65535 & b, (w &= 15) && (p < w && (c += z[n6++] << p, p += 8), y += c & (1 << w) - 1, c >>>= w, p -= w), p < 15 && (c += z[n6++] << p, p += 8, c += z[n6++] << p, p += 8), b = _[c & v];
                                                          r:
                                                            for (; ; ) {
                                                              if (c >>>= w = b >>> 24, p -= w, !(16 & (w = b >>> 16 & 255))) {
                                                                if (0 == (64 & w)) {
                                                                  b = _[(65535 & b) + (c & (1 << w) - 1)];
                                                                  continue r;
                                                                }
                                                                e2.msg = "invalid distance code", r7.mode = 30;
                                                                break e;
                                                              }
                                                              if (k = 65535 & b, p < (w &= 15) && (c += z[n6++] << p, (p += 8) < w && (c += z[n6++] << p, p += 8)), u < (k += c & (1 << w) - 1)) {
                                                                e2.msg = "invalid distance too far back", r7.mode = 30;
                                                                break e;
                                                              }
                                                              if (c >>>= w, p -= w, (w = s - a) < k) {
                                                                if (f < (w = k - w) && r7.sane) {
                                                                  e2.msg = "invalid distance too far back", r7.mode = 30;
                                                                  break e;
                                                                }
                                                                if (S = d, (x = 0) === l6) {
                                                                  if (x += h - w, w < y) {
                                                                    for (y -= w; E[s++] = d[x++], --w; )
                                                                      ;
                                                                    x = s - k, S = E;
                                                                  }
                                                                } else if (l6 < w) {
                                                                  if (x += h + l6 - w, (w -= l6) < y) {
                                                                    for (y -= w; E[s++] = d[x++], --w; )
                                                                      ;
                                                                    if (x = 0, l6 < y) {
                                                                      for (y -= w = l6; E[s++] = d[x++], --w; )
                                                                        ;
                                                                      x = s - k, S = E;
                                                                    }
                                                                  }
                                                                } else if (x += l6 - w, w < y) {
                                                                  for (y -= w; E[s++] = d[x++], --w; )
                                                                    ;
                                                                  x = s - k, S = E;
                                                                }
                                                                for (; 2 < y; )
                                                                  E[s++] = S[x++], E[s++] = S[x++], E[s++] = S[x++], y -= 3;
                                                                y && (E[s++] = S[x++], 1 < y && (E[s++] = S[x++]));
                                                              } else {
                                                                for (x = s - k; E[s++] = E[x++], E[s++] = E[x++], E[s++] = E[x++], 2 < (y -= 3); )
                                                                  ;
                                                                y && (E[s++] = E[x++], 1 < y && (E[s++] = E[x++]));
                                                              }
                                                              break;
                                                            }
                                                        }
                                                        break;
                                                      }
                                                  } while (n6 < i && s < o);
                                                n6 -= y = p >> 3, c &= (1 << (p -= y << 3)) - 1, e2.next_in = n6, e2.next_out = s, e2.avail_in = n6 < i ? i - n6 + 5 : 5 - (n6 - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r7.hold = c, r7.bits = p;
                                              };
                                            }, {}], 49: [function(e, t6, r6) {
                                              "use strict";
                                              var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), T = e("./inffast"), R = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n6 = 852, i = 592;
                                              function L(e2) {
                                                return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
                                              }
                                              function s() {
                                                this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
                                              }
                                              function a(e2) {
                                                var t7;
                                                return e2 && e2.state ? (t7 = e2.state, e2.total_in = e2.total_out = t7.total = 0, e2.msg = "", t7.wrap && (e2.adler = 1 & t7.wrap), t7.mode = P, t7.last = 0, t7.havedict = 0, t7.dmax = 32768, t7.head = null, t7.hold = 0, t7.bits = 0, t7.lencode = t7.lendyn = new I.Buf32(n6), t7.distcode = t7.distdyn = new I.Buf32(i), t7.sane = 1, t7.back = -1, N) : U;
                                              }
                                              function o(e2) {
                                                var t7;
                                                return e2 && e2.state ? ((t7 = e2.state).wsize = 0, t7.whave = 0, t7.wnext = 0, a(e2)) : U;
                                              }
                                              function u(e2, t7) {
                                                var r7, n7;
                                                return e2 && e2.state ? (n7 = e2.state, t7 < 0 ? (r7 = 0, t7 = -t7) : (r7 = 1 + (t7 >> 4), t7 < 48 && (t7 &= 15)), t7 && (t7 < 8 || 15 < t7) ? U : (null !== n7.window && n7.wbits !== t7 && (n7.window = null), n7.wrap = r7, n7.wbits = t7, o(e2))) : U;
                                              }
                                              function h(e2, t7) {
                                                var r7, n7;
                                                return e2 ? (n7 = new s(), (e2.state = n7).window = null, (r7 = u(e2, t7)) !== N && (e2.state = null), r7) : U;
                                              }
                                              var f, l6, d = true;
                                              function j(e2) {
                                                if (d) {
                                                  var t7;
                                                  for (f = new I.Buf32(512), l6 = new I.Buf32(32), t7 = 0; t7 < 144; )
                                                    e2.lens[t7++] = 8;
                                                  for (; t7 < 256; )
                                                    e2.lens[t7++] = 9;
                                                  for (; t7 < 280; )
                                                    e2.lens[t7++] = 7;
                                                  for (; t7 < 288; )
                                                    e2.lens[t7++] = 8;
                                                  for (R(D, e2.lens, 0, 288, f, 0, e2.work, { bits: 9 }), t7 = 0; t7 < 32; )
                                                    e2.lens[t7++] = 5;
                                                  R(F, e2.lens, 0, 32, l6, 0, e2.work, { bits: 5 }), d = false;
                                                }
                                                e2.lencode = f, e2.lenbits = 9, e2.distcode = l6, e2.distbits = 5;
                                              }
                                              function Z(e2, t7, r7, n7) {
                                                var i2, s2 = e2.state;
                                                return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n7 >= s2.wsize ? (I.arraySet(s2.window, t7, r7 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n7 < (i2 = s2.wsize - s2.wnext) && (i2 = n7), I.arraySet(s2.window, t7, r7 - n7, i2, s2.wnext), (n7 -= i2) ? (I.arraySet(s2.window, t7, r7 - n7, n7, 0), s2.wnext = n7, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
                                              }
                                              r6.inflateReset = o, r6.inflateReset2 = u, r6.inflateResetKeep = a, r6.inflateInit = function(e2) {
                                                return h(e2, 15);
                                              }, r6.inflateInit2 = h, r6.inflate = function(e2, t7) {
                                                var r7, n7, i2, s2, a2, o2, u2, h2, f2, l7, d2, c, p, m, _, g, v, b, w, y, k, x, S, z, E = 0, C = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                                                if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
                                                  return U;
                                                12 === (r7 = e2.state).mode && (r7.mode = 13), a2 = e2.next_out, i2 = e2.output, u2 = e2.avail_out, s2 = e2.next_in, n7 = e2.input, o2 = e2.avail_in, h2 = r7.hold, f2 = r7.bits, l7 = o2, d2 = u2, x = N;
                                                e:
                                                  for (; ; )
                                                    switch (r7.mode) {
                                                      case P:
                                                        if (0 === r7.wrap) {
                                                          r7.mode = 13;
                                                          break;
                                                        }
                                                        for (; f2 < 16; ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        if (2 & r7.wrap && 35615 === h2) {
                                                          C[r7.check = 0] = 255 & h2, C[1] = h2 >>> 8 & 255, r7.check = B(r7.check, C, 2, 0), f2 = h2 = 0, r7.mode = 2;
                                                          break;
                                                        }
                                                        if (r7.flags = 0, r7.head && (r7.head.done = false), !(1 & r7.wrap) || (((255 & h2) << 8) + (h2 >> 8)) % 31) {
                                                          e2.msg = "incorrect header check", r7.mode = 30;
                                                          break;
                                                        }
                                                        if (8 != (15 & h2)) {
                                                          e2.msg = "unknown compression method", r7.mode = 30;
                                                          break;
                                                        }
                                                        if (f2 -= 4, k = 8 + (15 & (h2 >>>= 4)), 0 === r7.wbits)
                                                          r7.wbits = k;
                                                        else if (k > r7.wbits) {
                                                          e2.msg = "invalid window size", r7.mode = 30;
                                                          break;
                                                        }
                                                        r7.dmax = 1 << k, e2.adler = r7.check = 1, r7.mode = 512 & h2 ? 10 : 12, f2 = h2 = 0;
                                                        break;
                                                      case 2:
                                                        for (; f2 < 16; ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        if (r7.flags = h2, 8 != (255 & r7.flags)) {
                                                          e2.msg = "unknown compression method", r7.mode = 30;
                                                          break;
                                                        }
                                                        if (57344 & r7.flags) {
                                                          e2.msg = "unknown header flags set", r7.mode = 30;
                                                          break;
                                                        }
                                                        r7.head && (r7.head.text = h2 >> 8 & 1), 512 & r7.flags && (C[0] = 255 & h2, C[1] = h2 >>> 8 & 255, r7.check = B(r7.check, C, 2, 0)), f2 = h2 = 0, r7.mode = 3;
                                                      case 3:
                                                        for (; f2 < 32; ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        r7.head && (r7.head.time = h2), 512 & r7.flags && (C[0] = 255 & h2, C[1] = h2 >>> 8 & 255, C[2] = h2 >>> 16 & 255, C[3] = h2 >>> 24 & 255, r7.check = B(r7.check, C, 4, 0)), f2 = h2 = 0, r7.mode = 4;
                                                      case 4:
                                                        for (; f2 < 16; ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        r7.head && (r7.head.xflags = 255 & h2, r7.head.os = h2 >> 8), 512 & r7.flags && (C[0] = 255 & h2, C[1] = h2 >>> 8 & 255, r7.check = B(r7.check, C, 2, 0)), f2 = h2 = 0, r7.mode = 5;
                                                      case 5:
                                                        if (1024 & r7.flags) {
                                                          for (; f2 < 16; ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          r7.length = h2, r7.head && (r7.head.extra_len = h2), 512 & r7.flags && (C[0] = 255 & h2, C[1] = h2 >>> 8 & 255, r7.check = B(r7.check, C, 2, 0)), f2 = h2 = 0;
                                                        } else
                                                          r7.head && (r7.head.extra = null);
                                                        r7.mode = 6;
                                                      case 6:
                                                        if (1024 & r7.flags && (o2 < (c = r7.length) && (c = o2), c && (r7.head && (k = r7.head.extra_len - r7.length, r7.head.extra || (r7.head.extra = new Array(r7.head.extra_len)), I.arraySet(r7.head.extra, n7, s2, c, k)), 512 & r7.flags && (r7.check = B(r7.check, n7, c, s2)), o2 -= c, s2 += c, r7.length -= c), r7.length))
                                                          break e;
                                                        r7.length = 0, r7.mode = 7;
                                                      case 7:
                                                        if (2048 & r7.flags) {
                                                          if (0 === o2)
                                                            break e;
                                                          for (c = 0; k = n7[s2 + c++], r7.head && k && r7.length < 65536 && (r7.head.name += String.fromCharCode(k)), k && c < o2; )
                                                            ;
                                                          if (512 & r7.flags && (r7.check = B(r7.check, n7, c, s2)), o2 -= c, s2 += c, k)
                                                            break e;
                                                        } else
                                                          r7.head && (r7.head.name = null);
                                                        r7.length = 0, r7.mode = 8;
                                                      case 8:
                                                        if (4096 & r7.flags) {
                                                          if (0 === o2)
                                                            break e;
                                                          for (c = 0; k = n7[s2 + c++], r7.head && k && r7.length < 65536 && (r7.head.comment += String.fromCharCode(k)), k && c < o2; )
                                                            ;
                                                          if (512 & r7.flags && (r7.check = B(r7.check, n7, c, s2)), o2 -= c, s2 += c, k)
                                                            break e;
                                                        } else
                                                          r7.head && (r7.head.comment = null);
                                                        r7.mode = 9;
                                                      case 9:
                                                        if (512 & r7.flags) {
                                                          for (; f2 < 16; ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          if (h2 !== (65535 & r7.check)) {
                                                            e2.msg = "header crc mismatch", r7.mode = 30;
                                                            break;
                                                          }
                                                          f2 = h2 = 0;
                                                        }
                                                        r7.head && (r7.head.hcrc = r7.flags >> 9 & 1, r7.head.done = true), e2.adler = r7.check = 0, r7.mode = 12;
                                                        break;
                                                      case 10:
                                                        for (; f2 < 32; ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        e2.adler = r7.check = L(h2), f2 = h2 = 0, r7.mode = 11;
                                                      case 11:
                                                        if (0 === r7.havedict)
                                                          return e2.next_out = a2, e2.avail_out = u2, e2.next_in = s2, e2.avail_in = o2, r7.hold = h2, r7.bits = f2, 2;
                                                        e2.adler = r7.check = 1, r7.mode = 12;
                                                      case 12:
                                                        if (5 === t7 || 6 === t7)
                                                          break e;
                                                      case 13:
                                                        if (r7.last) {
                                                          h2 >>>= 7 & f2, f2 -= 7 & f2, r7.mode = 27;
                                                          break;
                                                        }
                                                        for (; f2 < 3; ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        switch (r7.last = 1 & h2, f2 -= 1, 3 & (h2 >>>= 1)) {
                                                          case 0:
                                                            r7.mode = 14;
                                                            break;
                                                          case 1:
                                                            if (j(r7), r7.mode = 20, 6 !== t7)
                                                              break;
                                                            h2 >>>= 2, f2 -= 2;
                                                            break e;
                                                          case 2:
                                                            r7.mode = 17;
                                                            break;
                                                          case 3:
                                                            e2.msg = "invalid block type", r7.mode = 30;
                                                        }
                                                        h2 >>>= 2, f2 -= 2;
                                                        break;
                                                      case 14:
                                                        for (h2 >>>= 7 & f2, f2 -= 7 & f2; f2 < 32; ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        if ((65535 & h2) != (h2 >>> 16 ^ 65535)) {
                                                          e2.msg = "invalid stored block lengths", r7.mode = 30;
                                                          break;
                                                        }
                                                        if (r7.length = 65535 & h2, f2 = h2 = 0, r7.mode = 15, 6 === t7)
                                                          break e;
                                                      case 15:
                                                        r7.mode = 16;
                                                      case 16:
                                                        if (c = r7.length) {
                                                          if (o2 < c && (c = o2), u2 < c && (c = u2), 0 === c)
                                                            break e;
                                                          I.arraySet(i2, n7, s2, c, a2), o2 -= c, s2 += c, u2 -= c, a2 += c, r7.length -= c;
                                                          break;
                                                        }
                                                        r7.mode = 12;
                                                        break;
                                                      case 17:
                                                        for (; f2 < 14; ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        if (r7.nlen = 257 + (31 & h2), h2 >>>= 5, f2 -= 5, r7.ndist = 1 + (31 & h2), h2 >>>= 5, f2 -= 5, r7.ncode = 4 + (15 & h2), h2 >>>= 4, f2 -= 4, 286 < r7.nlen || 30 < r7.ndist) {
                                                          e2.msg = "too many length or distance symbols", r7.mode = 30;
                                                          break;
                                                        }
                                                        r7.have = 0, r7.mode = 18;
                                                      case 18:
                                                        for (; r7.have < r7.ncode; ) {
                                                          for (; f2 < 3; ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          r7.lens[A[r7.have++]] = 7 & h2, h2 >>>= 3, f2 -= 3;
                                                        }
                                                        for (; r7.have < 19; )
                                                          r7.lens[A[r7.have++]] = 0;
                                                        if (r7.lencode = r7.lendyn, r7.lenbits = 7, S = { bits: r7.lenbits }, x = R(0, r7.lens, 0, 19, r7.lencode, 0, r7.work, S), r7.lenbits = S.bits, x) {
                                                          e2.msg = "invalid code lengths set", r7.mode = 30;
                                                          break;
                                                        }
                                                        r7.have = 0, r7.mode = 19;
                                                      case 19:
                                                        for (; r7.have < r7.nlen + r7.ndist; ) {
                                                          for (; g = (E = r7.lencode[h2 & (1 << r7.lenbits) - 1]) >>> 16 & 255, v = 65535 & E, !((_ = E >>> 24) <= f2); ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          if (v < 16)
                                                            h2 >>>= _, f2 -= _, r7.lens[r7.have++] = v;
                                                          else {
                                                            if (16 === v) {
                                                              for (z = _ + 2; f2 < z; ) {
                                                                if (0 === o2)
                                                                  break e;
                                                                o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                              }
                                                              if (h2 >>>= _, f2 -= _, 0 === r7.have) {
                                                                e2.msg = "invalid bit length repeat", r7.mode = 30;
                                                                break;
                                                              }
                                                              k = r7.lens[r7.have - 1], c = 3 + (3 & h2), h2 >>>= 2, f2 -= 2;
                                                            } else if (17 === v) {
                                                              for (z = _ + 3; f2 < z; ) {
                                                                if (0 === o2)
                                                                  break e;
                                                                o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                              }
                                                              f2 -= _, k = 0, c = 3 + (7 & (h2 >>>= _)), h2 >>>= 3, f2 -= 3;
                                                            } else {
                                                              for (z = _ + 7; f2 < z; ) {
                                                                if (0 === o2)
                                                                  break e;
                                                                o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                              }
                                                              f2 -= _, k = 0, c = 11 + (127 & (h2 >>>= _)), h2 >>>= 7, f2 -= 7;
                                                            }
                                                            if (r7.have + c > r7.nlen + r7.ndist) {
                                                              e2.msg = "invalid bit length repeat", r7.mode = 30;
                                                              break;
                                                            }
                                                            for (; c--; )
                                                              r7.lens[r7.have++] = k;
                                                          }
                                                        }
                                                        if (30 === r7.mode)
                                                          break;
                                                        if (0 === r7.lens[256]) {
                                                          e2.msg = "invalid code -- missing end-of-block", r7.mode = 30;
                                                          break;
                                                        }
                                                        if (r7.lenbits = 9, S = { bits: r7.lenbits }, x = R(D, r7.lens, 0, r7.nlen, r7.lencode, 0, r7.work, S), r7.lenbits = S.bits, x) {
                                                          e2.msg = "invalid literal/lengths set", r7.mode = 30;
                                                          break;
                                                        }
                                                        if (r7.distbits = 6, r7.distcode = r7.distdyn, S = { bits: r7.distbits }, x = R(F, r7.lens, r7.nlen, r7.ndist, r7.distcode, 0, r7.work, S), r7.distbits = S.bits, x) {
                                                          e2.msg = "invalid distances set", r7.mode = 30;
                                                          break;
                                                        }
                                                        if (r7.mode = 20, 6 === t7)
                                                          break e;
                                                      case 20:
                                                        r7.mode = 21;
                                                      case 21:
                                                        if (6 <= o2 && 258 <= u2) {
                                                          e2.next_out = a2, e2.avail_out = u2, e2.next_in = s2, e2.avail_in = o2, r7.hold = h2, r7.bits = f2, T(e2, d2), a2 = e2.next_out, i2 = e2.output, u2 = e2.avail_out, s2 = e2.next_in, n7 = e2.input, o2 = e2.avail_in, h2 = r7.hold, f2 = r7.bits, 12 === r7.mode && (r7.back = -1);
                                                          break;
                                                        }
                                                        for (r7.back = 0; g = (E = r7.lencode[h2 & (1 << r7.lenbits) - 1]) >>> 16 & 255, v = 65535 & E, !((_ = E >>> 24) <= f2); ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        if (g && 0 == (240 & g)) {
                                                          for (b = _, w = g, y = v; g = (E = r7.lencode[y + ((h2 & (1 << b + w) - 1) >> b)]) >>> 16 & 255, v = 65535 & E, !(b + (_ = E >>> 24) <= f2); ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          h2 >>>= b, f2 -= b, r7.back += b;
                                                        }
                                                        if (h2 >>>= _, f2 -= _, r7.back += _, r7.length = v, 0 === g) {
                                                          r7.mode = 26;
                                                          break;
                                                        }
                                                        if (32 & g) {
                                                          r7.back = -1, r7.mode = 12;
                                                          break;
                                                        }
                                                        if (64 & g) {
                                                          e2.msg = "invalid literal/length code", r7.mode = 30;
                                                          break;
                                                        }
                                                        r7.extra = 15 & g, r7.mode = 22;
                                                      case 22:
                                                        if (r7.extra) {
                                                          for (z = r7.extra; f2 < z; ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          r7.length += h2 & (1 << r7.extra) - 1, h2 >>>= r7.extra, f2 -= r7.extra, r7.back += r7.extra;
                                                        }
                                                        r7.was = r7.length, r7.mode = 23;
                                                      case 23:
                                                        for (; g = (E = r7.distcode[h2 & (1 << r7.distbits) - 1]) >>> 16 & 255, v = 65535 & E, !((_ = E >>> 24) <= f2); ) {
                                                          if (0 === o2)
                                                            break e;
                                                          o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                        }
                                                        if (0 == (240 & g)) {
                                                          for (b = _, w = g, y = v; g = (E = r7.distcode[y + ((h2 & (1 << b + w) - 1) >> b)]) >>> 16 & 255, v = 65535 & E, !(b + (_ = E >>> 24) <= f2); ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          h2 >>>= b, f2 -= b, r7.back += b;
                                                        }
                                                        if (h2 >>>= _, f2 -= _, r7.back += _, 64 & g) {
                                                          e2.msg = "invalid distance code", r7.mode = 30;
                                                          break;
                                                        }
                                                        r7.offset = v, r7.extra = 15 & g, r7.mode = 24;
                                                      case 24:
                                                        if (r7.extra) {
                                                          for (z = r7.extra; f2 < z; ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          r7.offset += h2 & (1 << r7.extra) - 1, h2 >>>= r7.extra, f2 -= r7.extra, r7.back += r7.extra;
                                                        }
                                                        if (r7.offset > r7.dmax) {
                                                          e2.msg = "invalid distance too far back", r7.mode = 30;
                                                          break;
                                                        }
                                                        r7.mode = 25;
                                                      case 25:
                                                        if (0 === u2)
                                                          break e;
                                                        if (c = d2 - u2, r7.offset > c) {
                                                          if ((c = r7.offset - c) > r7.whave && r7.sane) {
                                                            e2.msg = "invalid distance too far back", r7.mode = 30;
                                                            break;
                                                          }
                                                          p = c > r7.wnext ? (c -= r7.wnext, r7.wsize - c) : r7.wnext - c, c > r7.length && (c = r7.length), m = r7.window;
                                                        } else
                                                          m = i2, p = a2 - r7.offset, c = r7.length;
                                                        for (u2 < c && (c = u2), u2 -= c, r7.length -= c; i2[a2++] = m[p++], --c; )
                                                          ;
                                                        0 === r7.length && (r7.mode = 21);
                                                        break;
                                                      case 26:
                                                        if (0 === u2)
                                                          break e;
                                                        i2[a2++] = r7.length, u2--, r7.mode = 21;
                                                        break;
                                                      case 27:
                                                        if (r7.wrap) {
                                                          for (; f2 < 32; ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 |= n7[s2++] << f2, f2 += 8;
                                                          }
                                                          if (d2 -= u2, e2.total_out += d2, r7.total += d2, d2 && (e2.adler = r7.check = r7.flags ? B(r7.check, i2, d2, a2 - d2) : O(r7.check, i2, d2, a2 - d2)), d2 = u2, (r7.flags ? h2 : L(h2)) !== r7.check) {
                                                            e2.msg = "incorrect data check", r7.mode = 30;
                                                            break;
                                                          }
                                                          f2 = h2 = 0;
                                                        }
                                                        r7.mode = 28;
                                                      case 28:
                                                        if (r7.wrap && r7.flags) {
                                                          for (; f2 < 32; ) {
                                                            if (0 === o2)
                                                              break e;
                                                            o2--, h2 += n7[s2++] << f2, f2 += 8;
                                                          }
                                                          if (h2 !== (4294967295 & r7.total)) {
                                                            e2.msg = "incorrect length check", r7.mode = 30;
                                                            break;
                                                          }
                                                          f2 = h2 = 0;
                                                        }
                                                        r7.mode = 29;
                                                      case 29:
                                                        x = 1;
                                                        break e;
                                                      case 30:
                                                        x = -3;
                                                        break e;
                                                      case 31:
                                                        return -4;
                                                      case 32:
                                                      default:
                                                        return U;
                                                    }
                                                return e2.next_out = a2, e2.avail_out = u2, e2.next_in = s2, e2.avail_in = o2, r7.hold = h2, r7.bits = f2, (r7.wsize || d2 !== e2.avail_out && r7.mode < 30 && (r7.mode < 27 || 4 !== t7)) && Z(e2, e2.output, e2.next_out, d2 - e2.avail_out) ? (r7.mode = 31, -4) : (l7 -= e2.avail_in, d2 -= e2.avail_out, e2.total_in += l7, e2.total_out += d2, r7.total += d2, r7.wrap && d2 && (e2.adler = r7.check = r7.flags ? B(r7.check, i2, d2, e2.next_out - d2) : O(r7.check, i2, d2, e2.next_out - d2)), e2.data_type = r7.bits + (r7.last ? 64 : 0) + (12 === r7.mode ? 128 : 0) + (20 === r7.mode || 15 === r7.mode ? 256 : 0), (0 == l7 && 0 === d2 || 4 === t7) && x === N && (x = -5), x);
                                              }, r6.inflateEnd = function(e2) {
                                                if (!e2 || !e2.state)
                                                  return U;
                                                var t7 = e2.state;
                                                return t7.window && (t7.window = null), e2.state = null, N;
                                              }, r6.inflateGetHeader = function(e2, t7) {
                                                var r7;
                                                return e2 && e2.state ? 0 == (2 & (r7 = e2.state).wrap) ? U : ((r7.head = t7).done = false, N) : U;
                                              }, r6.inflateSetDictionary = function(e2, t7) {
                                                var r7, n7 = t7.length;
                                                return e2 && e2.state ? 0 !== (r7 = e2.state).wrap && 11 !== r7.mode ? U : 11 === r7.mode && O(1, t7, n7, 0) !== r7.check ? -3 : Z(e2, t7, n7, n7) ? (r7.mode = 31, -4) : (r7.havedict = 1, N) : U;
                                              }, r6.inflateInfo = "pako inflate (from Nodeca project)";
                                            }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t6, r6) {
                                              "use strict";
                                              var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
                                              t6.exports = function(e2, t7, r7, n6, i, s, a, o) {
                                                var u, h, f, l6, d, c, p, m, _, g = o.bits, v = 0, b = 0, w = 0, y = 0, k = 0, x = 0, S = 0, z = 0, E = 0, C = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), T = null, R = 0;
                                                for (v = 0; v <= 15; v++)
                                                  O[v] = 0;
                                                for (b = 0; b < n6; b++)
                                                  O[t7[r7 + b]]++;
                                                for (k = g, y = 15; 1 <= y && 0 === O[y]; y--)
                                                  ;
                                                if (y < k && (k = y), 0 === y)
                                                  return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
                                                for (w = 1; w < y && 0 === O[w]; w++)
                                                  ;
                                                for (k < w && (k = w), v = z = 1; v <= 15; v++)
                                                  if (z <<= 1, (z -= O[v]) < 0)
                                                    return -1;
                                                if (0 < z && (0 === e2 || 1 !== y))
                                                  return -1;
                                                for (B[1] = 0, v = 1; v < 15; v++)
                                                  B[v + 1] = B[v] + O[v];
                                                for (b = 0; b < n6; b++)
                                                  0 !== t7[r7 + b] && (a[B[t7[r7 + b]]++] = b);
                                                if (c = 0 === e2 ? (A = T = a, 19) : 1 === e2 ? (A = F, I -= 257, T = N, R -= 257, 256) : (A = U, T = P, -1), v = w, d = s, S = b = C = 0, f = -1, l6 = (E = 1 << (x = k)) - 1, 1 === e2 && 852 < E || 2 === e2 && 592 < E)
                                                  return 1;
                                                for (; ; ) {
                                                  for (p = v - S, _ = a[b] < c ? (m = 0, a[b]) : a[b] > c ? (m = T[R + a[b]], A[I + a[b]]) : (m = 96, 0), u = 1 << v - S, w = h = 1 << x; i[d + (C >> S) + (h -= u)] = p << 24 | m << 16 | _ | 0, 0 !== h; )
                                                    ;
                                                  for (u = 1 << v - 1; C & u; )
                                                    u >>= 1;
                                                  if (0 !== u ? (C &= u - 1, C += u) : C = 0, b++, 0 == --O[v]) {
                                                    if (v === y)
                                                      break;
                                                    v = t7[r7 + a[b]];
                                                  }
                                                  if (k < v && (C & l6) !== f) {
                                                    for (0 === S && (S = k), d += w, z = 1 << (x = v - S); x + S < y && !((z -= O[x + S]) <= 0); )
                                                      x++, z <<= 1;
                                                    if (E += 1 << x, 1 === e2 && 852 < E || 2 === e2 && 592 < E)
                                                      return 1;
                                                    i[f = C & l6] = k << 24 | x << 16 | d - s | 0;
                                                  }
                                                }
                                                return 0 !== C && (i[d + C] = v - S << 24 | 64 << 16 | 0), o.bits = k, 0;
                                              };
                                            }, { "../utils/common": 41 }], 51: [function(e, t6, r6) {
                                              "use strict";
                                              t6.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
                                            }, {}], 52: [function(e, t6, r6) {
                                              "use strict";
                                              var o = e("../utils/common");
                                              function n6(e2) {
                                                for (var t7 = e2.length; 0 <= --t7; )
                                                  e2[t7] = 0;
                                              }
                                              var _ = 15, i = 16, u = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], h = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], f = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], l6 = new Array(576);
                                              n6(l6);
                                              var d = new Array(60);
                                              n6(d);
                                              var c = new Array(512);
                                              n6(c);
                                              var p = new Array(256);
                                              n6(p);
                                              var m = new Array(29);
                                              n6(m);
                                              var g, v, b, w = new Array(30);
                                              function y(e2, t7, r7, n7, i2) {
                                                this.static_tree = e2, this.extra_bits = t7, this.extra_base = r7, this.elems = n7, this.max_length = i2, this.has_stree = e2 && e2.length;
                                              }
                                              function s(e2, t7) {
                                                this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t7;
                                              }
                                              function k(e2) {
                                                return e2 < 256 ? c[e2] : c[256 + (e2 >>> 7)];
                                              }
                                              function x(e2, t7) {
                                                e2.pending_buf[e2.pending++] = 255 & t7, e2.pending_buf[e2.pending++] = t7 >>> 8 & 255;
                                              }
                                              function S(e2, t7, r7) {
                                                e2.bi_valid > i - r7 ? (e2.bi_buf |= t7 << e2.bi_valid & 65535, x(e2, e2.bi_buf), e2.bi_buf = t7 >> i - e2.bi_valid, e2.bi_valid += r7 - i) : (e2.bi_buf |= t7 << e2.bi_valid & 65535, e2.bi_valid += r7);
                                              }
                                              function z(e2, t7, r7) {
                                                S(e2, r7[2 * t7], r7[2 * t7 + 1]);
                                              }
                                              function E(e2, t7) {
                                                for (var r7 = 0; r7 |= 1 & e2, e2 >>>= 1, r7 <<= 1, 0 < --t7; )
                                                  ;
                                                return r7 >>> 1;
                                              }
                                              function C(e2, t7, r7) {
                                                var n7, i2, s2 = new Array(_ + 1), a2 = 0;
                                                for (n7 = 1; n7 <= _; n7++)
                                                  s2[n7] = a2 = a2 + r7[n7 - 1] << 1;
                                                for (i2 = 0; i2 <= t7; i2++) {
                                                  var o2 = e2[2 * i2 + 1];
                                                  0 !== o2 && (e2[2 * i2] = E(s2[o2]++, o2));
                                                }
                                              }
                                              function A(e2) {
                                                var t7;
                                                for (t7 = 0; t7 < 286; t7++)
                                                  e2.dyn_ltree[2 * t7] = 0;
                                                for (t7 = 0; t7 < 30; t7++)
                                                  e2.dyn_dtree[2 * t7] = 0;
                                                for (t7 = 0; t7 < 19; t7++)
                                                  e2.bl_tree[2 * t7] = 0;
                                                e2.dyn_ltree[512] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
                                              }
                                              function I(e2) {
                                                8 < e2.bi_valid ? x(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
                                              }
                                              function O(e2, t7, r7, n7) {
                                                var i2 = 2 * t7, s2 = 2 * r7;
                                                return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n7[t7] <= n7[r7];
                                              }
                                              function B(e2, t7, r7) {
                                                for (var n7 = e2.heap[r7], i2 = r7 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && O(t7, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !O(t7, n7, e2.heap[i2], e2.depth)); )
                                                  e2.heap[r7] = e2.heap[i2], r7 = i2, i2 <<= 1;
                                                e2.heap[r7] = n7;
                                              }
                                              function T(e2, t7, r7) {
                                                var n7, i2, s2, a2, o2 = 0;
                                                if (0 !== e2.last_lit)
                                                  for (; n7 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n7 ? z(e2, i2, t7) : (z(e2, (s2 = p[i2]) + 256 + 1, t7), 0 !== (a2 = u[s2]) && S(e2, i2 -= m[s2], a2), z(e2, s2 = k(--n7), r7), 0 !== (a2 = h[s2]) && S(e2, n7 -= w[s2], a2)), o2 < e2.last_lit; )
                                                    ;
                                                z(e2, 256, t7);
                                              }
                                              function R(e2, t7) {
                                                var r7, n7, i2, s2 = t7.dyn_tree, a2 = t7.stat_desc.static_tree, o2 = t7.stat_desc.has_stree, u2 = t7.stat_desc.elems, h2 = -1;
                                                for (e2.heap_len = 0, e2.heap_max = 573, r7 = 0; r7 < u2; r7++)
                                                  0 !== s2[2 * r7] ? (e2.heap[++e2.heap_len] = h2 = r7, e2.depth[r7] = 0) : s2[2 * r7 + 1] = 0;
                                                for (; e2.heap_len < 2; )
                                                  s2[2 * (i2 = e2.heap[++e2.heap_len] = h2 < 2 ? ++h2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
                                                for (t7.max_code = h2, r7 = e2.heap_len >> 1; 1 <= r7; r7--)
                                                  B(e2, s2, r7);
                                                for (i2 = u2; r7 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], B(e2, s2, 1), n7 = e2.heap[1], e2.heap[--e2.heap_max] = r7, e2.heap[--e2.heap_max] = n7, s2[2 * i2] = s2[2 * r7] + s2[2 * n7], e2.depth[i2] = (e2.depth[r7] >= e2.depth[n7] ? e2.depth[r7] : e2.depth[n7]) + 1, s2[2 * r7 + 1] = s2[2 * n7 + 1] = i2, e2.heap[1] = i2++, B(e2, s2, 1), 2 <= e2.heap_len; )
                                                  ;
                                                e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t8) {
                                                  var r8, n8, i3, s3, a3, o3, u3 = t8.dyn_tree, h3 = t8.max_code, f2 = t8.stat_desc.static_tree, l7 = t8.stat_desc.has_stree, d2 = t8.stat_desc.extra_bits, c2 = t8.stat_desc.extra_base, p2 = t8.stat_desc.max_length, m2 = 0;
                                                  for (s3 = 0; s3 <= _; s3++)
                                                    e3.bl_count[s3] = 0;
                                                  for (u3[2 * e3.heap[e3.heap_max] + 1] = 0, r8 = e3.heap_max + 1; r8 < 573; r8++)
                                                    p2 < (s3 = u3[2 * u3[2 * (n8 = e3.heap[r8]) + 1] + 1] + 1) && (s3 = p2, m2++), u3[2 * n8 + 1] = s3, h3 < n8 || (e3.bl_count[s3]++, a3 = 0, c2 <= n8 && (a3 = d2[n8 - c2]), o3 = u3[2 * n8], e3.opt_len += o3 * (s3 + a3), l7 && (e3.static_len += o3 * (f2[2 * n8 + 1] + a3)));
                                                  if (0 !== m2) {
                                                    do {
                                                      for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                                                        s3--;
                                                      e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
                                                    } while (0 < m2);
                                                    for (s3 = p2; 0 !== s3; s3--)
                                                      for (n8 = e3.bl_count[s3]; 0 !== n8; )
                                                        h3 < (i3 = e3.heap[--r8]) || (u3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - u3[2 * i3 + 1]) * u3[2 * i3], u3[2 * i3 + 1] = s3), n8--);
                                                  }
                                                }(e2, t7), C(s2, h2, e2.bl_count);
                                              }
                                              function D(e2, t7, r7) {
                                                var n7, i2, s2 = -1, a2 = t7[1], o2 = 0, u2 = 7, h2 = 4;
                                                for (0 === a2 && (u2 = 138, h2 = 3), t7[2 * (r7 + 1) + 1] = 65535, n7 = 0; n7 <= r7; n7++)
                                                  i2 = a2, a2 = t7[2 * (n7 + 1) + 1], ++o2 < u2 && i2 === a2 || (o2 < h2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[32]++) : o2 <= 10 ? e2.bl_tree[34]++ : e2.bl_tree[36]++, s2 = i2, h2 = (o2 = 0) === a2 ? (u2 = 138, 3) : i2 === a2 ? (u2 = 6, 3) : (u2 = 7, 4));
                                              }
                                              function F(e2, t7, r7) {
                                                var n7, i2, s2 = -1, a2 = t7[1], o2 = 0, u2 = 7, h2 = 4;
                                                for (0 === a2 && (u2 = 138, h2 = 3), n7 = 0; n7 <= r7; n7++)
                                                  if (i2 = a2, a2 = t7[2 * (n7 + 1) + 1], !(++o2 < u2 && i2 === a2)) {
                                                    if (o2 < h2)
                                                      for (; z(e2, i2, e2.bl_tree), 0 != --o2; )
                                                        ;
                                                    else
                                                      0 !== i2 ? (i2 !== s2 && (z(e2, i2, e2.bl_tree), o2--), z(e2, 16, e2.bl_tree), S(e2, o2 - 3, 2)) : o2 <= 10 ? (z(e2, 17, e2.bl_tree), S(e2, o2 - 3, 3)) : (z(e2, 18, e2.bl_tree), S(e2, o2 - 11, 7));
                                                    s2 = i2, h2 = (o2 = 0) === a2 ? (u2 = 138, 3) : i2 === a2 ? (u2 = 6, 3) : (u2 = 7, 4);
                                                  }
                                              }
                                              n6(w);
                                              var N = false;
                                              function U(e2, t7, r7, n7) {
                                                var i2, s2, a2;
                                                S(e2, 0 + (n7 ? 1 : 0), 3), s2 = t7, a2 = r7, I(i2 = e2), x(i2, a2), x(i2, ~a2), o.arraySet(i2.pending_buf, i2.window, s2, a2, i2.pending), i2.pending += a2;
                                              }
                                              r6._tr_init = function(e2) {
                                                N || (function() {
                                                  var e3, t7, r7, n7, i2, s2 = new Array(_ + 1);
                                                  for (n7 = r7 = 0; n7 < 28; n7++)
                                                    for (m[n7] = r7, e3 = 0; e3 < 1 << u[n7]; e3++)
                                                      p[r7++] = n7;
                                                  for (p[r7 - 1] = n7, n7 = i2 = 0; n7 < 16; n7++)
                                                    for (w[n7] = i2, e3 = 0; e3 < 1 << h[n7]; e3++)
                                                      c[i2++] = n7;
                                                  for (i2 >>= 7; n7 < 30; n7++)
                                                    for (w[n7] = i2 << 7, e3 = 0; e3 < 1 << h[n7] - 7; e3++)
                                                      c[256 + i2++] = n7;
                                                  for (t7 = 0; t7 <= _; t7++)
                                                    s2[t7] = 0;
                                                  for (e3 = 0; e3 <= 143; )
                                                    l6[2 * e3 + 1] = 8, e3++, s2[8]++;
                                                  for (; e3 <= 255; )
                                                    l6[2 * e3 + 1] = 9, e3++, s2[9]++;
                                                  for (; e3 <= 279; )
                                                    l6[2 * e3 + 1] = 7, e3++, s2[7]++;
                                                  for (; e3 <= 287; )
                                                    l6[2 * e3 + 1] = 8, e3++, s2[8]++;
                                                  for (C(l6, 287, s2), e3 = 0; e3 < 30; e3++)
                                                    d[2 * e3 + 1] = 5, d[2 * e3] = E(e3, 5);
                                                  g = new y(l6, u, 257, 286, _), v = new y(d, h, 0, 30, _), b = new y(new Array(0), a, 0, 19, 7);
                                                }(), N = true), e2.l_desc = new s(e2.dyn_ltree, g), e2.d_desc = new s(e2.dyn_dtree, v), e2.bl_desc = new s(e2.bl_tree, b), e2.bi_buf = 0, e2.bi_valid = 0, A(e2);
                                              }, r6._tr_stored_block = U, r6._tr_flush_block = function(e2, t7, r7, n7) {
                                                var i2, s2, a2 = 0;
                                                0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
                                                  var t8, r8 = 4093624447;
                                                  for (t8 = 0; t8 <= 31; t8++, r8 >>>= 1)
                                                    if (1 & r8 && 0 !== e3.dyn_ltree[2 * t8])
                                                      return 0;
                                                  if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
                                                    return 1;
                                                  for (t8 = 32; t8 < 256; t8++)
                                                    if (0 !== e3.dyn_ltree[2 * t8])
                                                      return 1;
                                                  return 0;
                                                }(e2)), R(e2, e2.l_desc), R(e2, e2.d_desc), a2 = function(e3) {
                                                  var t8;
                                                  for (D(e3, e3.dyn_ltree, e3.l_desc.max_code), D(e3, e3.dyn_dtree, e3.d_desc.max_code), R(e3, e3.bl_desc), t8 = 18; 3 <= t8 && 0 === e3.bl_tree[2 * f[t8] + 1]; t8--)
                                                    ;
                                                  return e3.opt_len += 3 * (t8 + 1) + 5 + 5 + 4, t8;
                                                }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r7 + 5, r7 + 4 <= i2 && -1 !== t7 ? U(e2, t7, r7, n7) : 4 === e2.strategy || s2 === i2 ? (S(e2, 2 + (n7 ? 1 : 0), 3), T(e2, l6, d)) : (S(e2, 4 + (n7 ? 1 : 0), 3), function(e3, t8, r8, n8) {
                                                  var i3;
                                                  for (S(e3, t8 - 257, 5), S(e3, r8 - 1, 5), S(e3, n8 - 4, 4), i3 = 0; i3 < n8; i3++)
                                                    S(e3, e3.bl_tree[2 * f[i3] + 1], 3);
                                                  F(e3, e3.dyn_ltree, t8 - 1), F(e3, e3.dyn_dtree, r8 - 1);
                                                }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), T(e2, e2.dyn_ltree, e2.dyn_dtree)), A(e2), n7 && I(e2);
                                              }, r6._tr_tally = function(e2, t7, r7) {
                                                return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t7 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t7, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r7, e2.last_lit++, 0 === t7 ? e2.dyn_ltree[2 * r7]++ : (e2.matches++, t7--, e2.dyn_ltree[2 * (p[r7] + 256 + 1)]++, e2.dyn_dtree[2 * k(t7)]++), e2.last_lit === e2.lit_bufsize - 1;
                                              }, r6._tr_align = function(e2) {
                                                var t7;
                                                S(e2, 2, 3), z(e2, 256, l6), 16 === (t7 = e2).bi_valid ? (x(t7, t7.bi_buf), t7.bi_buf = 0, t7.bi_valid = 0) : 8 <= t7.bi_valid && (t7.pending_buf[t7.pending++] = 255 & t7.bi_buf, t7.bi_buf >>= 8, t7.bi_valid -= 8);
                                              };
                                            }, { "../utils/common": 41 }], 53: [function(e, t6, r6) {
                                              "use strict";
                                              t6.exports = function() {
                                                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
                                              };
                                            }, {}], 54: [function(e, t6, r6) {
                                              "use strict";
                                              t6.exports = "function" == typeof setImmediate ? setImmediate : function() {
                                                var e2 = [].slice.apply(arguments);
                                                e2.splice(1, 0, 0), setTimeout.apply(null, e2);
                                              };
                                            }, {}] }, {}, [10])(10);
                                          });
                                        }).call(this, void 0 !== r4 ? r4 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                                      }, {}] }, {}, [1])(1);
                                    });
                                  }).call(this, void 0 !== r3 ? r3 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                                }, {}] }, {}, [1])(1);
                              });
                            }).call(this, void 0 !== r2 ? r2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                          }, {}] }, {}, [1])(1);
                        });
                      }).call(this, void 0 !== r ? r : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                    }, {}] }, {}, [1])(1);
                  });
                }).call(this, "undefined" != typeof global2 ? global2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
              }, {}] }, {}, [1])(1);
            });
          }).call(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer, require2("timers").setImmediate);
      }, { "buffer": 8, "timers": 22 }], 12: [function(require2, module3, exports3) {
        "use strict";
        var immediate = require2("immediate");
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module3.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["finally"] = function(callback) {
          if (typeof callback !== "function") {
            return this;
          }
          var p = this.constructor;
          return this.then(resolve2, reject2);
          function resolve2(value) {
            function yes() {
              return value;
            }
            return p.resolve(callback()).then(yes);
          }
          function reject2(reason) {
            function no() {
              throw reason;
            }
            return p.resolve(callback()).then(no);
          }
        };
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e) {
              return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e) {
            out.status = "error";
            out.value = e;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            allResolver(iterable[i], i);
          }
          return promise;
          function allResolver(value, i2) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i2] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            resolver(iterable[i]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "immediate": 10 }], 13: [function(require2, module3, exports3) {
        ;
        (function() {
          if (typeof module3 === "object" && module3.exports) {
            module3.exports = LRUCache;
          } else {
            this.LRUCache = LRUCache;
          }
          function hOP(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
          }
          function naiveLength() {
            return 1;
          }
          var didTypeWarning = false;
          function typeCheckKey(key) {
            if (!didTypeWarning && typeof key !== "string" && typeof key !== "number") {
              didTypeWarning = true;
              console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack);
            }
          }
          function LRUCache(options) {
            if (!(this instanceof LRUCache))
              return new LRUCache(options);
            if (typeof options === "number")
              options = { max: options };
            if (!options)
              options = {};
            this._max = options.max;
            if (!this._max || !(typeof this._max === "number") || this._max <= 0)
              this._max = Infinity;
            this._lengthCalculator = options.length || naiveLength;
            if (typeof this._lengthCalculator !== "function")
              this._lengthCalculator = naiveLength;
            this._allowStale = options.stale || false;
            this._maxAge = options.maxAge || null;
            this._dispose = options.dispose;
            this.reset();
          }
          Object.defineProperty(
            LRUCache.prototype,
            "max",
            {
              set: function(mL) {
                if (!mL || !(typeof mL === "number") || mL <= 0)
                  mL = Infinity;
                this._max = mL;
                if (this._length > this._max)
                  trim(this);
              },
              get: function() {
                return this._max;
              },
              enumerable: true
            }
          );
          Object.defineProperty(
            LRUCache.prototype,
            "lengthCalculator",
            {
              set: function(lC) {
                if (typeof lC !== "function") {
                  this._lengthCalculator = naiveLength;
                  this._length = this._itemCount;
                  for (var key in this._cache) {
                    this._cache[key].length = 1;
                  }
                } else {
                  this._lengthCalculator = lC;
                  this._length = 0;
                  for (var key in this._cache) {
                    this._cache[key].length = this._lengthCalculator(this._cache[key].value);
                    this._length += this._cache[key].length;
                  }
                }
                if (this._length > this._max)
                  trim(this);
              },
              get: function() {
                return this._lengthCalculator;
              },
              enumerable: true
            }
          );
          Object.defineProperty(
            LRUCache.prototype,
            "length",
            {
              get: function() {
                return this._length;
              },
              enumerable: true
            }
          );
          Object.defineProperty(
            LRUCache.prototype,
            "itemCount",
            {
              get: function() {
                return this._itemCount;
              },
              enumerable: true
            }
          );
          LRUCache.prototype.forEach = function(fn, thisp) {
            thisp = thisp || this;
            var i = 0;
            var itemCount = this._itemCount;
            for (var k = this._mru - 1; k >= 0 && i < itemCount; k--)
              if (this._lruList[k]) {
                i++;
                var hit = this._lruList[k];
                if (isStale(this, hit)) {
                  del(this, hit);
                  if (!this._allowStale)
                    hit = void 0;
                }
                if (hit) {
                  fn.call(thisp, hit.value, hit.key, this);
                }
              }
          };
          LRUCache.prototype.keys = function() {
            var keys = new Array(this._itemCount);
            var i = 0;
            for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
              if (this._lruList[k]) {
                var hit = this._lruList[k];
                keys[i++] = hit.key;
              }
            return keys;
          };
          LRUCache.prototype.values = function() {
            var values = new Array(this._itemCount);
            var i = 0;
            for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
              if (this._lruList[k]) {
                var hit = this._lruList[k];
                values[i++] = hit.value;
              }
            return values;
          };
          LRUCache.prototype.reset = function() {
            if (this._dispose && this._cache) {
              for (var k in this._cache) {
                this._dispose(k, this._cache[k].value);
              }
            }
            this._cache = /* @__PURE__ */ Object.create(null);
            this._lruList = /* @__PURE__ */ Object.create(null);
            this._mru = 0;
            this._lru = 0;
            this._length = 0;
            this._itemCount = 0;
          };
          LRUCache.prototype.dump = function() {
            var arr = [];
            var i = 0;
            for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
              if (this._lruList[k]) {
                var hit = this._lruList[k];
                if (!isStale(this, hit)) {
                  ++i;
                  arr.push({
                    k: hit.key,
                    v: hit.value,
                    e: hit.now + (hit.maxAge || 0)
                  });
                }
              }
            return arr;
          };
          LRUCache.prototype.dumpLru = function() {
            return this._lruList;
          };
          LRUCache.prototype.set = function(key, value, maxAge) {
            maxAge = maxAge || this._maxAge;
            typeCheckKey(key);
            var now = maxAge ? Date.now() : 0;
            var len = this._lengthCalculator(value);
            if (hOP(this._cache, key)) {
              if (len > this._max) {
                del(this, this._cache[key]);
                return false;
              }
              if (this._dispose)
                this._dispose(key, this._cache[key].value);
              this._cache[key].now = now;
              this._cache[key].maxAge = maxAge;
              this._cache[key].value = value;
              this._length += len - this._cache[key].length;
              this._cache[key].length = len;
              this.get(key);
              if (this._length > this._max)
                trim(this);
              return true;
            }
            var hit = new Entry(key, value, this._mru++, len, now, maxAge);
            if (hit.length > this._max) {
              if (this._dispose)
                this._dispose(key, value);
              return false;
            }
            this._length += hit.length;
            this._lruList[hit.lu] = this._cache[key] = hit;
            this._itemCount++;
            if (this._length > this._max)
              trim(this);
            return true;
          };
          LRUCache.prototype.has = function(key) {
            typeCheckKey(key);
            if (!hOP(this._cache, key))
              return false;
            var hit = this._cache[key];
            if (isStale(this, hit)) {
              return false;
            }
            return true;
          };
          LRUCache.prototype.get = function(key) {
            typeCheckKey(key);
            return get(this, key, true);
          };
          LRUCache.prototype.peek = function(key) {
            typeCheckKey(key);
            return get(this, key, false);
          };
          LRUCache.prototype.pop = function() {
            var hit = this._lruList[this._lru];
            del(this, hit);
            return hit || null;
          };
          LRUCache.prototype.del = function(key) {
            typeCheckKey(key);
            del(this, this._cache[key]);
          };
          LRUCache.prototype.load = function(arr) {
            this.reset();
            var now = Date.now();
            for (var l = arr.length - 1; l >= 0; l--) {
              var hit = arr[l];
              typeCheckKey(hit.k);
              var expiresAt = hit.e || 0;
              if (expiresAt === 0) {
                this.set(hit.k, hit.v);
              } else {
                var maxAge = expiresAt - now;
                if (maxAge > 0)
                  this.set(hit.k, hit.v, maxAge);
              }
            }
          };
          function get(self2, key, doUse) {
            typeCheckKey(key);
            var hit = self2._cache[key];
            if (hit) {
              if (isStale(self2, hit)) {
                del(self2, hit);
                if (!self2._allowStale)
                  hit = void 0;
              } else {
                if (doUse)
                  use(self2, hit);
              }
              if (hit)
                hit = hit.value;
            }
            return hit;
          }
          function isStale(self2, hit) {
            if (!hit || !hit.maxAge && !self2._maxAge)
              return false;
            var stale = false;
            var diff = Date.now() - hit.now;
            if (hit.maxAge) {
              stale = diff > hit.maxAge;
            } else {
              stale = self2._maxAge && diff > self2._maxAge;
            }
            return stale;
          }
          function use(self2, hit) {
            shiftLU(self2, hit);
            hit.lu = self2._mru++;
            self2._lruList[hit.lu] = hit;
          }
          function trim(self2) {
            while (self2._lru < self2._mru && self2._length > self2._max)
              del(self2, self2._lruList[self2._lru]);
          }
          function shiftLU(self2, hit) {
            delete self2._lruList[hit.lu];
            while (self2._lru < self2._mru && !self2._lruList[self2._lru])
              self2._lru++;
          }
          function del(self2, hit) {
            if (hit) {
              if (self2._dispose)
                self2._dispose(hit.key, hit.value);
              self2._length -= hit.length;
              self2._itemCount--;
              delete self2._cache[hit.key];
              shiftLU(self2, hit);
            }
          }
          function Entry(key, value, lu, length, now, maxAge) {
            this.key = key;
            this.value = value;
            this.lu = lu;
            this.length = length;
            this.now = now;
            if (maxAge)
              this.maxAge = maxAge;
          }
        })();
      }, {}], 14: [function(require2, module3, exports3) {
        require2("text-encoding-polyfill");
        var StringDecoder = require2("string_decoder").StringDecoder;
        function defaultDecoder(data) {
          var decoder = new StringDecoder();
          var out = decoder.write(data) + decoder.end();
          return out.replace(/\0/g, "").trim();
        }
        module3.exports = createDecoder;
        var regex = /^(?:ANSI\s)?(\d+)$/m;
        function createDecoder(encoding, second) {
          if (!encoding) {
            return defaultDecoder;
          }
          try {
            new TextDecoder(encoding.trim());
          } catch (e) {
            var match = regex.exec(encoding);
            if (match && !second) {
              return createDecoder("windows-" + match[1], true);
            } else {
              return defaultDecoder;
            }
          }
          return browserDecoder;
          function browserDecoder(buffer) {
            var decoder = new TextDecoder(encoding);
            var out = decoder.decode(buffer, {
              stream: true
            }) + decoder.decode();
            return out.replace(/\0/g, "").trim();
          }
        }
      }, { "string_decoder": 19, "text-encoding-polyfill": 20 }], 15: [function(require2, module3, exports3) {
        var createDecoder = require2("./decoder");
        function dbfHeader(data) {
          var out = {};
          out.lastUpdated = new Date(data.readUInt8(1) + 1900, data.readUInt8(2), data.readUInt8(3));
          out.records = data.readUInt32LE(4);
          out.headerLen = data.readUInt16LE(8);
          out.recLen = data.readUInt16LE(10);
          return out;
        }
        function dbfRowHeader(data, headerLen, decoder) {
          var out = [];
          var offset = 32;
          while (offset < headerLen) {
            out.push({
              name: decoder(data.slice(offset, offset + 11)),
              dataType: String.fromCharCode(data.readUInt8(offset + 11)),
              len: data.readUInt8(offset + 16),
              decimal: data.readUInt8(offset + 17)
            });
            if (data.readUInt8(offset + 32) === 13) {
              break;
            } else {
              offset += 32;
            }
          }
          return out;
        }
        function rowFuncs(buffer, offset, len, type, decoder) {
          var data = buffer.slice(offset, offset + len);
          var textData = decoder(data);
          switch (type) {
            case "N":
            case "F":
            case "O":
              return parseFloat(textData, 10);
            case "D":
              return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));
            case "L":
              return textData.toLowerCase() === "y" || textData.toLowerCase() === "t";
            default:
              return textData;
          }
        }
        function parseRow(buffer, offset, rowHeaders, decoder) {
          var out = {};
          var i = 0;
          var len = rowHeaders.length;
          var field;
          var header;
          while (i < len) {
            header = rowHeaders[i];
            field = rowFuncs(buffer, offset, header.len, header.dataType, decoder);
            offset += header.len;
            if (typeof field !== "undefined") {
              out[header.name] = field;
            }
            i++;
          }
          return out;
        }
        module3.exports = function(buffer, encoding) {
          var decoder = createDecoder(encoding);
          var header = dbfHeader(buffer);
          var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1, decoder);
          var offset = (rowHeaders.length + 1 << 5) + 2;
          var recLen = header.recLen;
          var records = header.records;
          var out = [];
          while (records) {
            out.push(parseRow(buffer, offset, rowHeaders, decoder));
            offset += recLen;
            records--;
          }
          return out;
        };
      }, { "./decoder": 14 }], 16: [function(require2, module3, exports3) {
        var process = module3.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 17: [function(require2, module3, exports3) {
        (function(global2, factory) {
          typeof exports3 === "object" && typeof module3 !== "undefined" ? module3.exports = factory() : typeof define2 === "function" && define2.amd ? define2(factory) : global2.proj4 = factory();
        })(this, function() {
          "use strict";
          var globals = function(defs2) {
            defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
            defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
            defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
            defs2.WGS84 = defs2["EPSG:4326"];
            defs2["EPSG:3785"] = defs2["EPSG:3857"];
            defs2.GOOGLE = defs2["EPSG:3857"];
            defs2["EPSG:900913"] = defs2["EPSG:3857"];
            defs2["EPSG:102113"] = defs2["EPSG:3857"];
          };
          var PJD_3PARAM = 1;
          var PJD_7PARAM = 2;
          var PJD_GRIDSHIFT = 3;
          var PJD_WGS84 = 4;
          var PJD_NODATUM = 5;
          var SRS_WGS84_SEMIMAJOR = 6378137;
          var SRS_WGS84_SEMIMINOR = 6356752314e-3;
          var SRS_WGS84_ESQUARED = 0.0066943799901413165;
          var SEC_TO_RAD = 484813681109536e-20;
          var HALF_PI = Math.PI / 2;
          var SIXTH = 0.16666666666666666;
          var RA4 = 0.04722222222222222;
          var RA6 = 0.022156084656084655;
          var EPSLN = 1e-10;
          var D2R = 0.017453292519943295;
          var R2D = 57.29577951308232;
          var FORTPI = Math.PI / 4;
          var TWO_PI = Math.PI * 2;
          var SPI = 3.14159265359;
          var exports$1 = {};
          exports$1.greenwich = 0;
          exports$1.lisbon = -9.131906111111;
          exports$1.paris = 2.337229166667;
          exports$1.bogota = -74.080916666667;
          exports$1.madrid = -3.687938888889;
          exports$1.rome = 12.452333333333;
          exports$1.bern = 7.439583333333;
          exports$1.jakarta = 106.807719444444;
          exports$1.ferro = -17.666666666667;
          exports$1.brussels = 4.367975;
          exports$1.stockholm = 18.058277777778;
          exports$1.athens = 23.7163375;
          exports$1.oslo = 10.722916666667;
          var units = {
            ft: { to_meter: 0.3048 },
            "us-ft": { to_meter: 1200 / 3937 }
          };
          var ignoredChar = /[\s_\-\/\(\)]/g;
          function match(obj, key) {
            if (obj[key]) {
              return obj[key];
            }
            var keys = Object.keys(obj);
            var lkey = key.toLowerCase().replace(ignoredChar, "");
            var i = -1;
            var testkey, processedKey;
            while (++i < keys.length) {
              testkey = keys[i];
              processedKey = testkey.toLowerCase().replace(ignoredChar, "");
              if (processedKey === lkey) {
                return obj[testkey];
              }
            }
          }
          var parseProj = function(defData) {
            var self2 = {};
            var paramObj = defData.split("+").map(function(v) {
              return v.trim();
            }).filter(function(a) {
              return a;
            }).reduce(function(p, a) {
              var split = a.split("=");
              split.push(true);
              p[split[0].toLowerCase()] = split[1];
              return p;
            }, {});
            var paramName, paramVal, paramOutname;
            var params2 = {
              proj: "projName",
              datum: "datumCode",
              rf: function(v) {
                self2.rf = parseFloat(v);
              },
              lat_0: function(v) {
                self2.lat0 = v * D2R;
              },
              lat_1: function(v) {
                self2.lat1 = v * D2R;
              },
              lat_2: function(v) {
                self2.lat2 = v * D2R;
              },
              lat_ts: function(v) {
                self2.lat_ts = v * D2R;
              },
              lon_0: function(v) {
                self2.long0 = v * D2R;
              },
              lon_1: function(v) {
                self2.long1 = v * D2R;
              },
              lon_2: function(v) {
                self2.long2 = v * D2R;
              },
              alpha: function(v) {
                self2.alpha = parseFloat(v) * D2R;
              },
              gamma: function(v) {
                self2.rectified_grid_angle = parseFloat(v);
              },
              lonc: function(v) {
                self2.longc = v * D2R;
              },
              x_0: function(v) {
                self2.x0 = parseFloat(v);
              },
              y_0: function(v) {
                self2.y0 = parseFloat(v);
              },
              k_0: function(v) {
                self2.k0 = parseFloat(v);
              },
              k: function(v) {
                self2.k0 = parseFloat(v);
              },
              a: function(v) {
                self2.a = parseFloat(v);
              },
              b: function(v) {
                self2.b = parseFloat(v);
              },
              r_a: function() {
                self2.R_A = true;
              },
              zone: function(v) {
                self2.zone = parseInt(v, 10);
              },
              south: function() {
                self2.utmSouth = true;
              },
              towgs84: function(v) {
                self2.datum_params = v.split(",").map(function(a) {
                  return parseFloat(a);
                });
              },
              to_meter: function(v) {
                self2.to_meter = parseFloat(v);
              },
              units: function(v) {
                self2.units = v;
                var unit = match(units, v);
                if (unit) {
                  self2.to_meter = unit.to_meter;
                }
              },
              from_greenwich: function(v) {
                self2.from_greenwich = v * D2R;
              },
              pm: function(v) {
                var pm = match(exports$1, v);
                self2.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
              },
              nadgrids: function(v) {
                if (v === "@null") {
                  self2.datumCode = "none";
                } else {
                  self2.nadgrids = v;
                }
              },
              axis: function(v) {
                var legalAxis = "ewnsud";
                if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
                  self2.axis = v;
                }
              },
              approx: function() {
                self2.approx = true;
              }
            };
            for (paramName in paramObj) {
              paramVal = paramObj[paramName];
              if (paramName in params2) {
                paramOutname = params2[paramName];
                if (typeof paramOutname === "function") {
                  paramOutname(paramVal);
                } else {
                  self2[paramOutname] = paramVal;
                }
              } else {
                self2[paramName] = paramVal;
              }
            }
            if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
              self2.datumCode = self2.datumCode.toLowerCase();
            }
            return self2;
          };
          var NEUTRAL = 1;
          var KEYWORD = 2;
          var NUMBER = 3;
          var QUOTED = 4;
          var AFTERQUOTE = 5;
          var ENDED = -1;
          var whitespace = /\s/;
          var latin = /[A-Za-z]/;
          var keyword = /[A-Za-z84]/;
          var endThings = /[,\]]/;
          var digets = /[\d\.E\-\+]/;
          function Parser(text) {
            if (typeof text !== "string") {
              throw new Error("not a string");
            }
            this.text = text.trim();
            this.level = 0;
            this.place = 0;
            this.root = null;
            this.stack = [];
            this.currentObject = null;
            this.state = NEUTRAL;
          }
          Parser.prototype.readCharicter = function() {
            var char = this.text[this.place++];
            if (this.state !== QUOTED) {
              while (whitespace.test(char)) {
                if (this.place >= this.text.length) {
                  return;
                }
                char = this.text[this.place++];
              }
            }
            switch (this.state) {
              case NEUTRAL:
                return this.neutral(char);
              case KEYWORD:
                return this.keyword(char);
              case QUOTED:
                return this.quoted(char);
              case AFTERQUOTE:
                return this.afterquote(char);
              case NUMBER:
                return this.number(char);
              case ENDED:
                return;
            }
          };
          Parser.prototype.afterquote = function(char) {
            if (char === '"') {
              this.word += '"';
              this.state = QUOTED;
              return;
            }
            if (endThings.test(char)) {
              this.word = this.word.trim();
              this.afterItem(char);
              return;
            }
            throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
          };
          Parser.prototype.afterItem = function(char) {
            if (char === ",") {
              if (this.word !== null) {
                this.currentObject.push(this.word);
              }
              this.word = null;
              this.state = NEUTRAL;
              return;
            }
            if (char === "]") {
              this.level--;
              if (this.word !== null) {
                this.currentObject.push(this.word);
                this.word = null;
              }
              this.state = NEUTRAL;
              this.currentObject = this.stack.pop();
              if (!this.currentObject) {
                this.state = ENDED;
              }
              return;
            }
          };
          Parser.prototype.number = function(char) {
            if (digets.test(char)) {
              this.word += char;
              return;
            }
            if (endThings.test(char)) {
              this.word = parseFloat(this.word);
              this.afterItem(char);
              return;
            }
            throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
          };
          Parser.prototype.quoted = function(char) {
            if (char === '"') {
              this.state = AFTERQUOTE;
              return;
            }
            this.word += char;
            return;
          };
          Parser.prototype.keyword = function(char) {
            if (keyword.test(char)) {
              this.word += char;
              return;
            }
            if (char === "[") {
              var newObjects = [];
              newObjects.push(this.word);
              this.level++;
              if (this.root === null) {
                this.root = newObjects;
              } else {
                this.currentObject.push(newObjects);
              }
              this.stack.push(this.currentObject);
              this.currentObject = newObjects;
              this.state = NEUTRAL;
              return;
            }
            if (endThings.test(char)) {
              this.afterItem(char);
              return;
            }
            throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
          };
          Parser.prototype.neutral = function(char) {
            if (latin.test(char)) {
              this.word = char;
              this.state = KEYWORD;
              return;
            }
            if (char === '"') {
              this.word = "";
              this.state = QUOTED;
              return;
            }
            if (digets.test(char)) {
              this.word = char;
              this.state = NUMBER;
              return;
            }
            if (endThings.test(char)) {
              this.afterItem(char);
              return;
            }
            throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
          };
          Parser.prototype.output = function() {
            while (this.place < this.text.length) {
              this.readCharicter();
            }
            if (this.state === ENDED) {
              return this.root;
            }
            throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
          };
          function parseString(txt) {
            var parser = new Parser(txt);
            return parser.output();
          }
          function mapit(obj, key, value) {
            if (Array.isArray(key)) {
              value.unshift(key);
              key = null;
            }
            var thing = key ? {} : obj;
            var out = value.reduce(function(newObj, item) {
              sExpr(item, newObj);
              return newObj;
            }, thing);
            if (key) {
              obj[key] = out;
            }
          }
          function sExpr(v, obj) {
            if (!Array.isArray(v)) {
              obj[v] = true;
              return;
            }
            var key = v.shift();
            if (key === "PARAMETER") {
              key = v.shift();
            }
            if (v.length === 1) {
              if (Array.isArray(v[0])) {
                obj[key] = {};
                sExpr(v[0], obj[key]);
                return;
              }
              obj[key] = v[0];
              return;
            }
            if (!v.length) {
              obj[key] = true;
              return;
            }
            if (key === "TOWGS84") {
              obj[key] = v;
              return;
            }
            if (key === "AXIS") {
              if (!(key in obj)) {
                obj[key] = [];
              }
              obj[key].push(v);
              return;
            }
            if (!Array.isArray(key)) {
              obj[key] = {};
            }
            var i;
            switch (key) {
              case "UNIT":
              case "PRIMEM":
              case "VERT_DATUM":
                obj[key] = {
                  name: v[0].toLowerCase(),
                  convert: v[1]
                };
                if (v.length === 3) {
                  sExpr(v[2], obj[key]);
                }
                return;
              case "SPHEROID":
              case "ELLIPSOID":
                obj[key] = {
                  name: v[0],
                  a: v[1],
                  rf: v[2]
                };
                if (v.length === 4) {
                  sExpr(v[3], obj[key]);
                }
                return;
              case "PROJECTEDCRS":
              case "PROJCRS":
              case "GEOGCS":
              case "GEOCCS":
              case "PROJCS":
              case "LOCAL_CS":
              case "GEODCRS":
              case "GEODETICCRS":
              case "GEODETICDATUM":
              case "EDATUM":
              case "ENGINEERINGDATUM":
              case "VERT_CS":
              case "VERTCRS":
              case "VERTICALCRS":
              case "COMPD_CS":
              case "COMPOUNDCRS":
              case "ENGINEERINGCRS":
              case "ENGCRS":
              case "FITTED_CS":
              case "LOCAL_DATUM":
              case "DATUM":
                v[0] = ["name", v[0]];
                mapit(obj, key, v);
                return;
              default:
                i = -1;
                while (++i < v.length) {
                  if (!Array.isArray(v[i])) {
                    return sExpr(v, obj[key]);
                  }
                }
                return mapit(obj, key, v);
            }
          }
          var D2R$1 = 0.017453292519943295;
          function rename(obj, params2) {
            var outName = params2[0];
            var inName = params2[1];
            if (!(outName in obj) && inName in obj) {
              obj[outName] = obj[inName];
              if (params2.length === 3) {
                obj[outName] = params2[2](obj[outName]);
              }
            }
          }
          function d2r(input) {
            return input * D2R$1;
          }
          function cleanWKT(wkt2) {
            if (wkt2.type === "GEOGCS") {
              wkt2.projName = "longlat";
            } else if (wkt2.type === "LOCAL_CS") {
              wkt2.projName = "identity";
              wkt2.local = true;
            } else {
              if (typeof wkt2.PROJECTION === "object") {
                wkt2.projName = Object.keys(wkt2.PROJECTION)[0];
              } else {
                wkt2.projName = wkt2.PROJECTION;
              }
            }
            if (wkt2.AXIS) {
              var axisOrder = "";
              for (var i = 0, ii = wkt2.AXIS.length; i < ii; ++i) {
                var axis = [wkt2.AXIS[i][0].toLowerCase(), wkt2.AXIS[i][1].toLowerCase()];
                if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
                  axisOrder += "n";
                } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
                  axisOrder += "s";
                } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
                  axisOrder += "e";
                } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
                  axisOrder += "w";
                }
              }
              if (axisOrder.length === 2) {
                axisOrder += "u";
              }
              if (axisOrder.length === 3) {
                wkt2.axis = axisOrder;
              }
            }
            if (wkt2.UNIT) {
              wkt2.units = wkt2.UNIT.name.toLowerCase();
              if (wkt2.units === "metre") {
                wkt2.units = "meter";
              }
              if (wkt2.UNIT.convert) {
                if (wkt2.type === "GEOGCS") {
                  if (wkt2.DATUM && wkt2.DATUM.SPHEROID) {
                    wkt2.to_meter = wkt2.UNIT.convert * wkt2.DATUM.SPHEROID.a;
                  }
                } else {
                  wkt2.to_meter = wkt2.UNIT.convert;
                }
              }
            }
            var geogcs = wkt2.GEOGCS;
            if (wkt2.type === "GEOGCS") {
              geogcs = wkt2;
            }
            if (geogcs) {
              if (geogcs.DATUM) {
                wkt2.datumCode = geogcs.DATUM.name.toLowerCase();
              } else {
                wkt2.datumCode = geogcs.name.toLowerCase();
              }
              if (wkt2.datumCode.slice(0, 2) === "d_") {
                wkt2.datumCode = wkt2.datumCode.slice(2);
              }
              if (wkt2.datumCode === "new_zealand_geodetic_datum_1949" || wkt2.datumCode === "new_zealand_1949") {
                wkt2.datumCode = "nzgd49";
              }
              if (wkt2.datumCode === "wgs_1984" || wkt2.datumCode === "world_geodetic_system_1984") {
                if (wkt2.PROJECTION === "Mercator_Auxiliary_Sphere") {
                  wkt2.sphere = true;
                }
                wkt2.datumCode = "wgs84";
              }
              if (wkt2.datumCode.slice(-6) === "_ferro") {
                wkt2.datumCode = wkt2.datumCode.slice(0, -6);
              }
              if (wkt2.datumCode.slice(-8) === "_jakarta") {
                wkt2.datumCode = wkt2.datumCode.slice(0, -8);
              }
              if (~wkt2.datumCode.indexOf("belge")) {
                wkt2.datumCode = "rnb72";
              }
              if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
                wkt2.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
                if (wkt2.ellps.toLowerCase().slice(0, 13) === "international") {
                  wkt2.ellps = "intl";
                }
                wkt2.a = geogcs.DATUM.SPHEROID.a;
                wkt2.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
              }
              if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
                wkt2.datum_params = geogcs.DATUM.TOWGS84;
              }
              if (~wkt2.datumCode.indexOf("osgb_1936")) {
                wkt2.datumCode = "osgb36";
              }
              if (~wkt2.datumCode.indexOf("osni_1952")) {
                wkt2.datumCode = "osni52";
              }
              if (~wkt2.datumCode.indexOf("tm65") || ~wkt2.datumCode.indexOf("geodetic_datum_of_1965")) {
                wkt2.datumCode = "ire65";
              }
              if (wkt2.datumCode === "ch1903+") {
                wkt2.datumCode = "ch1903";
              }
              if (~wkt2.datumCode.indexOf("israel")) {
                wkt2.datumCode = "isr93";
              }
            }
            if (wkt2.b && !isFinite(wkt2.b)) {
              wkt2.b = wkt2.a;
            }
            function toMeter(input) {
              var ratio = wkt2.to_meter || 1;
              return input * ratio;
            }
            var renamer = function(a) {
              return rename(wkt2, a);
            };
            var list = [
              ["standard_parallel_1", "Standard_Parallel_1"],
              ["standard_parallel_1", "Latitude of 1st standard parallel"],
              ["standard_parallel_2", "Standard_Parallel_2"],
              ["standard_parallel_2", "Latitude of 2nd standard parallel"],
              ["false_easting", "False_Easting"],
              ["false_easting", "False easting"],
              ["false-easting", "Easting at false origin"],
              ["false_northing", "False_Northing"],
              ["false_northing", "False northing"],
              ["false_northing", "Northing at false origin"],
              ["central_meridian", "Central_Meridian"],
              ["central_meridian", "Longitude of natural origin"],
              ["central_meridian", "Longitude of false origin"],
              ["latitude_of_origin", "Latitude_Of_Origin"],
              ["latitude_of_origin", "Central_Parallel"],
              ["latitude_of_origin", "Latitude of natural origin"],
              ["latitude_of_origin", "Latitude of false origin"],
              ["scale_factor", "Scale_Factor"],
              ["k0", "scale_factor"],
              ["latitude_of_center", "Latitude_Of_Center"],
              ["latitude_of_center", "Latitude_of_center"],
              ["lat0", "latitude_of_center", d2r],
              ["longitude_of_center", "Longitude_Of_Center"],
              ["longitude_of_center", "Longitude_of_center"],
              ["longc", "longitude_of_center", d2r],
              ["x0", "false_easting", toMeter],
              ["y0", "false_northing", toMeter],
              ["long0", "central_meridian", d2r],
              ["lat0", "latitude_of_origin", d2r],
              ["lat0", "standard_parallel_1", d2r],
              ["lat1", "standard_parallel_1", d2r],
              ["lat2", "standard_parallel_2", d2r],
              ["azimuth", "Azimuth"],
              ["alpha", "azimuth", d2r],
              ["srsCode", "name"]
            ];
            list.forEach(renamer);
            if (!wkt2.long0 && wkt2.longc && (wkt2.projName === "Albers_Conic_Equal_Area" || wkt2.projName === "Lambert_Azimuthal_Equal_Area")) {
              wkt2.long0 = wkt2.longc;
            }
            if (!wkt2.lat_ts && wkt2.lat1 && (wkt2.projName === "Stereographic_South_Pole" || wkt2.projName === "Polar Stereographic (variant B)")) {
              wkt2.lat0 = d2r(wkt2.lat1 > 0 ? 90 : -90);
              wkt2.lat_ts = wkt2.lat1;
            }
          }
          var wkt = function(wkt2) {
            var lisp = parseString(wkt2);
            var type = lisp.shift();
            var name = lisp.shift();
            lisp.unshift(["name", name]);
            lisp.unshift(["type", type]);
            var obj = {};
            sExpr(lisp, obj);
            cleanWKT(obj);
            return obj;
          };
          function defs(name) {
            var that = this;
            if (arguments.length === 2) {
              var def = arguments[1];
              if (typeof def === "string") {
                if (def.charAt(0) === "+") {
                  defs[name] = parseProj(arguments[1]);
                } else {
                  defs[name] = wkt(arguments[1]);
                }
              } else {
                defs[name] = def;
              }
            } else if (arguments.length === 1) {
              if (Array.isArray(name)) {
                return name.map(function(v) {
                  if (Array.isArray(v)) {
                    defs.apply(that, v);
                  } else {
                    defs(v);
                  }
                });
              } else if (typeof name === "string") {
                if (name in defs) {
                  return defs[name];
                }
              } else if ("EPSG" in name) {
                defs["EPSG:" + name.EPSG] = name;
              } else if ("ESRI" in name) {
                defs["ESRI:" + name.ESRI] = name;
              } else if ("IAU2000" in name) {
                defs["IAU2000:" + name.IAU2000] = name;
              } else {
                console.log(name);
              }
              return;
            }
          }
          globals(defs);
          function testObj(code) {
            return typeof code === "string";
          }
          function testDef(code) {
            return code in defs;
          }
          var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
          function testWKT(code) {
            return codeWords.some(function(word) {
              return code.indexOf(word) > -1;
            });
          }
          var codes = ["3857", "900913", "3785", "102113"];
          function checkMercator(item) {
            var auth = match(item, "authority");
            if (!auth) {
              return;
            }
            var code = match(auth, "epsg");
            return code && codes.indexOf(code) > -1;
          }
          function checkProjStr(item) {
            var ext = match(item, "extension");
            if (!ext) {
              return;
            }
            return match(ext, "proj4");
          }
          function testProj(code) {
            return code[0] === "+";
          }
          function parse(code) {
            if (testObj(code)) {
              if (testDef(code)) {
                return defs[code];
              }
              if (testWKT(code)) {
                var out = wkt(code);
                if (checkMercator(out)) {
                  return defs["EPSG:3857"];
                }
                var maybeProjStr = checkProjStr(out);
                if (maybeProjStr) {
                  return parseProj(maybeProjStr);
                }
                return out;
              }
              if (testProj(code)) {
                return parseProj(code);
              }
            } else {
              return code;
            }
          }
          var extend = function(destination, source) {
            destination = destination || {};
            var value, property;
            if (!source) {
              return destination;
            }
            for (property in source) {
              value = source[property];
              if (value !== void 0) {
                destination[property] = value;
              }
            }
            return destination;
          };
          var msfnz = function(eccent, sinphi, cosphi) {
            var con = eccent * sinphi;
            return cosphi / Math.sqrt(1 - con * con);
          };
          var sign = function(x) {
            return x < 0 ? -1 : 1;
          };
          var adjust_lon = function(x) {
            return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
          };
          var tsfnz = function(eccent, phi, sinphi) {
            var con = eccent * sinphi;
            var com = 0.5 * eccent;
            con = Math.pow((1 - con) / (1 + con), com);
            return Math.tan(0.5 * (HALF_PI - phi)) / con;
          };
          var phi2z = function(eccent, ts) {
            var eccnth = 0.5 * eccent;
            var con, dphi;
            var phi = HALF_PI - 2 * Math.atan(ts);
            for (var i = 0; i <= 15; i++) {
              con = eccent * Math.sin(phi);
              dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
              phi += dphi;
              if (Math.abs(dphi) <= 1e-10) {
                return phi;
              }
            }
            return -9999;
          };
          function init() {
            var con = this.b / this.a;
            this.es = 1 - con * con;
            if (!("x0" in this)) {
              this.x0 = 0;
            }
            if (!("y0" in this)) {
              this.y0 = 0;
            }
            this.e = Math.sqrt(this.es);
            if (this.lat_ts) {
              if (this.sphere) {
                this.k0 = Math.cos(this.lat_ts);
              } else {
                this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
              }
            } else {
              if (!this.k0) {
                if (this.k) {
                  this.k0 = this.k;
                } else {
                  this.k0 = 1;
                }
              }
            }
          }
          function forward(p) {
            var lon = p.x;
            var lat = p.y;
            if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
              return null;
            }
            var x, y;
            if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
              return null;
            } else {
              if (this.sphere) {
                x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
                y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
              } else {
                var sinphi = Math.sin(lat);
                var ts = tsfnz(this.e, lat, sinphi);
                x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
                y = this.y0 - this.a * this.k0 * Math.log(ts);
              }
              p.x = x;
              p.y = y;
              return p;
            }
          }
          function inverse(p) {
            var x = p.x - this.x0;
            var y = p.y - this.y0;
            var lon, lat;
            if (this.sphere) {
              lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
            } else {
              var ts = Math.exp(-y / (this.a * this.k0));
              lat = phi2z(this.e, ts);
              if (lat === -9999) {
                return null;
              }
            }
            lon = adjust_lon(this.long0 + x / (this.a * this.k0));
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
          var merc = {
            init,
            forward,
            inverse,
            names: names$1
          };
          function init$1() {
          }
          function identity(pt) {
            return pt;
          }
          var names$2 = ["longlat", "identity"];
          var longlat = {
            init: init$1,
            forward: identity,
            inverse: identity,
            names: names$2
          };
          var projs = [merc, longlat];
          var names = {};
          var projStore = [];
          function add(proj, i) {
            var len = projStore.length;
            if (!proj.names) {
              console.log(i);
              return true;
            }
            projStore[len] = proj;
            proj.names.forEach(function(n) {
              names[n.toLowerCase()] = len;
            });
            return this;
          }
          function get(name) {
            if (!name) {
              return false;
            }
            var n = name.toLowerCase();
            if (typeof names[n] !== "undefined" && projStore[names[n]]) {
              return projStore[names[n]];
            }
          }
          function start() {
            projs.forEach(add);
          }
          var projections = {
            start,
            add,
            get
          };
          var exports$2 = {};
          exports$2.MERIT = {
            a: 6378137,
            rf: 298.257,
            ellipseName: "MERIT 1983"
          };
          exports$2.SGS85 = {
            a: 6378136,
            rf: 298.257,
            ellipseName: "Soviet Geodetic System 85"
          };
          exports$2.GRS80 = {
            a: 6378137,
            rf: 298.257222101,
            ellipseName: "GRS 1980(IUGG, 1980)"
          };
          exports$2.IAU76 = {
            a: 6378140,
            rf: 298.257,
            ellipseName: "IAU 1976"
          };
          exports$2.airy = {
            a: 6377563396e-3,
            b: 635625691e-2,
            ellipseName: "Airy 1830"
          };
          exports$2.APL4 = {
            a: 6378137,
            rf: 298.25,
            ellipseName: "Appl. Physics. 1965"
          };
          exports$2.NWL9D = {
            a: 6378145,
            rf: 298.25,
            ellipseName: "Naval Weapons Lab., 1965"
          };
          exports$2.mod_airy = {
            a: 6377340189e-3,
            b: 6356034446e-3,
            ellipseName: "Modified Airy"
          };
          exports$2.andrae = {
            a: 637710443e-2,
            rf: 300,
            ellipseName: "Andrae 1876 (Den., Iclnd.)"
          };
          exports$2.aust_SA = {
            a: 6378160,
            rf: 298.25,
            ellipseName: "Australian Natl & S. Amer. 1969"
          };
          exports$2.GRS67 = {
            a: 6378160,
            rf: 298.247167427,
            ellipseName: "GRS 67(IUGG 1967)"
          };
          exports$2.bessel = {
            a: 6377397155e-3,
            rf: 299.1528128,
            ellipseName: "Bessel 1841"
          };
          exports$2.bess_nam = {
            a: 6377483865e-3,
            rf: 299.1528128,
            ellipseName: "Bessel 1841 (Namibia)"
          };
          exports$2.clrk66 = {
            a: 63782064e-1,
            b: 63565838e-1,
            ellipseName: "Clarke 1866"
          };
          exports$2.clrk80 = {
            a: 6378249145e-3,
            rf: 293.4663,
            ellipseName: "Clarke 1880 mod."
          };
          exports$2.clrk58 = {
            a: 6378293645208759e-9,
            rf: 294.2606763692654,
            ellipseName: "Clarke 1858"
          };
          exports$2.CPM = {
            a: 63757387e-1,
            rf: 334.29,
            ellipseName: "Comm. des Poids et Mesures 1799"
          };
          exports$2.delmbr = {
            a: 6376428,
            rf: 311.5,
            ellipseName: "Delambre 1810 (Belgium)"
          };
          exports$2.engelis = {
            a: 637813605e-2,
            rf: 298.2566,
            ellipseName: "Engelis 1985"
          };
          exports$2.evrst30 = {
            a: 6377276345e-3,
            rf: 300.8017,
            ellipseName: "Everest 1830"
          };
          exports$2.evrst48 = {
            a: 6377304063e-3,
            rf: 300.8017,
            ellipseName: "Everest 1948"
          };
          exports$2.evrst56 = {
            a: 6377301243e-3,
            rf: 300.8017,
            ellipseName: "Everest 1956"
          };
          exports$2.evrst69 = {
            a: 6377295664e-3,
            rf: 300.8017,
            ellipseName: "Everest 1969"
          };
          exports$2.evrstSS = {
            a: 6377298556e-3,
            rf: 300.8017,
            ellipseName: "Everest (Sabah & Sarawak)"
          };
          exports$2.fschr60 = {
            a: 6378166,
            rf: 298.3,
            ellipseName: "Fischer (Mercury Datum) 1960"
          };
          exports$2.fschr60m = {
            a: 6378155,
            rf: 298.3,
            ellipseName: "Fischer 1960"
          };
          exports$2.fschr68 = {
            a: 6378150,
            rf: 298.3,
            ellipseName: "Fischer 1968"
          };
          exports$2.helmert = {
            a: 6378200,
            rf: 298.3,
            ellipseName: "Helmert 1906"
          };
          exports$2.hough = {
            a: 6378270,
            rf: 297,
            ellipseName: "Hough"
          };
          exports$2.intl = {
            a: 6378388,
            rf: 297,
            ellipseName: "International 1909 (Hayford)"
          };
          exports$2.kaula = {
            a: 6378163,
            rf: 298.24,
            ellipseName: "Kaula 1961"
          };
          exports$2.lerch = {
            a: 6378139,
            rf: 298.257,
            ellipseName: "Lerch 1979"
          };
          exports$2.mprts = {
            a: 6397300,
            rf: 191,
            ellipseName: "Maupertius 1738"
          };
          exports$2.new_intl = {
            a: 63781575e-1,
            b: 63567722e-1,
            ellipseName: "New International 1967"
          };
          exports$2.plessis = {
            a: 6376523,
            rf: 6355863,
            ellipseName: "Plessis 1817 (France)"
          };
          exports$2.krass = {
            a: 6378245,
            rf: 298.3,
            ellipseName: "Krassovsky, 1942"
          };
          exports$2.SEasia = {
            a: 6378155,
            b: 63567733205e-4,
            ellipseName: "Southeast Asia"
          };
          exports$2.walbeck = {
            a: 6376896,
            b: 63558348467e-4,
            ellipseName: "Walbeck"
          };
          exports$2.WGS60 = {
            a: 6378165,
            rf: 298.3,
            ellipseName: "WGS 60"
          };
          exports$2.WGS66 = {
            a: 6378145,
            rf: 298.25,
            ellipseName: "WGS 66"
          };
          exports$2.WGS7 = {
            a: 6378135,
            rf: 298.26,
            ellipseName: "WGS 72"
          };
          var WGS84 = exports$2.WGS84 = {
            a: 6378137,
            rf: 298.257223563,
            ellipseName: "WGS 84"
          };
          exports$2.sphere = {
            a: 6370997,
            b: 6370997,
            ellipseName: "Normal Sphere (r=6370997)"
          };
          function eccentricity(a, b, rf, R_A) {
            var a2 = a * a;
            var b2 = b * b;
            var es = (a2 - b2) / a2;
            var e = 0;
            if (R_A) {
              a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
              a2 = a * a;
              es = 0;
            } else {
              e = Math.sqrt(es);
            }
            var ep2 = (a2 - b2) / b2;
            return {
              es,
              e,
              ep2
            };
          }
          function sphere(a, b, rf, ellps, sphere2) {
            if (!a) {
              var ellipse = match(exports$2, ellps);
              if (!ellipse) {
                ellipse = WGS84;
              }
              a = ellipse.a;
              b = ellipse.b;
              rf = ellipse.rf;
            }
            if (rf && !b) {
              b = (1 - 1 / rf) * a;
            }
            if (rf === 0 || Math.abs(a - b) < EPSLN) {
              sphere2 = true;
              b = a;
            }
            return {
              a,
              b,
              rf,
              sphere: sphere2
            };
          }
          var exports$3 = {};
          exports$3.wgs84 = {
            towgs84: "0,0,0",
            ellipse: "WGS84",
            datumName: "WGS84"
          };
          exports$3.ch1903 = {
            towgs84: "674.374,15.056,405.346",
            ellipse: "bessel",
            datumName: "swiss"
          };
          exports$3.ggrs87 = {
            towgs84: "-199.87,74.79,246.62",
            ellipse: "GRS80",
            datumName: "Greek_Geodetic_Reference_System_1987"
          };
          exports$3.nad83 = {
            towgs84: "0,0,0",
            ellipse: "GRS80",
            datumName: "North_American_Datum_1983"
          };
          exports$3.nad27 = {
            nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
            ellipse: "clrk66",
            datumName: "North_American_Datum_1927"
          };
          exports$3.potsdam = {
            towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
            ellipse: "bessel",
            datumName: "Potsdam Rauenberg 1950 DHDN"
          };
          exports$3.carthage = {
            towgs84: "-263.0,6.0,431.0",
            ellipse: "clark80",
            datumName: "Carthage 1934 Tunisia"
          };
          exports$3.hermannskogel = {
            towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
            ellipse: "bessel",
            datumName: "Hermannskogel"
          };
          exports$3.osni52 = {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "airy",
            datumName: "Irish National"
          };
          exports$3.ire65 = {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "mod_airy",
            datumName: "Ireland 1965"
          };
          exports$3.rassadiran = {
            towgs84: "-133.63,-157.5,-158.62",
            ellipse: "intl",
            datumName: "Rassadiran"
          };
          exports$3.nzgd49 = {
            towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
            ellipse: "intl",
            datumName: "New Zealand Geodetic Datum 1949"
          };
          exports$3.osgb36 = {
            towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
            ellipse: "airy",
            datumName: "Airy 1830"
          };
          exports$3.s_jtsk = {
            towgs84: "589,76,480",
            ellipse: "bessel",
            datumName: "S-JTSK (Ferro)"
          };
          exports$3.beduaram = {
            towgs84: "-106,-87,188",
            ellipse: "clrk80",
            datumName: "Beduaram"
          };
          exports$3.gunung_segara = {
            towgs84: "-403,684,41",
            ellipse: "bessel",
            datumName: "Gunung Segara Jakarta"
          };
          exports$3.rnb72 = {
            towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
            ellipse: "intl",
            datumName: "Reseau National Belge 1972"
          };
          function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
            var out = {};
            if (datumCode === void 0 || datumCode === "none") {
              out.datum_type = PJD_NODATUM;
            } else {
              out.datum_type = PJD_WGS84;
            }
            if (datum_params) {
              out.datum_params = datum_params.map(parseFloat);
              if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
                out.datum_type = PJD_3PARAM;
              }
              if (out.datum_params.length > 3) {
                if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
                  out.datum_type = PJD_7PARAM;
                  out.datum_params[3] *= SEC_TO_RAD;
                  out.datum_params[4] *= SEC_TO_RAD;
                  out.datum_params[5] *= SEC_TO_RAD;
                  out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
                }
              }
            }
            if (nadgrids) {
              out.datum_type = PJD_GRIDSHIFT;
              out.grids = nadgrids;
            }
            out.a = a;
            out.b = b;
            out.es = es;
            out.ep2 = ep2;
            return out;
          }
          var loadedNadgrids = {};
          function nadgrid(key, data) {
            var view = new DataView(data);
            var isLittleEndian = detectLittleEndian(view);
            var header = readHeader(view, isLittleEndian);
            if (header.nSubgrids > 1) {
              console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
            }
            var subgrids = readSubgrids(view, header, isLittleEndian);
            var nadgrid2 = { header, subgrids };
            loadedNadgrids[key] = nadgrid2;
            return nadgrid2;
          }
          function getNadgrids(nadgrids) {
            if (nadgrids === void 0) {
              return null;
            }
            var grids = nadgrids.split(",");
            return grids.map(parseNadgridString);
          }
          function parseNadgridString(value) {
            if (value.length === 0) {
              return null;
            }
            var optional = value[0] === "@";
            if (optional) {
              value = value.slice(1);
            }
            if (value === "null") {
              return { name: "null", mandatory: !optional, grid: null, isNull: true };
            }
            return {
              name: value,
              mandatory: !optional,
              grid: loadedNadgrids[value] || null,
              isNull: false
            };
          }
          function secondsToRadians(seconds) {
            return seconds / 3600 * Math.PI / 180;
          }
          function detectLittleEndian(view) {
            var nFields = view.getInt32(8, false);
            if (nFields === 11) {
              return false;
            }
            nFields = view.getInt32(8, true);
            if (nFields !== 11) {
              console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
            }
            return true;
          }
          function readHeader(view, isLittleEndian) {
            return {
              nFields: view.getInt32(8, isLittleEndian),
              nSubgridFields: view.getInt32(24, isLittleEndian),
              nSubgrids: view.getInt32(40, isLittleEndian),
              shiftType: decodeString(view, 56, 56 + 8).trim(),
              fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
              fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
              toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
              toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
            };
          }
          function decodeString(view, start2, end) {
            return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
          }
          function readSubgrids(view, header, isLittleEndian) {
            var gridOffset = 176;
            var grids = [];
            for (var i = 0; i < header.nSubgrids; i++) {
              var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
              var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
              var lngColumnCount = Math.round(
                1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
              );
              var latColumnCount = Math.round(
                1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
              );
              grids.push({
                ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
                del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
                lim: [lngColumnCount, latColumnCount],
                count: subHeader.gridNodeCount,
                cvs: mapNodes(nodes)
              });
            }
            return grids;
          }
          function mapNodes(nodes) {
            return nodes.map(function(r) {
              return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
            });
          }
          function readGridHeader(view, offset, isLittleEndian) {
            return {
              name: decodeString(view, offset + 8, offset + 16).trim(),
              parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
              lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
              upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
              lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
              upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
              latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
              longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
              gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
            };
          }
          function readGridNodes(view, offset, gridHeader, isLittleEndian) {
            var nodesOffset = offset + 176;
            var gridRecordLength = 16;
            var gridShiftRecords = [];
            for (var i = 0; i < gridHeader.gridNodeCount; i++) {
              var record = {
                latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
                longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
                latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
                longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
              };
              gridShiftRecords.push(record);
            }
            return gridShiftRecords;
          }
          function Projection(srsCode, callback) {
            if (!(this instanceof Projection)) {
              return new Projection(srsCode);
            }
            callback = callback || function(error) {
              if (error) {
                throw error;
              }
            };
            var json = parse(srsCode);
            if (typeof json !== "object") {
              callback(srsCode);
              return;
            }
            var ourProj = Projection.projections.get(json.projName);
            if (!ourProj) {
              callback(srsCode);
              return;
            }
            if (json.datumCode && json.datumCode !== "none") {
              var datumDef = match(exports$3, json.datumCode);
              if (datumDef) {
                json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
                json.ellps = datumDef.ellipse;
                json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
              }
            }
            json.k0 = json.k0 || 1;
            json.axis = json.axis || "enu";
            json.ellps = json.ellps || "wgs84";
            json.lat1 = json.lat1 || json.lat0;
            var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
            var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
            var nadgrids = getNadgrids(json.nadgrids);
            var datumObj = json.datum || datum(
              json.datumCode,
              json.datum_params,
              sphere_.a,
              sphere_.b,
              ecc.es,
              ecc.ep2,
              nadgrids
            );
            extend(this, json);
            extend(this, ourProj);
            this.a = sphere_.a;
            this.b = sphere_.b;
            this.rf = sphere_.rf;
            this.sphere = sphere_.sphere;
            this.es = ecc.es;
            this.e = ecc.e;
            this.ep2 = ecc.ep2;
            this.datum = datumObj;
            this.init();
            callback(null, this);
          }
          Projection.projections = projections;
          Projection.projections.start();
          "use strict";
          function compareDatums(source, dest) {
            if (source.datum_type !== dest.datum_type) {
              return false;
            } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
              return false;
            } else if (source.datum_type === PJD_3PARAM) {
              return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
            } else if (source.datum_type === PJD_7PARAM) {
              return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
            } else {
              return true;
            }
          }
          function geodeticToGeocentric(p, es, a) {
            var Longitude = p.x;
            var Latitude = p.y;
            var Height = p.z ? p.z : 0;
            var Rn;
            var Sin_Lat;
            var Sin2_Lat;
            var Cos_Lat;
            if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
              Latitude = -HALF_PI;
            } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
              Latitude = HALF_PI;
            } else if (Latitude < -HALF_PI) {
              return { x: -Infinity, y: -Infinity, z: p.z };
            } else if (Latitude > HALF_PI) {
              return { x: Infinity, y: Infinity, z: p.z };
            }
            if (Longitude > Math.PI) {
              Longitude -= 2 * Math.PI;
            }
            Sin_Lat = Math.sin(Latitude);
            Cos_Lat = Math.cos(Latitude);
            Sin2_Lat = Sin_Lat * Sin_Lat;
            Rn = a / Math.sqrt(1 - es * Sin2_Lat);
            return {
              x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
              y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
              z: (Rn * (1 - es) + Height) * Sin_Lat
            };
          }
          function geocentricToGeodetic(p, es, a, b) {
            var genau = 1e-12;
            var genau2 = genau * genau;
            var maxiter = 30;
            var P;
            var RR;
            var CT;
            var ST;
            var RX;
            var RK;
            var RN;
            var CPHI0;
            var SPHI0;
            var CPHI;
            var SPHI;
            var SDPHI;
            var iter;
            var X = p.x;
            var Y = p.y;
            var Z2 = p.z ? p.z : 0;
            var Longitude;
            var Latitude;
            var Height;
            P = Math.sqrt(X * X + Y * Y);
            RR = Math.sqrt(X * X + Y * Y + Z2 * Z2);
            if (P / a < genau) {
              Longitude = 0;
              if (RR / a < genau) {
                Latitude = HALF_PI;
                Height = -b;
                return {
                  x: p.x,
                  y: p.y,
                  z: p.z
                };
              }
            } else {
              Longitude = Math.atan2(Y, X);
            }
            CT = Z2 / RR;
            ST = P / RR;
            RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
            CPHI0 = ST * (1 - es) * RX;
            SPHI0 = CT * RX;
            iter = 0;
            do {
              iter++;
              RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
              Height = P * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
              RK = es * RN / (RN + Height);
              RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
              CPHI = ST * (1 - RK) * RX;
              SPHI = CT * RX;
              SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
              CPHI0 = CPHI;
              SPHI0 = SPHI;
            } while (SDPHI * SDPHI > genau2 && iter < maxiter);
            Latitude = Math.atan(SPHI / Math.abs(CPHI));
            return {
              x: Longitude,
              y: Latitude,
              z: Height
            };
          }
          function geocentricToWgs84(p, datum_type, datum_params) {
            if (datum_type === PJD_3PARAM) {
              return {
                x: p.x + datum_params[0],
                y: p.y + datum_params[1],
                z: p.z + datum_params[2]
              };
            } else if (datum_type === PJD_7PARAM) {
              var Dx_BF = datum_params[0];
              var Dy_BF = datum_params[1];
              var Dz_BF = datum_params[2];
              var Rx_BF = datum_params[3];
              var Ry_BF = datum_params[4];
              var Rz_BF = datum_params[5];
              var M_BF = datum_params[6];
              return {
                x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
                y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
                z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
              };
            }
          }
          function geocentricFromWgs84(p, datum_type, datum_params) {
            if (datum_type === PJD_3PARAM) {
              return {
                x: p.x - datum_params[0],
                y: p.y - datum_params[1],
                z: p.z - datum_params[2]
              };
            } else if (datum_type === PJD_7PARAM) {
              var Dx_BF = datum_params[0];
              var Dy_BF = datum_params[1];
              var Dz_BF = datum_params[2];
              var Rx_BF = datum_params[3];
              var Ry_BF = datum_params[4];
              var Rz_BF = datum_params[5];
              var M_BF = datum_params[6];
              var x_tmp = (p.x - Dx_BF) / M_BF;
              var y_tmp = (p.y - Dy_BF) / M_BF;
              var z_tmp = (p.z - Dz_BF) / M_BF;
              return {
                x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
                y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
                z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
              };
            }
          }
          function checkParams(type) {
            return type === PJD_3PARAM || type === PJD_7PARAM;
          }
          var datum_transform = function(source, dest, point) {
            if (compareDatums(source, dest)) {
              return point;
            }
            if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
              return point;
            }
            var source_a = source.a;
            var source_es = source.es;
            if (source.datum_type === PJD_GRIDSHIFT) {
              var gridShiftCode = applyGridShift(source, false, point);
              if (gridShiftCode !== 0) {
                return void 0;
              }
              source_a = SRS_WGS84_SEMIMAJOR;
              source_es = SRS_WGS84_ESQUARED;
            }
            var dest_a = dest.a;
            var dest_b = dest.b;
            var dest_es = dest.es;
            if (dest.datum_type === PJD_GRIDSHIFT) {
              dest_a = SRS_WGS84_SEMIMAJOR;
              dest_b = SRS_WGS84_SEMIMINOR;
              dest_es = SRS_WGS84_ESQUARED;
            }
            if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
              return point;
            }
            point = geodeticToGeocentric(point, source_es, source_a);
            if (checkParams(source.datum_type)) {
              point = geocentricToWgs84(point, source.datum_type, source.datum_params);
            }
            if (checkParams(dest.datum_type)) {
              point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
            }
            point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
            if (dest.datum_type === PJD_GRIDSHIFT) {
              var destGridShiftResult = applyGridShift(dest, true, point);
              if (destGridShiftResult !== 0) {
                return void 0;
              }
            }
            return point;
          };
          function applyGridShift(source, inverse2, point) {
            if (source.grids === null || source.grids.length === 0) {
              console.log("Grid shift grids not found");
              return -1;
            }
            var input = { x: -point.x, y: point.y };
            var output = { x: Number.NaN, y: Number.NaN };
            var attemptedGrids = [];
            for (var i = 0; i < source.grids.length; i++) {
              var grid = source.grids[i];
              attemptedGrids.push(grid.name);
              if (grid.isNull) {
                output = input;
                break;
              }
              if (grid.grid === null) {
                if (grid.mandatory) {
                  console.log("Unable to find mandatory grid '" + grid.name + "'");
                  return -1;
                }
                continue;
              }
              var subgrid = grid.grid.subgrids[0];
              var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
              var minX = subgrid.ll[0] - epsilon;
              var minY = subgrid.ll[1] - epsilon;
              var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
              var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
              if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
                continue;
              }
              output = applySubgridShift(input, inverse2, subgrid);
              if (!isNaN(output.x)) {
                break;
              }
            }
            if (isNaN(output.x)) {
              console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
              return -1;
            }
            point.x = -output.x;
            point.y = output.y;
            return 0;
          }
          function applySubgridShift(pin, inverse2, ct) {
            var val = { x: Number.NaN, y: Number.NaN };
            if (isNaN(pin.x)) {
              return val;
            }
            var tb = { x: pin.x, y: pin.y };
            tb.x -= ct.ll[0];
            tb.y -= ct.ll[1];
            tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
            var t = nadInterpolate(tb, ct);
            if (inverse2) {
              if (isNaN(t.x)) {
                return val;
              }
              t.x = tb.x - t.x;
              t.y = tb.y - t.y;
              var i = 9, tol = 1e-12;
              var dif, del;
              do {
                del = nadInterpolate(t, ct);
                if (isNaN(del.x)) {
                  console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
                  break;
                }
                dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
                t.x += dif.x;
                t.y += dif.y;
              } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
              if (i < 0) {
                console.log("Inverse grid shift iterator failed to converge.");
                return val;
              }
              val.x = adjust_lon(t.x + ct.ll[0]);
              val.y = t.y + ct.ll[1];
            } else {
              if (!isNaN(t.x)) {
                val.x = pin.x + t.x;
                val.y = pin.y + t.y;
              }
            }
            return val;
          }
          function nadInterpolate(pin, ct) {
            var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
            var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
            var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
            var val = { x: Number.NaN, y: Number.NaN };
            var inx;
            if (indx.x < 0 || indx.x >= ct.lim[0]) {
              return val;
            }
            if (indx.y < 0 || indx.y >= ct.lim[1]) {
              return val;
            }
            inx = indx.y * ct.lim[0] + indx.x;
            var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
            inx++;
            var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
            inx += ct.lim[0];
            var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
            inx--;
            var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
            var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
            val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
            val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
            return val;
          }
          var adjust_axis = function(crs, denorm, point) {
            var xin = point.x, yin = point.y, zin = point.z || 0;
            var v, t, i;
            var out = {};
            for (i = 0; i < 3; i++) {
              if (denorm && i === 2 && point.z === void 0) {
                continue;
              }
              if (i === 0) {
                v = xin;
                if ("ew".indexOf(crs.axis[i]) !== -1) {
                  t = "x";
                } else {
                  t = "y";
                }
              } else if (i === 1) {
                v = yin;
                if ("ns".indexOf(crs.axis[i]) !== -1) {
                  t = "y";
                } else {
                  t = "x";
                }
              } else {
                v = zin;
                t = "z";
              }
              switch (crs.axis[i]) {
                case "e":
                  out[t] = v;
                  break;
                case "w":
                  out[t] = -v;
                  break;
                case "n":
                  out[t] = v;
                  break;
                case "s":
                  out[t] = -v;
                  break;
                case "u":
                  if (point[t] !== void 0) {
                    out.z = v;
                  }
                  break;
                case "d":
                  if (point[t] !== void 0) {
                    out.z = -v;
                  }
                  break;
                default:
                  return null;
              }
            }
            return out;
          };
          var toPoint = function(array) {
            var out = {
              x: array[0],
              y: array[1]
            };
            if (array.length > 2) {
              out.z = array[2];
            }
            if (array.length > 3) {
              out.m = array[3];
            }
            return out;
          };
          var checkSanity = function(point) {
            checkCoord(point.x);
            checkCoord(point.y);
          };
          function checkCoord(num) {
            if (typeof Number.isFinite === "function") {
              if (Number.isFinite(num)) {
                return;
              }
              throw new TypeError("coordinates must be finite numbers");
            }
            if (typeof num !== "number" || num !== num || !isFinite(num)) {
              throw new TypeError("coordinates must be finite numbers");
            }
          }
          function checkNotWGS(source, dest) {
            return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== "WGS84";
          }
          function transform(source, dest, point) {
            var wgs842;
            if (Array.isArray(point)) {
              point = toPoint(point);
            }
            checkSanity(point);
            if (source.datum && dest.datum && checkNotWGS(source, dest)) {
              wgs842 = new Projection("WGS84");
              point = transform(source, wgs842, point);
              source = wgs842;
            }
            if (source.axis !== "enu") {
              point = adjust_axis(source, false, point);
            }
            if (source.projName === "longlat") {
              point = {
                x: point.x * D2R,
                y: point.y * D2R,
                z: point.z || 0
              };
            } else {
              if (source.to_meter) {
                point = {
                  x: point.x * source.to_meter,
                  y: point.y * source.to_meter,
                  z: point.z || 0
                };
              }
              point = source.inverse(point);
              if (!point) {
                return;
              }
            }
            if (source.from_greenwich) {
              point.x += source.from_greenwich;
            }
            point = datum_transform(source.datum, dest.datum, point);
            if (!point) {
              return;
            }
            if (dest.from_greenwich) {
              point = {
                x: point.x - dest.from_greenwich,
                y: point.y,
                z: point.z || 0
              };
            }
            if (dest.projName === "longlat") {
              point = {
                x: point.x * R2D,
                y: point.y * R2D,
                z: point.z || 0
              };
            } else {
              point = dest.forward(point);
              if (dest.to_meter) {
                point = {
                  x: point.x / dest.to_meter,
                  y: point.y / dest.to_meter,
                  z: point.z || 0
                };
              }
            }
            if (dest.axis !== "enu") {
              return adjust_axis(dest, true, point);
            }
            return point;
          }
          var wgs84 = Projection("WGS84");
          function transformer(from, to, coords) {
            var transformedArray, out, keys;
            if (Array.isArray(coords)) {
              transformedArray = transform(from, to, coords) || { x: NaN, y: NaN };
              if (coords.length > 2) {
                if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
                  if (typeof transformedArray.z === "number") {
                    return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
                  } else {
                    return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
                  }
                } else {
                  return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
                }
              } else {
                return [transformedArray.x, transformedArray.y];
              }
            } else {
              out = transform(from, to, coords);
              keys = Object.keys(coords);
              if (keys.length === 2) {
                return out;
              }
              keys.forEach(function(key) {
                if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
                  if (key === "x" || key === "y" || key === "z") {
                    return;
                  }
                } else {
                  if (key === "x" || key === "y") {
                    return;
                  }
                }
                out[key] = coords[key];
              });
              return out;
            }
          }
          function checkProj(item) {
            if (item instanceof Projection) {
              return item;
            }
            if (item.oProj) {
              return item.oProj;
            }
            return Projection(item);
          }
          function proj4$1(fromProj, toProj, coord) {
            fromProj = checkProj(fromProj);
            var single = false;
            var obj;
            if (typeof toProj === "undefined") {
              toProj = fromProj;
              fromProj = wgs84;
              single = true;
            } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
              coord = toProj;
              toProj = fromProj;
              fromProj = wgs84;
              single = true;
            }
            toProj = checkProj(toProj);
            if (coord) {
              return transformer(fromProj, toProj, coord);
            } else {
              obj = {
                forward: function(coords) {
                  return transformer(fromProj, toProj, coords);
                },
                inverse: function(coords) {
                  return transformer(toProj, fromProj, coords);
                }
              };
              if (single) {
                obj.oProj = toProj;
              }
              return obj;
            }
          }
          var NUM_100K_SETS = 6;
          var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
          var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
          var A = 65;
          var I = 73;
          var O = 79;
          var V = 86;
          var Z = 90;
          var mgrs = {
            forward: forward$1,
            inverse: inverse$1,
            toPoint: toPoint$1
          };
          function forward$1(ll, accuracy) {
            accuracy = accuracy || 5;
            return encode(LLtoUTM({
              lat: ll[1],
              lon: ll[0]
            }), accuracy);
          }
          function inverse$1(mgrs2) {
            var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
            if (bbox.lat && bbox.lon) {
              return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
            }
            return [bbox.left, bbox.bottom, bbox.right, bbox.top];
          }
          function toPoint$1(mgrs2) {
            var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
            if (bbox.lat && bbox.lon) {
              return [bbox.lon, bbox.lat];
            }
            return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
          }
          function degToRad(deg) {
            return deg * (Math.PI / 180);
          }
          function radToDeg(rad) {
            return 180 * (rad / Math.PI);
          }
          function LLtoUTM(ll) {
            var Lat = ll.lat;
            var Long = ll.lon;
            var a = 6378137;
            var eccSquared = 669438e-8;
            var k0 = 0.9996;
            var LongOrigin;
            var eccPrimeSquared;
            var N, T, C, A2, M;
            var LatRad = degToRad(Lat);
            var LongRad = degToRad(Long);
            var LongOriginRad;
            var ZoneNumber;
            ZoneNumber = Math.floor((Long + 180) / 6) + 1;
            if (Long === 180) {
              ZoneNumber = 60;
            }
            if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
              ZoneNumber = 32;
            }
            if (Lat >= 72 && Lat < 84) {
              if (Long >= 0 && Long < 9) {
                ZoneNumber = 31;
              } else if (Long >= 9 && Long < 21) {
                ZoneNumber = 33;
              } else if (Long >= 21 && Long < 33) {
                ZoneNumber = 35;
              } else if (Long >= 33 && Long < 42) {
                ZoneNumber = 37;
              }
            }
            LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
            LongOriginRad = degToRad(LongOrigin);
            eccPrimeSquared = eccSquared / (1 - eccSquared);
            N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
            T = Math.tan(LatRad) * Math.tan(LatRad);
            C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
            A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);
            M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
            var UTMEasting = k0 * N * (A2 + (1 - T + C) * A2 * A2 * A2 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;
            var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T + 9 * C + 4 * C * C) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));
            if (Lat < 0) {
              UTMNorthing += 1e7;
            }
            return {
              northing: Math.round(UTMNorthing),
              easting: Math.round(UTMEasting),
              zoneNumber: ZoneNumber,
              zoneLetter: getLetterDesignator(Lat)
            };
          }
          function UTMtoLL(utm2) {
            var UTMNorthing = utm2.northing;
            var UTMEasting = utm2.easting;
            var zoneLetter = utm2.zoneLetter;
            var zoneNumber = utm2.zoneNumber;
            if (zoneNumber < 0 || zoneNumber > 60) {
              return null;
            }
            var k0 = 0.9996;
            var a = 6378137;
            var eccSquared = 669438e-8;
            var eccPrimeSquared;
            var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
            var N1, T1, C12, R1, D, M;
            var LongOrigin;
            var mu, phi1Rad;
            var x = UTMEasting - 5e5;
            var y = UTMNorthing;
            if (zoneLetter < "N") {
              y -= 1e7;
            }
            LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
            eccPrimeSquared = eccSquared / (1 - eccSquared);
            M = y / k0;
            mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
            phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
            N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
            T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
            C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
            R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
            D = x / (N1 * k0);
            var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D * D * D * D * D * D / 720);
            lat = radToDeg(lat);
            var lon = (D - (1 + 2 * T1 + C12) * D * D * D / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
            lon = LongOrigin + radToDeg(lon);
            var result;
            if (utm2.accuracy) {
              var topRight = UTMtoLL({
                northing: utm2.northing + utm2.accuracy,
                easting: utm2.easting + utm2.accuracy,
                zoneLetter: utm2.zoneLetter,
                zoneNumber: utm2.zoneNumber
              });
              result = {
                top: topRight.lat,
                right: topRight.lon,
                bottom: lat,
                left: lon
              };
            } else {
              result = {
                lat,
                lon
              };
            }
            return result;
          }
          function getLetterDesignator(lat) {
            var LetterDesignator = "Z";
            if (84 >= lat && lat >= 72) {
              LetterDesignator = "X";
            } else if (72 > lat && lat >= 64) {
              LetterDesignator = "W";
            } else if (64 > lat && lat >= 56) {
              LetterDesignator = "V";
            } else if (56 > lat && lat >= 48) {
              LetterDesignator = "U";
            } else if (48 > lat && lat >= 40) {
              LetterDesignator = "T";
            } else if (40 > lat && lat >= 32) {
              LetterDesignator = "S";
            } else if (32 > lat && lat >= 24) {
              LetterDesignator = "R";
            } else if (24 > lat && lat >= 16) {
              LetterDesignator = "Q";
            } else if (16 > lat && lat >= 8) {
              LetterDesignator = "P";
            } else if (8 > lat && lat >= 0) {
              LetterDesignator = "N";
            } else if (0 > lat && lat >= -8) {
              LetterDesignator = "M";
            } else if (-8 > lat && lat >= -16) {
              LetterDesignator = "L";
            } else if (-16 > lat && lat >= -24) {
              LetterDesignator = "K";
            } else if (-24 > lat && lat >= -32) {
              LetterDesignator = "J";
            } else if (-32 > lat && lat >= -40) {
              LetterDesignator = "H";
            } else if (-40 > lat && lat >= -48) {
              LetterDesignator = "G";
            } else if (-48 > lat && lat >= -56) {
              LetterDesignator = "F";
            } else if (-56 > lat && lat >= -64) {
              LetterDesignator = "E";
            } else if (-64 > lat && lat >= -72) {
              LetterDesignator = "D";
            } else if (-72 > lat && lat >= -80) {
              LetterDesignator = "C";
            }
            return LetterDesignator;
          }
          function encode(utm2, accuracy) {
            var seasting = "00000" + utm2.easting, snorthing = "00000" + utm2.northing;
            return utm2.zoneNumber + utm2.zoneLetter + get100kID(utm2.easting, utm2.northing, utm2.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
          }
          function get100kID(easting, northing, zoneNumber) {
            var setParm = get100kSetForZone(zoneNumber);
            var setColumn = Math.floor(easting / 1e5);
            var setRow = Math.floor(northing / 1e5) % 20;
            return getLetter100kID(setColumn, setRow, setParm);
          }
          function get100kSetForZone(i) {
            var setParm = i % NUM_100K_SETS;
            if (setParm === 0) {
              setParm = NUM_100K_SETS;
            }
            return setParm;
          }
          function getLetter100kID(column, row, parm) {
            var index = parm - 1;
            var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
            var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
            var colInt = colOrigin + column - 1;
            var rowInt = rowOrigin + row;
            var rollover = false;
            if (colInt > Z) {
              colInt = colInt - Z + A - 1;
              rollover = true;
            }
            if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
              colInt++;
            }
            if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
              colInt++;
              if (colInt === I) {
                colInt++;
              }
            }
            if (colInt > Z) {
              colInt = colInt - Z + A - 1;
            }
            if (rowInt > V) {
              rowInt = rowInt - V + A - 1;
              rollover = true;
            } else {
              rollover = false;
            }
            if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
              rowInt++;
            }
            if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
              rowInt++;
              if (rowInt === I) {
                rowInt++;
              }
            }
            if (rowInt > V) {
              rowInt = rowInt - V + A - 1;
            }
            var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
            return twoLetter;
          }
          function decode(mgrsString) {
            if (mgrsString && mgrsString.length === 0) {
              throw "MGRSPoint coverting from nothing";
            }
            var length = mgrsString.length;
            var hunK = null;
            var sb = "";
            var testChar;
            var i = 0;
            while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
              if (i >= 2) {
                throw "MGRSPoint bad conversion from: " + mgrsString;
              }
              sb += testChar;
              i++;
            }
            var zoneNumber = parseInt(sb, 10);
            if (i === 0 || i + 3 > length) {
              throw "MGRSPoint bad conversion from: " + mgrsString;
            }
            var zoneLetter = mgrsString.charAt(i++);
            if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
              throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
            }
            hunK = mgrsString.substring(i, i += 2);
            var set = get100kSetForZone(zoneNumber);
            var east100k = getEastingFromChar(hunK.charAt(0), set);
            var north100k = getNorthingFromChar(hunK.charAt(1), set);
            while (north100k < getMinNorthing(zoneLetter)) {
              north100k += 2e6;
            }
            var remainder = length - i;
            if (remainder % 2 !== 0) {
              throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
            }
            var sep = remainder / 2;
            var sepEasting = 0;
            var sepNorthing = 0;
            var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
            if (sep > 0) {
              accuracyBonus = 1e5 / Math.pow(10, sep);
              sepEastingString = mgrsString.substring(i, i + sep);
              sepEasting = parseFloat(sepEastingString) * accuracyBonus;
              sepNorthingString = mgrsString.substring(i + sep);
              sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
            }
            easting = sepEasting + east100k;
            northing = sepNorthing + north100k;
            return {
              easting,
              northing,
              zoneLetter,
              zoneNumber,
              accuracy: accuracyBonus
            };
          }
          function getEastingFromChar(e, set) {
            var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
            var eastingValue = 1e5;
            var rewindMarker = false;
            while (curCol !== e.charCodeAt(0)) {
              curCol++;
              if (curCol === I) {
                curCol++;
              }
              if (curCol === O) {
                curCol++;
              }
              if (curCol > Z) {
                if (rewindMarker) {
                  throw "Bad character: " + e;
                }
                curCol = A;
                rewindMarker = true;
              }
              eastingValue += 1e5;
            }
            return eastingValue;
          }
          function getNorthingFromChar(n, set) {
            if (n > "V") {
              throw "MGRSPoint given invalid Northing " + n;
            }
            var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
            var northingValue = 0;
            var rewindMarker = false;
            while (curRow !== n.charCodeAt(0)) {
              curRow++;
              if (curRow === I) {
                curRow++;
              }
              if (curRow === O) {
                curRow++;
              }
              if (curRow > V) {
                if (rewindMarker) {
                  throw "Bad character: " + n;
                }
                curRow = A;
                rewindMarker = true;
              }
              northingValue += 1e5;
            }
            return northingValue;
          }
          function getMinNorthing(zoneLetter) {
            var northing;
            switch (zoneLetter) {
              case "C":
                northing = 11e5;
                break;
              case "D":
                northing = 2e6;
                break;
              case "E":
                northing = 28e5;
                break;
              case "F":
                northing = 37e5;
                break;
              case "G":
                northing = 46e5;
                break;
              case "H":
                northing = 55e5;
                break;
              case "J":
                northing = 64e5;
                break;
              case "K":
                northing = 73e5;
                break;
              case "L":
                northing = 82e5;
                break;
              case "M":
                northing = 91e5;
                break;
              case "N":
                northing = 0;
                break;
              case "P":
                northing = 8e5;
                break;
              case "Q":
                northing = 17e5;
                break;
              case "R":
                northing = 26e5;
                break;
              case "S":
                northing = 35e5;
                break;
              case "T":
                northing = 44e5;
                break;
              case "U":
                northing = 53e5;
                break;
              case "V":
                northing = 62e5;
                break;
              case "W":
                northing = 7e6;
                break;
              case "X":
                northing = 79e5;
                break;
              default:
                northing = -1;
            }
            if (northing >= 0) {
              return northing;
            } else {
              throw "Invalid zone letter: " + zoneLetter;
            }
          }
          function Point(x, y, z) {
            if (!(this instanceof Point)) {
              return new Point(x, y, z);
            }
            if (Array.isArray(x)) {
              this.x = x[0];
              this.y = x[1];
              this.z = x[2] || 0;
            } else if (typeof x === "object") {
              this.x = x.x;
              this.y = x.y;
              this.z = x.z || 0;
            } else if (typeof x === "string" && typeof y === "undefined") {
              var coords = x.split(",");
              this.x = parseFloat(coords[0], 10);
              this.y = parseFloat(coords[1], 10);
              this.z = parseFloat(coords[2], 10) || 0;
            } else {
              this.x = x;
              this.y = y;
              this.z = z || 0;
            }
            console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
          }
          Point.fromMGRS = function(mgrsStr) {
            return new Point(toPoint$1(mgrsStr));
          };
          Point.prototype.toMGRS = function(accuracy) {
            return forward$1([this.x, this.y], accuracy);
          };
          var C00 = 1;
          var C02 = 0.25;
          var C04 = 0.046875;
          var C06 = 0.01953125;
          var C08 = 0.01068115234375;
          var C22 = 0.75;
          var C44 = 0.46875;
          var C46 = 0.013020833333333334;
          var C48 = 0.007120768229166667;
          var C66 = 0.3645833333333333;
          var C68 = 0.005696614583333333;
          var C88 = 0.3076171875;
          var pj_enfn = function(es) {
            var en = [];
            en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
            en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
            var t = es * es;
            en[2] = t * (C44 - es * (C46 + es * C48));
            t *= es;
            en[3] = t * (C66 - es * C68);
            en[4] = t * es * C88;
            return en;
          };
          var pj_mlfn = function(phi, sphi, cphi, en) {
            cphi *= sphi;
            sphi *= sphi;
            return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
          };
          var MAX_ITER = 20;
          var pj_inv_mlfn = function(arg, es, en) {
            var k = 1 / (1 - es);
            var phi = arg;
            for (var i = MAX_ITER; i; --i) {
              var s = Math.sin(phi);
              var t = 1 - es * s * s;
              t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
              phi -= t;
              if (Math.abs(t) < EPSLN) {
                return phi;
              }
            }
            return phi;
          };
          function init$2() {
            this.x0 = this.x0 !== void 0 ? this.x0 : 0;
            this.y0 = this.y0 !== void 0 ? this.y0 : 0;
            this.long0 = this.long0 !== void 0 ? this.long0 : 0;
            this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
            if (this.es) {
              this.en = pj_enfn(this.es);
              this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
            }
          }
          function forward$2(p) {
            var lon = p.x;
            var lat = p.y;
            var delta_lon = adjust_lon(lon - this.long0);
            var con;
            var x, y;
            var sin_phi = Math.sin(lat);
            var cos_phi = Math.cos(lat);
            if (!this.es) {
              var b = cos_phi * Math.sin(delta_lon);
              if (Math.abs(Math.abs(b) - 1) < EPSLN) {
                return 93;
              } else {
                x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
                y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
                b = Math.abs(y);
                if (b >= 1) {
                  if (b - 1 > EPSLN) {
                    return 93;
                  } else {
                    y = 0;
                  }
                } else {
                  y = Math.acos(y);
                }
                if (lat < 0) {
                  y = -y;
                }
                y = this.a * this.k0 * (y - this.lat0) + this.y0;
              }
            } else {
              var al = cos_phi * delta_lon;
              var als = Math.pow(al, 2);
              var c = this.ep2 * Math.pow(cos_phi, 2);
              var cs = Math.pow(c, 2);
              var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
              var t = Math.pow(tq, 2);
              var ts = Math.pow(t, 2);
              con = 1 - this.es * Math.pow(sin_phi, 2);
              al = al / Math.sqrt(con);
              var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
              x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
              y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
            }
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$2(p) {
            var con, phi;
            var lat, lon;
            var x = (p.x - this.x0) * (1 / this.a);
            var y = (p.y - this.y0) * (1 / this.a);
            if (!this.es) {
              var f = Math.exp(x / this.k0);
              var g = 0.5 * (f - 1 / f);
              var temp = this.lat0 + y / this.k0;
              var h = Math.cos(temp);
              con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
              lat = Math.asin(con);
              if (y < 0) {
                lat = -lat;
              }
              if (g === 0 && h === 0) {
                lon = 0;
              } else {
                lon = adjust_lon(Math.atan2(g, h) + this.long0);
              }
            } else {
              con = this.ml0 + y / this.k0;
              phi = pj_inv_mlfn(con, this.es, this.en);
              if (Math.abs(phi) < HALF_PI) {
                var sin_phi = Math.sin(phi);
                var cos_phi = Math.cos(phi);
                var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
                var c = this.ep2 * Math.pow(cos_phi, 2);
                var cs = Math.pow(c, 2);
                var t = Math.pow(tan_phi, 2);
                var ts = Math.pow(t, 2);
                con = 1 - this.es * Math.pow(sin_phi, 2);
                var d = x * Math.sqrt(con) / this.k0;
                var ds = Math.pow(d, 2);
                con = con * tan_phi;
                lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
                lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
              } else {
                lat = HALF_PI * sign(y);
                lon = 0;
              }
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$3 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
          var tmerc = {
            init: init$2,
            forward: forward$2,
            inverse: inverse$2,
            names: names$3
          };
          var sinh = function(x) {
            var r = Math.exp(x);
            r = (r - 1 / r) / 2;
            return r;
          };
          var hypot = function(x, y) {
            x = Math.abs(x);
            y = Math.abs(y);
            var a = Math.max(x, y);
            var b = Math.min(x, y) / (a ? a : 1);
            return a * Math.sqrt(1 + Math.pow(b, 2));
          };
          var log1py = function(x) {
            var y = 1 + x;
            var z = y - 1;
            return z === 0 ? x : x * Math.log(y) / z;
          };
          var asinhy = function(x) {
            var y = Math.abs(x);
            y = log1py(y * (1 + y / (hypot(1, y) + 1)));
            return x < 0 ? -y : y;
          };
          var gatg = function(pp, B) {
            var cos_2B = 2 * Math.cos(2 * B);
            var i = pp.length - 1;
            var h1 = pp[i];
            var h2 = 0;
            var h;
            while (--i >= 0) {
              h = -h2 + cos_2B * h1 + pp[i];
              h2 = h1;
              h1 = h;
            }
            return B + h * Math.sin(2 * B);
          };
          var clens = function(pp, arg_r) {
            var r = 2 * Math.cos(arg_r);
            var i = pp.length - 1;
            var hr1 = pp[i];
            var hr2 = 0;
            var hr;
            while (--i >= 0) {
              hr = -hr2 + r * hr1 + pp[i];
              hr2 = hr1;
              hr1 = hr;
            }
            return Math.sin(arg_r) * hr;
          };
          var cosh = function(x) {
            var r = Math.exp(x);
            r = (r + 1 / r) / 2;
            return r;
          };
          var clens_cmplx = function(pp, arg_r, arg_i) {
            var sin_arg_r = Math.sin(arg_r);
            var cos_arg_r = Math.cos(arg_r);
            var sinh_arg_i = sinh(arg_i);
            var cosh_arg_i = cosh(arg_i);
            var r = 2 * cos_arg_r * cosh_arg_i;
            var i = -2 * sin_arg_r * sinh_arg_i;
            var j = pp.length - 1;
            var hr = pp[j];
            var hi1 = 0;
            var hr1 = 0;
            var hi = 0;
            var hr2;
            var hi2;
            while (--j >= 0) {
              hr2 = hr1;
              hi2 = hi1;
              hr1 = hr;
              hi1 = hi;
              hr = -hr2 + r * hr1 - i * hi1 + pp[j];
              hi = -hi2 + i * hr1 + r * hi1;
            }
            r = sin_arg_r * cosh_arg_i;
            i = cos_arg_r * sinh_arg_i;
            return [r * hr - i * hi, r * hi + i * hr];
          };
          function init$3() {
            if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
              throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
            }
            if (this.approx) {
              tmerc.init.apply(this);
              this.forward = tmerc.forward;
              this.inverse = tmerc.inverse;
            }
            this.x0 = this.x0 !== void 0 ? this.x0 : 0;
            this.y0 = this.y0 !== void 0 ? this.y0 : 0;
            this.long0 = this.long0 !== void 0 ? this.long0 : 0;
            this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
            this.cgb = [];
            this.cbg = [];
            this.utg = [];
            this.gtu = [];
            var f = this.es / (1 + Math.sqrt(1 - this.es));
            var n = f / (2 - f);
            var np = n;
            this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
            this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
            np = np * n;
            this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
            this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
            np = np * n;
            this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
            this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
            np = np * n;
            this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
            this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
            np = np * n;
            this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
            this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
            np = np * n;
            this.cgb[5] = np * (601676 / 22275);
            this.cbg[5] = np * (444337 / 155925);
            np = Math.pow(n, 2);
            this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
            this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
            this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
            this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
            this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
            np = np * n;
            this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
            this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
            np = np * n;
            this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
            this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
            np = np * n;
            this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
            this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
            np = np * n;
            this.utg[5] = np * (-20648693 / 638668800);
            this.gtu[5] = np * (212378941 / 319334400);
            var Z2 = gatg(this.cbg, this.lat0);
            this.Zb = -this.Qn * (Z2 + clens(this.gtu, 2 * Z2));
          }
          function forward$3(p) {
            var Ce = adjust_lon(p.x - this.long0);
            var Cn = p.y;
            Cn = gatg(this.cbg, Cn);
            var sin_Cn = Math.sin(Cn);
            var cos_Cn = Math.cos(Cn);
            var sin_Ce = Math.sin(Ce);
            var cos_Ce = Math.cos(Ce);
            Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
            Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
            Ce = asinhy(Math.tan(Ce));
            var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
            Cn = Cn + tmp[0];
            Ce = Ce + tmp[1];
            var x;
            var y;
            if (Math.abs(Ce) <= 2.623395162778) {
              x = this.a * (this.Qn * Ce) + this.x0;
              y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
            } else {
              x = Infinity;
              y = Infinity;
            }
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$3(p) {
            var Ce = (p.x - this.x0) * (1 / this.a);
            var Cn = (p.y - this.y0) * (1 / this.a);
            Cn = (Cn - this.Zb) / this.Qn;
            Ce = Ce / this.Qn;
            var lon;
            var lat;
            if (Math.abs(Ce) <= 2.623395162778) {
              var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
              Cn = Cn + tmp[0];
              Ce = Ce + tmp[1];
              Ce = Math.atan(sinh(Ce));
              var sin_Cn = Math.sin(Cn);
              var cos_Cn = Math.cos(Cn);
              var sin_Ce = Math.sin(Ce);
              var cos_Ce = Math.cos(Ce);
              Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
              Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
              lon = adjust_lon(Ce + this.long0);
              lat = gatg(this.cgb, Cn);
            } else {
              lon = Infinity;
              lat = Infinity;
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
          var etmerc = {
            init: init$3,
            forward: forward$3,
            inverse: inverse$3,
            names: names$4
          };
          var adjust_zone = function(zone, lon) {
            if (zone === void 0) {
              zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
              if (zone < 0) {
                return 0;
              } else if (zone > 60) {
                return 60;
              }
            }
            return zone;
          };
          var dependsOn = "etmerc";
          function init$4() {
            var zone = adjust_zone(this.zone, this.long0);
            if (zone === void 0) {
              throw new Error("unknown utm zone");
            }
            this.lat0 = 0;
            this.long0 = (6 * Math.abs(zone) - 183) * D2R;
            this.x0 = 5e5;
            this.y0 = this.utmSouth ? 1e7 : 0;
            this.k0 = 0.9996;
            etmerc.init.apply(this);
            this.forward = etmerc.forward;
            this.inverse = etmerc.inverse;
          }
          var names$5 = ["Universal Transverse Mercator System", "utm"];
          var utm = {
            init: init$4,
            names: names$5,
            dependsOn
          };
          var srat = function(esinp, exp) {
            return Math.pow((1 - esinp) / (1 + esinp), exp);
          };
          var MAX_ITER$1 = 20;
          function init$6() {
            var sphi = Math.sin(this.lat0);
            var cphi = Math.cos(this.lat0);
            cphi *= cphi;
            this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
            this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
            this.phic0 = Math.asin(sphi / this.C);
            this.ratexp = 0.5 * this.C * this.e;
            this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
          }
          function forward$5(p) {
            var lon = p.x;
            var lat = p.y;
            p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
            p.x = this.C * lon;
            return p;
          }
          function inverse$5(p) {
            var DEL_TOL = 1e-14;
            var lon = p.x / this.C;
            var lat = p.y;
            var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
            for (var i = MAX_ITER$1; i > 0; --i) {
              lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
              if (Math.abs(lat - p.y) < DEL_TOL) {
                break;
              }
              p.y = lat;
            }
            if (!i) {
              return null;
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$7 = ["gauss"];
          var gauss = {
            init: init$6,
            forward: forward$5,
            inverse: inverse$5,
            names: names$7
          };
          function init$5() {
            gauss.init.apply(this);
            if (!this.rc) {
              return;
            }
            this.sinc0 = Math.sin(this.phic0);
            this.cosc0 = Math.cos(this.phic0);
            this.R2 = 2 * this.rc;
            if (!this.title) {
              this.title = "Oblique Stereographic Alternative";
            }
          }
          function forward$4(p) {
            var sinc, cosc, cosl, k;
            p.x = adjust_lon(p.x - this.long0);
            gauss.forward.apply(this, [p]);
            sinc = Math.sin(p.y);
            cosc = Math.cos(p.y);
            cosl = Math.cos(p.x);
            k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
            p.x = k * cosc * Math.sin(p.x);
            p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
            p.x = this.a * p.x + this.x0;
            p.y = this.a * p.y + this.y0;
            return p;
          }
          function inverse$4(p) {
            var sinc, cosc, lon, lat, rho;
            p.x = (p.x - this.x0) / this.a;
            p.y = (p.y - this.y0) / this.a;
            p.x /= this.k0;
            p.y /= this.k0;
            if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
              var c = 2 * Math.atan2(rho, this.R2);
              sinc = Math.sin(c);
              cosc = Math.cos(c);
              lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
              lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
            } else {
              lat = this.phic0;
              lon = 0;
            }
            p.x = lon;
            p.y = lat;
            gauss.inverse.apply(this, [p]);
            p.x = adjust_lon(p.x + this.long0);
            return p;
          }
          var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
          var sterea = {
            init: init$5,
            forward: forward$4,
            inverse: inverse$4,
            names: names$6
          };
          function ssfn_(phit, sinphi, eccen) {
            sinphi *= eccen;
            return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
          }
          function init$7() {
            this.coslat0 = Math.cos(this.lat0);
            this.sinlat0 = Math.sin(this.lat0);
            if (this.sphere) {
              if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
                this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
              }
            } else {
              if (Math.abs(this.coslat0) <= EPSLN) {
                if (this.lat0 > 0) {
                  this.con = 1;
                } else {
                  this.con = -1;
                }
              }
              this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
              if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
                this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
              }
              this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
              this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
              this.cosX0 = Math.cos(this.X0);
              this.sinX0 = Math.sin(this.X0);
            }
          }
          function forward$6(p) {
            var lon = p.x;
            var lat = p.y;
            var sinlat = Math.sin(lat);
            var coslat = Math.cos(lat);
            var A2, X, sinX, cosX, ts, rh;
            var dlon = adjust_lon(lon - this.long0);
            if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
              p.x = NaN;
              p.y = NaN;
              return p;
            }
            if (this.sphere) {
              A2 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
              p.x = this.a * A2 * coslat * Math.sin(dlon) + this.x0;
              p.y = this.a * A2 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
              return p;
            } else {
              X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
              cosX = Math.cos(X);
              sinX = Math.sin(X);
              if (Math.abs(this.coslat0) <= EPSLN) {
                ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
                rh = 2 * this.a * this.k0 * ts / this.cons;
                p.x = this.x0 + rh * Math.sin(lon - this.long0);
                p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
                return p;
              } else if (Math.abs(this.sinlat0) < EPSLN) {
                A2 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
                p.y = A2 * sinX;
              } else {
                A2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
                p.y = A2 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
              }
              p.x = A2 * cosX * Math.sin(dlon) + this.x0;
            }
            return p;
          }
          function inverse$6(p) {
            p.x -= this.x0;
            p.y -= this.y0;
            var lon, lat, ts, ce, Chi;
            var rh = Math.sqrt(p.x * p.x + p.y * p.y);
            if (this.sphere) {
              var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
              lon = this.long0;
              lat = this.lat0;
              if (rh <= EPSLN) {
                p.x = lon;
                p.y = lat;
                return p;
              }
              lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
              if (Math.abs(this.coslat0) < EPSLN) {
                if (this.lat0 > 0) {
                  lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
                } else {
                  lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
                }
              } else {
                lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
              }
              p.x = lon;
              p.y = lat;
              return p;
            } else {
              if (Math.abs(this.coslat0) <= EPSLN) {
                if (rh <= EPSLN) {
                  lat = this.lat0;
                  lon = this.long0;
                  p.x = lon;
                  p.y = lat;
                  return p;
                }
                p.x *= this.con;
                p.y *= this.con;
                ts = rh * this.cons / (2 * this.a * this.k0);
                lat = this.con * phi2z(this.e, ts);
                lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
              } else {
                ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
                lon = this.long0;
                if (rh <= EPSLN) {
                  Chi = this.X0;
                } else {
                  Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
                  lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
                }
                lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
              }
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
          var stere = {
            init: init$7,
            forward: forward$6,
            inverse: inverse$6,
            names: names$8,
            ssfn_
          };
          function init$8() {
            var phy0 = this.lat0;
            this.lambda0 = this.long0;
            var sinPhy0 = Math.sin(phy0);
            var semiMajorAxis = this.a;
            var invF = this.rf;
            var flattening = 1 / invF;
            var e2 = 2 * flattening - Math.pow(flattening, 2);
            var e = this.e = Math.sqrt(e2);
            this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
            this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
            this.b0 = Math.asin(sinPhy0 / this.alpha);
            var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
            var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
            var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
            this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
          }
          function forward$7(p) {
            var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
            var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
            var S = -this.alpha * (Sa1 + Sa2) + this.K;
            var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
            var I2 = this.alpha * (p.x - this.lambda0);
            var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
            var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
            p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
            p.x = this.R * rotI + this.x0;
            return p;
          }
          function inverse$7(p) {
            var Y = p.x - this.x0;
            var X = p.y - this.y0;
            var rotI = Y / this.R;
            var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
            var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
            var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
            var lambda = this.lambda0 + I2 / this.alpha;
            var S = 0;
            var phy = b;
            var prevPhy = -1e3;
            var iteration = 0;
            while (Math.abs(phy - prevPhy) > 1e-7) {
              if (++iteration > 20) {
                return;
              }
              S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
              prevPhy = phy;
              phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
            }
            p.x = lambda;
            p.y = phy;
            return p;
          }
          var names$9 = ["somerc"];
          var somerc = {
            init: init$8,
            forward: forward$7,
            inverse: inverse$7,
            names: names$9
          };
          var TOL = 1e-7;
          function isTypeA(P) {
            var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
            var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
            return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1;
          }
          function init$9() {
            var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
            this.no_off = isTypeA(this);
            this.no_rot = "no_rot" in this;
            var alp = false;
            if ("alpha" in this) {
              alp = true;
            }
            var gam = false;
            if ("rectified_grid_angle" in this) {
              gam = true;
            }
            if (alp) {
              alpha_c = this.alpha;
            }
            if (gam) {
              gamma = this.rectified_grid_angle * D2R;
            }
            if (alp || gam) {
              lamc = this.longc;
            } else {
              lam1 = this.long1;
              phi1 = this.lat1;
              lam2 = this.long2;
              phi2 = this.lat2;
              if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
                throw new Error();
              }
            }
            var one_es = 1 - this.es;
            com = Math.sqrt(one_es);
            if (Math.abs(this.lat0) > EPSLN) {
              sinph0 = Math.sin(this.lat0);
              cosph0 = Math.cos(this.lat0);
              con = 1 - this.es * sinph0 * sinph0;
              this.B = cosph0 * cosph0;
              this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
              this.A = this.B * this.k0 * com / con;
              D = this.B * com / (cosph0 * Math.sqrt(con));
              F = D * D - 1;
              if (F <= 0) {
                F = 0;
              } else {
                F = Math.sqrt(F);
                if (this.lat0 < 0) {
                  F = -F;
                }
              }
              this.E = F += D;
              this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
            } else {
              this.B = 1 / com;
              this.A = this.k0;
              this.E = D = F = 1;
            }
            if (alp || gam) {
              if (alp) {
                gamma0 = Math.asin(Math.sin(alpha_c) / D);
                if (!gam) {
                  gamma = alpha_c;
                }
              } else {
                gamma0 = gamma;
                alpha_c = Math.asin(D * Math.sin(gamma0));
              }
              this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
            } else {
              H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
              L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
              F = this.E / H;
              p = (L - H) / (L + H);
              J = this.E * this.E;
              J = (J - L * H) / (J + L * H);
              con = lam1 - lam2;
              if (con < -Math.pi) {
                lam2 -= TWO_PI;
              } else if (con > Math.pi) {
                lam2 += TWO_PI;
              }
              this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
              gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
              gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
            }
            this.singam = Math.sin(gamma0);
            this.cosgam = Math.cos(gamma0);
            this.sinrot = Math.sin(gamma);
            this.cosrot = Math.cos(gamma);
            this.rB = 1 / this.B;
            this.ArB = this.A * this.rB;
            this.BrA = 1 / this.ArB;
            if (this.no_off) {
              this.u_0 = 0;
            } else {
              this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
              if (this.lat0 < 0) {
                this.u_0 = -this.u_0;
              }
            }
            F = 0.5 * gamma0;
            this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
            this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
          }
          function forward$8(p) {
            var coords = {};
            var S, T, U, V2, W, temp, u, v;
            p.x = p.x - this.lam0;
            if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
              W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
              temp = 1 / W;
              S = 0.5 * (W - temp);
              T = 0.5 * (W + temp);
              V2 = Math.sin(this.B * p.x);
              U = (S * this.singam - V2 * this.cosgam) / T;
              if (Math.abs(Math.abs(U) - 1) < EPSLN) {
                throw new Error();
              }
              v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
              temp = Math.cos(this.B * p.x);
              if (Math.abs(temp) < TOL) {
                u = this.A * p.x;
              } else {
                u = this.ArB * Math.atan2(S * this.cosgam + V2 * this.singam, temp);
              }
            } else {
              v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
              u = this.ArB * p.y;
            }
            if (this.no_rot) {
              coords.x = u;
              coords.y = v;
            } else {
              u -= this.u_0;
              coords.x = v * this.cosrot + u * this.sinrot;
              coords.y = u * this.cosrot - v * this.sinrot;
            }
            coords.x = this.a * coords.x + this.x0;
            coords.y = this.a * coords.y + this.y0;
            return coords;
          }
          function inverse$8(p) {
            var u, v, Qp, Sp, Tp, Vp, Up;
            var coords = {};
            p.x = (p.x - this.x0) * (1 / this.a);
            p.y = (p.y - this.y0) * (1 / this.a);
            if (this.no_rot) {
              v = p.y;
              u = p.x;
            } else {
              v = p.x * this.cosrot - p.y * this.sinrot;
              u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
            }
            Qp = Math.exp(-this.BrA * v);
            Sp = 0.5 * (Qp - 1 / Qp);
            Tp = 0.5 * (Qp + 1 / Qp);
            Vp = Math.sin(this.BrA * u);
            Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
            if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
              coords.x = 0;
              coords.y = Up < 0 ? -HALF_PI : HALF_PI;
            } else {
              coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
              coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
              if (coords.y === Infinity) {
                throw new Error();
              }
              coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
            }
            coords.x += this.lam0;
            return coords;
          }
          var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
          var omerc = {
            init: init$9,
            forward: forward$8,
            inverse: inverse$8,
            names: names$10
          };
          function init$10() {
            if (!this.lat2) {
              this.lat2 = this.lat1;
            }
            if (!this.k0) {
              this.k0 = 1;
            }
            this.x0 = this.x0 || 0;
            this.y0 = this.y0 || 0;
            if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
              return;
            }
            var temp = this.b / this.a;
            this.e = Math.sqrt(1 - temp * temp);
            var sin1 = Math.sin(this.lat1);
            var cos1 = Math.cos(this.lat1);
            var ms1 = msfnz(this.e, sin1, cos1);
            var ts1 = tsfnz(this.e, this.lat1, sin1);
            var sin2 = Math.sin(this.lat2);
            var cos2 = Math.cos(this.lat2);
            var ms2 = msfnz(this.e, sin2, cos2);
            var ts2 = tsfnz(this.e, this.lat2, sin2);
            var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
            if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
              this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
            } else {
              this.ns = sin1;
            }
            if (isNaN(this.ns)) {
              this.ns = sin1;
            }
            this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
            this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
            if (!this.title) {
              this.title = "Lambert Conformal Conic";
            }
          }
          function forward$9(p) {
            var lon = p.x;
            var lat = p.y;
            if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
              lat = sign(lat) * (HALF_PI - 2 * EPSLN);
            }
            var con = Math.abs(Math.abs(lat) - HALF_PI);
            var ts, rh1;
            if (con > EPSLN) {
              ts = tsfnz(this.e, lat, Math.sin(lat));
              rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
            } else {
              con = lat * this.ns;
              if (con <= 0) {
                return null;
              }
              rh1 = 0;
            }
            var theta = this.ns * adjust_lon(lon - this.long0);
            p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
            p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
            return p;
          }
          function inverse$9(p) {
            var rh1, con, ts;
            var lat, lon;
            var x = (p.x - this.x0) / this.k0;
            var y = this.rh - (p.y - this.y0) / this.k0;
            if (this.ns > 0) {
              rh1 = Math.sqrt(x * x + y * y);
              con = 1;
            } else {
              rh1 = -Math.sqrt(x * x + y * y);
              con = -1;
            }
            var theta = 0;
            if (rh1 !== 0) {
              theta = Math.atan2(con * x, con * y);
            }
            if (rh1 !== 0 || this.ns > 0) {
              con = 1 / this.ns;
              ts = Math.pow(rh1 / (this.a * this.f0), con);
              lat = phi2z(this.e, ts);
              if (lat === -9999) {
                return null;
              }
            } else {
              lat = -HALF_PI;
            }
            lon = adjust_lon(theta / this.ns + this.long0);
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$11 = [
            "Lambert Tangential Conformal Conic Projection",
            "Lambert_Conformal_Conic",
            "Lambert_Conformal_Conic_1SP",
            "Lambert_Conformal_Conic_2SP",
            "lcc"
          ];
          var lcc = {
            init: init$10,
            forward: forward$9,
            inverse: inverse$9,
            names: names$11
          };
          function init$11() {
            this.a = 6377397155e-3;
            this.es = 0.006674372230614;
            this.e = Math.sqrt(this.es);
            if (!this.lat0) {
              this.lat0 = 0.863937979737193;
            }
            if (!this.long0) {
              this.long0 = 0.7417649320975901 - 0.308341501185665;
            }
            if (!this.k0) {
              this.k0 = 0.9999;
            }
            this.s45 = 0.785398163397448;
            this.s90 = 2 * this.s45;
            this.fi0 = this.lat0;
            this.e2 = this.es;
            this.e = Math.sqrt(this.e2);
            this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
            this.uq = 1.04216856380474;
            this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
            this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
            this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
            this.k1 = this.k0;
            this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
            this.s0 = 1.37008346281555;
            this.n = Math.sin(this.s0);
            this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
            this.ad = this.s90 - this.uq;
          }
          function forward$10(p) {
            var gfi, u, deltav, s, d, eps, ro;
            var lon = p.x;
            var lat = p.y;
            var delta_lon = adjust_lon(lon - this.long0);
            gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
            u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
            deltav = -delta_lon * this.alfa;
            s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
            d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
            eps = this.n * d;
            ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
            p.y = ro * Math.cos(eps) / 1;
            p.x = ro * Math.sin(eps) / 1;
            if (!this.czech) {
              p.y *= -1;
              p.x *= -1;
            }
            return p;
          }
          function inverse$10(p) {
            var u, deltav, s, d, eps, ro, fi1;
            var ok;
            var tmp = p.x;
            p.x = p.y;
            p.y = tmp;
            if (!this.czech) {
              p.y *= -1;
              p.x *= -1;
            }
            ro = Math.sqrt(p.x * p.x + p.y * p.y);
            eps = Math.atan2(p.y, p.x);
            d = eps / Math.sin(this.s0);
            s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
            u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
            deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
            p.x = this.long0 - deltav / this.alfa;
            fi1 = u;
            ok = 0;
            var iter = 0;
            do {
              p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
              if (Math.abs(fi1 - p.y) < 1e-10) {
                ok = 1;
              }
              fi1 = p.y;
              iter += 1;
            } while (ok === 0 && iter < 15);
            if (iter >= 15) {
              return null;
            }
            return p;
          }
          var names$12 = ["Krovak", "krovak"];
          var krovak = {
            init: init$11,
            forward: forward$10,
            inverse: inverse$10,
            names: names$12
          };
          var mlfn = function(e0, e1, e2, e3, phi) {
            return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
          };
          var e0fn = function(x) {
            return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
          };
          var e1fn = function(x) {
            return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
          };
          var e2fn = function(x) {
            return 0.05859375 * x * x * (1 + 0.75 * x);
          };
          var e3fn = function(x) {
            return x * x * x * (35 / 3072);
          };
          var gN = function(a, e, sinphi) {
            var temp = e * sinphi;
            return a / Math.sqrt(1 - temp * temp);
          };
          var adjust_lat = function(x) {
            return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
          };
          var imlfn = function(ml, e0, e1, e2, e3) {
            var phi;
            var dphi;
            phi = ml / e0;
            for (var i = 0; i < 15; i++) {
              dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
              phi += dphi;
              if (Math.abs(dphi) <= 1e-10) {
                return phi;
              }
            }
            return NaN;
          };
          function init$12() {
            if (!this.sphere) {
              this.e0 = e0fn(this.es);
              this.e1 = e1fn(this.es);
              this.e2 = e2fn(this.es);
              this.e3 = e3fn(this.es);
              this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
            }
          }
          function forward$11(p) {
            var x, y;
            var lam = p.x;
            var phi = p.y;
            lam = adjust_lon(lam - this.long0);
            if (this.sphere) {
              x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
              y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
            } else {
              var sinphi = Math.sin(phi);
              var cosphi = Math.cos(phi);
              var nl = gN(this.a, this.e, sinphi);
              var tl = Math.tan(phi) * Math.tan(phi);
              var al = lam * Math.cos(phi);
              var asq = al * al;
              var cl = this.es * cosphi * cosphi / (1 - this.es);
              var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
              x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
              y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
            }
            p.x = x + this.x0;
            p.y = y + this.y0;
            return p;
          }
          function inverse$11(p) {
            p.x -= this.x0;
            p.y -= this.y0;
            var x = p.x / this.a;
            var y = p.y / this.a;
            var phi, lam;
            if (this.sphere) {
              var dd = y + this.lat0;
              phi = Math.asin(Math.sin(dd) * Math.cos(x));
              lam = Math.atan2(Math.tan(x), Math.cos(dd));
            } else {
              var ml1 = this.ml0 / this.a + y;
              var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
              if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
                p.x = this.long0;
                p.y = HALF_PI;
                if (y < 0) {
                  p.y *= -1;
                }
                return p;
              }
              var nl1 = gN(this.a, this.e, Math.sin(phi1));
              var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
              var tl1 = Math.pow(Math.tan(phi1), 2);
              var dl = x * this.a / nl1;
              var dsq = dl * dl;
              phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
              lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
            }
            p.x = adjust_lon(lam + this.long0);
            p.y = adjust_lat(phi);
            return p;
          }
          var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
          var cass = {
            init: init$12,
            forward: forward$11,
            inverse: inverse$11,
            names: names$13
          };
          var qsfnz = function(eccent, sinphi) {
            var con;
            if (eccent > 1e-7) {
              con = eccent * sinphi;
              return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
            } else {
              return 2 * sinphi;
            }
          };
          var S_POLE = 1;
          var N_POLE = 2;
          var EQUIT = 3;
          var OBLIQ = 4;
          function init$13() {
            var t = Math.abs(this.lat0);
            if (Math.abs(t - HALF_PI) < EPSLN) {
              this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
            } else if (Math.abs(t) < EPSLN) {
              this.mode = this.EQUIT;
            } else {
              this.mode = this.OBLIQ;
            }
            if (this.es > 0) {
              var sinphi;
              this.qp = qsfnz(this.e, 1);
              this.mmf = 0.5 / (1 - this.es);
              this.apa = authset(this.es);
              switch (this.mode) {
                case this.N_POLE:
                  this.dd = 1;
                  break;
                case this.S_POLE:
                  this.dd = 1;
                  break;
                case this.EQUIT:
                  this.rq = Math.sqrt(0.5 * this.qp);
                  this.dd = 1 / this.rq;
                  this.xmf = 1;
                  this.ymf = 0.5 * this.qp;
                  break;
                case this.OBLIQ:
                  this.rq = Math.sqrt(0.5 * this.qp);
                  sinphi = Math.sin(this.lat0);
                  this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
                  this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
                  this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
                  this.ymf = (this.xmf = this.rq) / this.dd;
                  this.xmf *= this.dd;
                  break;
              }
            } else {
              if (this.mode === this.OBLIQ) {
                this.sinph0 = Math.sin(this.lat0);
                this.cosph0 = Math.cos(this.lat0);
              }
            }
          }
          function forward$12(p) {
            var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
            var lam = p.x;
            var phi = p.y;
            lam = adjust_lon(lam - this.long0);
            if (this.sphere) {
              sinphi = Math.sin(phi);
              cosphi = Math.cos(phi);
              coslam = Math.cos(lam);
              if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
                if (y <= EPSLN) {
                  return null;
                }
                y = Math.sqrt(2 / y);
                x = y * cosphi * Math.sin(lam);
                y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
              } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                if (this.mode === this.N_POLE) {
                  coslam = -coslam;
                }
                if (Math.abs(phi + this.lat0) < EPSLN) {
                  return null;
                }
                y = FORTPI - phi * 0.5;
                y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
                x = y * Math.sin(lam);
                y *= coslam;
              }
            } else {
              sinb = 0;
              cosb = 0;
              b = 0;
              coslam = Math.cos(lam);
              sinlam = Math.sin(lam);
              sinphi = Math.sin(phi);
              q = qsfnz(this.e, sinphi);
              if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                sinb = q / this.qp;
                cosb = Math.sqrt(1 - sinb * sinb);
              }
              switch (this.mode) {
                case this.OBLIQ:
                  b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
                  break;
                case this.EQUIT:
                  b = 1 + cosb * coslam;
                  break;
                case this.N_POLE:
                  b = HALF_PI + phi;
                  q = this.qp - q;
                  break;
                case this.S_POLE:
                  b = phi - HALF_PI;
                  q = this.qp + q;
                  break;
              }
              if (Math.abs(b) < EPSLN) {
                return null;
              }
              switch (this.mode) {
                case this.OBLIQ:
                case this.EQUIT:
                  b = Math.sqrt(2 / b);
                  if (this.mode === this.OBLIQ) {
                    y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
                  } else {
                    y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
                  }
                  x = this.xmf * b * cosb * sinlam;
                  break;
                case this.N_POLE:
                case this.S_POLE:
                  if (q >= 0) {
                    x = (b = Math.sqrt(q)) * sinlam;
                    y = coslam * (this.mode === this.S_POLE ? b : -b);
                  } else {
                    x = y = 0;
                  }
                  break;
              }
            }
            p.x = this.a * x + this.x0;
            p.y = this.a * y + this.y0;
            return p;
          }
          function inverse$12(p) {
            p.x -= this.x0;
            p.y -= this.y0;
            var x = p.x / this.a;
            var y = p.y / this.a;
            var lam, phi, cCe, sCe, q, rho, ab;
            if (this.sphere) {
              var cosz = 0, rh, sinz = 0;
              rh = Math.sqrt(x * x + y * y);
              phi = rh * 0.5;
              if (phi > 1) {
                return null;
              }
              phi = 2 * Math.asin(phi);
              if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                sinz = Math.sin(phi);
                cosz = Math.cos(phi);
              }
              switch (this.mode) {
                case this.EQUIT:
                  phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
                  x *= sinz;
                  y = cosz * rh;
                  break;
                case this.OBLIQ:
                  phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
                  x *= sinz * this.cosph0;
                  y = (cosz - Math.sin(phi) * this.sinph0) * rh;
                  break;
                case this.N_POLE:
                  y = -y;
                  phi = HALF_PI - phi;
                  break;
                case this.S_POLE:
                  phi -= HALF_PI;
                  break;
              }
              lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
            } else {
              ab = 0;
              if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                x /= this.dd;
                y *= this.dd;
                rho = Math.sqrt(x * x + y * y);
                if (rho < EPSLN) {
                  p.x = this.long0;
                  p.y = this.lat0;
                  return p;
                }
                sCe = 2 * Math.asin(0.5 * rho / this.rq);
                cCe = Math.cos(sCe);
                x *= sCe = Math.sin(sCe);
                if (this.mode === this.OBLIQ) {
                  ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
                  q = this.qp * ab;
                  y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
                } else {
                  ab = y * sCe / rho;
                  q = this.qp * ab;
                  y = rho * cCe;
                }
              } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                if (this.mode === this.N_POLE) {
                  y = -y;
                }
                q = x * x + y * y;
                if (!q) {
                  p.x = this.long0;
                  p.y = this.lat0;
                  return p;
                }
                ab = 1 - q / this.qp;
                if (this.mode === this.S_POLE) {
                  ab = -ab;
                }
              }
              lam = Math.atan2(x, y);
              phi = authlat(Math.asin(ab), this.apa);
            }
            p.x = adjust_lon(this.long0 + lam);
            p.y = phi;
            return p;
          }
          var P00 = 0.3333333333333333;
          var P01 = 0.17222222222222222;
          var P02 = 0.10257936507936508;
          var P10 = 0.06388888888888888;
          var P11 = 0.0664021164021164;
          var P20 = 0.016415012942191543;
          function authset(es) {
            var t;
            var APA = [];
            APA[0] = es * P00;
            t = es * es;
            APA[0] += t * P01;
            APA[1] = t * P10;
            t *= es;
            APA[0] += t * P02;
            APA[1] += t * P11;
            APA[2] = t * P20;
            return APA;
          }
          function authlat(beta, APA) {
            var t = beta + beta;
            return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
          }
          var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
          var laea = {
            init: init$13,
            forward: forward$12,
            inverse: inverse$12,
            names: names$14,
            S_POLE,
            N_POLE,
            EQUIT,
            OBLIQ
          };
          var asinz = function(x) {
            if (Math.abs(x) > 1) {
              x = x > 1 ? 1 : -1;
            }
            return Math.asin(x);
          };
          function init$14() {
            if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
              return;
            }
            this.temp = this.b / this.a;
            this.es = 1 - Math.pow(this.temp, 2);
            this.e3 = Math.sqrt(this.es);
            this.sin_po = Math.sin(this.lat1);
            this.cos_po = Math.cos(this.lat1);
            this.t1 = this.sin_po;
            this.con = this.sin_po;
            this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
            this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
            this.sin_po = Math.sin(this.lat2);
            this.cos_po = Math.cos(this.lat2);
            this.t2 = this.sin_po;
            this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
            this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
            this.sin_po = Math.sin(this.lat0);
            this.cos_po = Math.cos(this.lat0);
            this.t3 = this.sin_po;
            this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
            if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
              this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
            } else {
              this.ns0 = this.con;
            }
            this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
            this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
          }
          function forward$13(p) {
            var lon = p.x;
            var lat = p.y;
            this.sin_phi = Math.sin(lat);
            this.cos_phi = Math.cos(lat);
            var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
            var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
            var theta = this.ns0 * adjust_lon(lon - this.long0);
            var x = rh1 * Math.sin(theta) + this.x0;
            var y = this.rh - rh1 * Math.cos(theta) + this.y0;
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$13(p) {
            var rh1, qs, con, theta, lon, lat;
            p.x -= this.x0;
            p.y = this.rh - p.y + this.y0;
            if (this.ns0 >= 0) {
              rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
              con = 1;
            } else {
              rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
              con = -1;
            }
            theta = 0;
            if (rh1 !== 0) {
              theta = Math.atan2(con * p.x, con * p.y);
            }
            con = rh1 * this.ns0 / this.a;
            if (this.sphere) {
              lat = Math.asin((this.c - con * con) / (2 * this.ns0));
            } else {
              qs = (this.c - con * con) / this.ns0;
              lat = this.phi1z(this.e3, qs);
            }
            lon = adjust_lon(theta / this.ns0 + this.long0);
            p.x = lon;
            p.y = lat;
            return p;
          }
          function phi1z(eccent, qs) {
            var sinphi, cosphi, con, com, dphi;
            var phi = asinz(0.5 * qs);
            if (eccent < EPSLN) {
              return phi;
            }
            var eccnts = eccent * eccent;
            for (var i = 1; i <= 25; i++) {
              sinphi = Math.sin(phi);
              cosphi = Math.cos(phi);
              con = eccent * sinphi;
              com = 1 - con * con;
              dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
              phi = phi + dphi;
              if (Math.abs(dphi) <= 1e-7) {
                return phi;
              }
            }
            return null;
          }
          var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
          var aea = {
            init: init$14,
            forward: forward$13,
            inverse: inverse$13,
            names: names$15,
            phi1z
          };
          function init$15() {
            this.sin_p14 = Math.sin(this.lat0);
            this.cos_p14 = Math.cos(this.lat0);
            this.infinity_dist = 1e3 * this.a;
            this.rc = 1;
          }
          function forward$14(p) {
            var sinphi, cosphi;
            var dlon;
            var coslon;
            var ksp;
            var g;
            var x, y;
            var lon = p.x;
            var lat = p.y;
            dlon = adjust_lon(lon - this.long0);
            sinphi = Math.sin(lat);
            cosphi = Math.cos(lat);
            coslon = Math.cos(dlon);
            g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
            ksp = 1;
            if (g > 0 || Math.abs(g) <= EPSLN) {
              x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
              y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
            } else {
              x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
              y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
            }
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$14(p) {
            var rh;
            var sinc, cosc;
            var c;
            var lon, lat;
            p.x = (p.x - this.x0) / this.a;
            p.y = (p.y - this.y0) / this.a;
            p.x /= this.k0;
            p.y /= this.k0;
            if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
              c = Math.atan2(rh, this.rc);
              sinc = Math.sin(c);
              cosc = Math.cos(c);
              lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
              lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
              lon = adjust_lon(this.long0 + lon);
            } else {
              lat = this.phic0;
              lon = 0;
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$16 = ["gnom"];
          var gnom = {
            init: init$15,
            forward: forward$14,
            inverse: inverse$14,
            names: names$16
          };
          var iqsfnz = function(eccent, q) {
            var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
            if (Math.abs(Math.abs(q) - temp) < 1e-6) {
              if (q < 0) {
                return -1 * HALF_PI;
              } else {
                return HALF_PI;
              }
            }
            var phi = Math.asin(0.5 * q);
            var dphi;
            var sin_phi;
            var cos_phi;
            var con;
            for (var i = 0; i < 30; i++) {
              sin_phi = Math.sin(phi);
              cos_phi = Math.cos(phi);
              con = eccent * sin_phi;
              dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
              phi += dphi;
              if (Math.abs(dphi) <= 1e-10) {
                return phi;
              }
            }
            return NaN;
          };
          function init$16() {
            if (!this.sphere) {
              this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
            }
          }
          function forward$15(p) {
            var lon = p.x;
            var lat = p.y;
            var x, y;
            var dlon = adjust_lon(lon - this.long0);
            if (this.sphere) {
              x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
              y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
            } else {
              var qs = qsfnz(this.e, Math.sin(lat));
              x = this.x0 + this.a * this.k0 * dlon;
              y = this.y0 + this.a * qs * 0.5 / this.k0;
            }
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$15(p) {
            p.x -= this.x0;
            p.y -= this.y0;
            var lon, lat;
            if (this.sphere) {
              lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
              lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
            } else {
              lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
              lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$17 = ["cea"];
          var cea = {
            init: init$16,
            forward: forward$15,
            inverse: inverse$15,
            names: names$17
          };
          function init$17() {
            this.x0 = this.x0 || 0;
            this.y0 = this.y0 || 0;
            this.lat0 = this.lat0 || 0;
            this.long0 = this.long0 || 0;
            this.lat_ts = this.lat_ts || 0;
            this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
            this.rc = Math.cos(this.lat_ts);
          }
          function forward$16(p) {
            var lon = p.x;
            var lat = p.y;
            var dlon = adjust_lon(lon - this.long0);
            var dlat = adjust_lat(lat - this.lat0);
            p.x = this.x0 + this.a * dlon * this.rc;
            p.y = this.y0 + this.a * dlat;
            return p;
          }
          function inverse$16(p) {
            var x = p.x;
            var y = p.y;
            p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
            p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
            return p;
          }
          var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
          var eqc = {
            init: init$17,
            forward: forward$16,
            inverse: inverse$16,
            names: names$18
          };
          var MAX_ITER$2 = 20;
          function init$18() {
            this.temp = this.b / this.a;
            this.es = 1 - Math.pow(this.temp, 2);
            this.e = Math.sqrt(this.es);
            this.e0 = e0fn(this.es);
            this.e1 = e1fn(this.es);
            this.e2 = e2fn(this.es);
            this.e3 = e3fn(this.es);
            this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
          }
          function forward$17(p) {
            var lon = p.x;
            var lat = p.y;
            var x, y, el;
            var dlon = adjust_lon(lon - this.long0);
            el = dlon * Math.sin(lat);
            if (this.sphere) {
              if (Math.abs(lat) <= EPSLN) {
                x = this.a * dlon;
                y = -1 * this.a * this.lat0;
              } else {
                x = this.a * Math.sin(el) / Math.tan(lat);
                y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
              }
            } else {
              if (Math.abs(lat) <= EPSLN) {
                x = this.a * dlon;
                y = -1 * this.ml0;
              } else {
                var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
                x = nl * Math.sin(el);
                y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
              }
            }
            p.x = x + this.x0;
            p.y = y + this.y0;
            return p;
          }
          function inverse$17(p) {
            var lon, lat, x, y, i;
            var al, bl;
            var phi, dphi;
            x = p.x - this.x0;
            y = p.y - this.y0;
            if (this.sphere) {
              if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
                lon = adjust_lon(x / this.a + this.long0);
                lat = 0;
              } else {
                al = this.lat0 + y / this.a;
                bl = x * x / this.a / this.a + al * al;
                phi = al;
                var tanphi;
                for (i = MAX_ITER$2; i; --i) {
                  tanphi = Math.tan(phi);
                  dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
                  phi += dphi;
                  if (Math.abs(dphi) <= EPSLN) {
                    lat = phi;
                    break;
                  }
                }
                lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
              }
            } else {
              if (Math.abs(y + this.ml0) <= EPSLN) {
                lat = 0;
                lon = adjust_lon(this.long0 + x / this.a);
              } else {
                al = (this.ml0 + y) / this.a;
                bl = x * x / this.a / this.a + al * al;
                phi = al;
                var cl, mln, mlnp, ma;
                var con;
                for (i = MAX_ITER$2; i; --i) {
                  con = this.e * Math.sin(phi);
                  cl = Math.sqrt(1 - con * con) * Math.tan(phi);
                  mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
                  mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
                  ma = mln / this.a;
                  dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
                  phi -= dphi;
                  if (Math.abs(dphi) <= EPSLN) {
                    lat = phi;
                    break;
                  }
                }
                cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
                lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
              }
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$19 = ["Polyconic", "poly"];
          var poly = {
            init: init$18,
            forward: forward$17,
            inverse: inverse$17,
            names: names$19
          };
          function init$19() {
            this.A = [];
            this.A[1] = 0.6399175073;
            this.A[2] = -0.1358797613;
            this.A[3] = 0.063294409;
            this.A[4] = -0.02526853;
            this.A[5] = 0.0117879;
            this.A[6] = -55161e-7;
            this.A[7] = 26906e-7;
            this.A[8] = -1333e-6;
            this.A[9] = 67e-5;
            this.A[10] = -34e-5;
            this.B_re = [];
            this.B_im = [];
            this.B_re[1] = 0.7557853228;
            this.B_im[1] = 0;
            this.B_re[2] = 0.249204646;
            this.B_im[2] = 3371507e-9;
            this.B_re[3] = -1541739e-9;
            this.B_im[3] = 0.04105856;
            this.B_re[4] = -0.10162907;
            this.B_im[4] = 0.01727609;
            this.B_re[5] = -0.26623489;
            this.B_im[5] = -0.36249218;
            this.B_re[6] = -0.6870983;
            this.B_im[6] = -1.1651967;
            this.C_re = [];
            this.C_im = [];
            this.C_re[1] = 1.3231270439;
            this.C_im[1] = 0;
            this.C_re[2] = -0.577245789;
            this.C_im[2] = -7809598e-9;
            this.C_re[3] = 0.508307513;
            this.C_im[3] = -0.112208952;
            this.C_re[4] = -0.15094762;
            this.C_im[4] = 0.18200602;
            this.C_re[5] = 1.01418179;
            this.C_im[5] = 1.64497696;
            this.C_re[6] = 1.9660549;
            this.C_im[6] = 2.5127645;
            this.D = [];
            this.D[1] = 1.5627014243;
            this.D[2] = 0.5185406398;
            this.D[3] = -0.03333098;
            this.D[4] = -0.1052906;
            this.D[5] = -0.0368594;
            this.D[6] = 7317e-6;
            this.D[7] = 0.0122;
            this.D[8] = 394e-5;
            this.D[9] = -13e-4;
          }
          function forward$18(p) {
            var n;
            var lon = p.x;
            var lat = p.y;
            var delta_lat = lat - this.lat0;
            var delta_lon = lon - this.long0;
            var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
            var d_lambda = delta_lon;
            var d_phi_n = 1;
            var d_psi = 0;
            for (n = 1; n <= 10; n++) {
              d_phi_n = d_phi_n * d_phi;
              d_psi = d_psi + this.A[n] * d_phi_n;
            }
            var th_re = d_psi;
            var th_im = d_lambda;
            var th_n_re = 1;
            var th_n_im = 0;
            var th_n_re1;
            var th_n_im1;
            var z_re = 0;
            var z_im = 0;
            for (n = 1; n <= 6; n++) {
              th_n_re1 = th_n_re * th_re - th_n_im * th_im;
              th_n_im1 = th_n_im * th_re + th_n_re * th_im;
              th_n_re = th_n_re1;
              th_n_im = th_n_im1;
              z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
              z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
            }
            p.x = z_im * this.a + this.x0;
            p.y = z_re * this.a + this.y0;
            return p;
          }
          function inverse$18(p) {
            var n;
            var x = p.x;
            var y = p.y;
            var delta_x = x - this.x0;
            var delta_y = y - this.y0;
            var z_re = delta_y / this.a;
            var z_im = delta_x / this.a;
            var z_n_re = 1;
            var z_n_im = 0;
            var z_n_re1;
            var z_n_im1;
            var th_re = 0;
            var th_im = 0;
            for (n = 1; n <= 6; n++) {
              z_n_re1 = z_n_re * z_re - z_n_im * z_im;
              z_n_im1 = z_n_im * z_re + z_n_re * z_im;
              z_n_re = z_n_re1;
              z_n_im = z_n_im1;
              th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
              th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
            }
            for (var i = 0; i < this.iterations; i++) {
              var th_n_re = th_re;
              var th_n_im = th_im;
              var th_n_re1;
              var th_n_im1;
              var num_re = z_re;
              var num_im = z_im;
              for (n = 2; n <= 6; n++) {
                th_n_re1 = th_n_re * th_re - th_n_im * th_im;
                th_n_im1 = th_n_im * th_re + th_n_re * th_im;
                th_n_re = th_n_re1;
                th_n_im = th_n_im1;
                num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
                num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
              }
              th_n_re = 1;
              th_n_im = 0;
              var den_re = this.B_re[1];
              var den_im = this.B_im[1];
              for (n = 2; n <= 6; n++) {
                th_n_re1 = th_n_re * th_re - th_n_im * th_im;
                th_n_im1 = th_n_im * th_re + th_n_re * th_im;
                th_n_re = th_n_re1;
                th_n_im = th_n_im1;
                den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
                den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
              }
              var den2 = den_re * den_re + den_im * den_im;
              th_re = (num_re * den_re + num_im * den_im) / den2;
              th_im = (num_im * den_re - num_re * den_im) / den2;
            }
            var d_psi = th_re;
            var d_lambda = th_im;
            var d_psi_n = 1;
            var d_phi = 0;
            for (n = 1; n <= 9; n++) {
              d_psi_n = d_psi_n * d_psi;
              d_phi = d_phi + this.D[n] * d_psi_n;
            }
            var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
            var lon = this.long0 + d_lambda;
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
          var nzmg = {
            init: init$19,
            forward: forward$18,
            inverse: inverse$18,
            names: names$20
          };
          function init$20() {
          }
          function forward$19(p) {
            var lon = p.x;
            var lat = p.y;
            var dlon = adjust_lon(lon - this.long0);
            var x = this.x0 + this.a * dlon;
            var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$19(p) {
            p.x -= this.x0;
            p.y -= this.y0;
            var lon = adjust_lon(this.long0 + p.x / this.a);
            var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$21 = ["Miller_Cylindrical", "mill"];
          var mill = {
            init: init$20,
            forward: forward$19,
            inverse: inverse$19,
            names: names$21
          };
          var MAX_ITER$3 = 20;
          function init$21() {
            if (!this.sphere) {
              this.en = pj_enfn(this.es);
            } else {
              this.n = 1;
              this.m = 0;
              this.es = 0;
              this.C_y = Math.sqrt((this.m + 1) / this.n);
              this.C_x = this.C_y / (this.m + 1);
            }
          }
          function forward$20(p) {
            var x, y;
            var lon = p.x;
            var lat = p.y;
            lon = adjust_lon(lon - this.long0);
            if (this.sphere) {
              if (!this.m) {
                lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
              } else {
                var k = this.n * Math.sin(lat);
                for (var i = MAX_ITER$3; i; --i) {
                  var V2 = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
                  lat -= V2;
                  if (Math.abs(V2) < EPSLN) {
                    break;
                  }
                }
              }
              x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
              y = this.a * this.C_y * lat;
            } else {
              var s = Math.sin(lat);
              var c = Math.cos(lat);
              y = this.a * pj_mlfn(lat, s, c, this.en);
              x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
            }
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$20(p) {
            var lat, temp, lon, s;
            p.x -= this.x0;
            lon = p.x / this.a;
            p.y -= this.y0;
            lat = p.y / this.a;
            if (this.sphere) {
              lat /= this.C_y;
              lon = lon / (this.C_x * (this.m + Math.cos(lat)));
              if (this.m) {
                lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
              } else if (this.n !== 1) {
                lat = asinz(Math.sin(lat) / this.n);
              }
              lon = adjust_lon(lon + this.long0);
              lat = adjust_lat(lat);
            } else {
              lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
              s = Math.abs(lat);
              if (s < HALF_PI) {
                s = Math.sin(lat);
                temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
                lon = adjust_lon(temp);
              } else if (s - EPSLN < HALF_PI) {
                lon = this.long0;
              }
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$22 = ["Sinusoidal", "sinu"];
          var sinu = {
            init: init$21,
            forward: forward$20,
            inverse: inverse$20,
            names: names$22
          };
          function init$22() {
          }
          function forward$21(p) {
            var lon = p.x;
            var lat = p.y;
            var delta_lon = adjust_lon(lon - this.long0);
            var theta = lat;
            var con = Math.PI * Math.sin(lat);
            while (true) {
              var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
              theta += delta_theta;
              if (Math.abs(delta_theta) < EPSLN) {
                break;
              }
            }
            theta /= 2;
            if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
              delta_lon = 0;
            }
            var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
            var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$21(p) {
            var theta;
            var arg;
            p.x -= this.x0;
            p.y -= this.y0;
            arg = p.y / (1.4142135623731 * this.a);
            if (Math.abs(arg) > 0.999999999999) {
              arg = 0.999999999999;
            }
            theta = Math.asin(arg);
            var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
            if (lon < -Math.PI) {
              lon = -Math.PI;
            }
            if (lon > Math.PI) {
              lon = Math.PI;
            }
            arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
            if (Math.abs(arg) > 1) {
              arg = 1;
            }
            var lat = Math.asin(arg);
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$23 = ["Mollweide", "moll"];
          var moll = {
            init: init$22,
            forward: forward$21,
            inverse: inverse$21,
            names: names$23
          };
          function init$23() {
            if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
              return;
            }
            this.lat2 = this.lat2 || this.lat1;
            this.temp = this.b / this.a;
            this.es = 1 - Math.pow(this.temp, 2);
            this.e = Math.sqrt(this.es);
            this.e0 = e0fn(this.es);
            this.e1 = e1fn(this.es);
            this.e2 = e2fn(this.es);
            this.e3 = e3fn(this.es);
            this.sinphi = Math.sin(this.lat1);
            this.cosphi = Math.cos(this.lat1);
            this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
            this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
            if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
              this.ns = this.sinphi;
            } else {
              this.sinphi = Math.sin(this.lat2);
              this.cosphi = Math.cos(this.lat2);
              this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
              this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
              this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
            }
            this.g = this.ml1 + this.ms1 / this.ns;
            this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
            this.rh = this.a * (this.g - this.ml0);
          }
          function forward$22(p) {
            var lon = p.x;
            var lat = p.y;
            var rh1;
            if (this.sphere) {
              rh1 = this.a * (this.g - lat);
            } else {
              var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
              rh1 = this.a * (this.g - ml);
            }
            var theta = this.ns * adjust_lon(lon - this.long0);
            var x = this.x0 + rh1 * Math.sin(theta);
            var y = this.y0 + this.rh - rh1 * Math.cos(theta);
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$22(p) {
            p.x -= this.x0;
            p.y = this.rh - p.y + this.y0;
            var con, rh1, lat, lon;
            if (this.ns >= 0) {
              rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
              con = 1;
            } else {
              rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
              con = -1;
            }
            var theta = 0;
            if (rh1 !== 0) {
              theta = Math.atan2(con * p.x, con * p.y);
            }
            if (this.sphere) {
              lon = adjust_lon(this.long0 + theta / this.ns);
              lat = adjust_lat(this.g - rh1 / this.a);
              p.x = lon;
              p.y = lat;
              return p;
            } else {
              var ml = this.g - rh1 / this.a;
              lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
              lon = adjust_lon(this.long0 + theta / this.ns);
              p.x = lon;
              p.y = lat;
              return p;
            }
          }
          var names$24 = ["Equidistant_Conic", "eqdc"];
          var eqdc = {
            init: init$23,
            forward: forward$22,
            inverse: inverse$22,
            names: names$24
          };
          function init$24() {
            this.R = this.a;
          }
          function forward$23(p) {
            var lon = p.x;
            var lat = p.y;
            var dlon = adjust_lon(lon - this.long0);
            var x, y;
            if (Math.abs(lat) <= EPSLN) {
              x = this.x0 + this.R * dlon;
              y = this.y0;
            }
            var theta = asinz(2 * Math.abs(lat / Math.PI));
            if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
              x = this.x0;
              if (lat >= 0) {
                y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
              } else {
                y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
              }
            }
            var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
            var asq = al * al;
            var sinth = Math.sin(theta);
            var costh = Math.cos(theta);
            var g = costh / (sinth + costh - 1);
            var gsq = g * g;
            var m = g * (2 / sinth - 1);
            var msq = m * m;
            var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
            if (dlon < 0) {
              con = -con;
            }
            x = this.x0 + con;
            var q = asq + g;
            con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
            if (lat >= 0) {
              y = this.y0 + con;
            } else {
              y = this.y0 - con;
            }
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$23(p) {
            var lon, lat;
            var xx, yy, xys, c1, c2, c3;
            var a1;
            var m1;
            var con;
            var th1;
            var d;
            p.x -= this.x0;
            p.y -= this.y0;
            con = Math.PI * this.R;
            xx = p.x / con;
            yy = p.y / con;
            xys = xx * xx + yy * yy;
            c1 = -Math.abs(yy) * (1 + xys);
            c2 = c1 - 2 * yy * yy + xx * xx;
            c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
            d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
            a1 = (c1 - c2 * c2 / 3 / c3) / c3;
            m1 = 2 * Math.sqrt(-a1 / 3);
            con = 3 * d / a1 / m1;
            if (Math.abs(con) > 1) {
              if (con >= 0) {
                con = 1;
              } else {
                con = -1;
              }
            }
            th1 = Math.acos(con) / 3;
            if (p.y >= 0) {
              lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
            } else {
              lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
            }
            if (Math.abs(xx) < EPSLN) {
              lon = this.long0;
            } else {
              lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
          var vandg = {
            init: init$24,
            forward: forward$23,
            inverse: inverse$23,
            names: names$25
          };
          function init$25() {
            this.sin_p12 = Math.sin(this.lat0);
            this.cos_p12 = Math.cos(this.lat0);
          }
          function forward$24(p) {
            var lon = p.x;
            var lat = p.y;
            var sinphi = Math.sin(p.y);
            var cosphi = Math.cos(p.y);
            var dlon = adjust_lon(lon - this.long0);
            var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
            if (this.sphere) {
              if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
                p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
                p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
                return p;
              } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
                p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
                p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
                return p;
              } else {
                cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
                c = Math.acos(cos_c);
                kp = c ? c / Math.sin(c) : 1;
                p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
                p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
                return p;
              }
            } else {
              e0 = e0fn(this.es);
              e1 = e1fn(this.es);
              e2 = e2fn(this.es);
              e3 = e3fn(this.es);
              if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
                Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
                Ml = this.a * mlfn(e0, e1, e2, e3, lat);
                p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
                p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
                return p;
              } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
                Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
                Ml = this.a * mlfn(e0, e1, e2, e3, lat);
                p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
                p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
                return p;
              } else {
                tanphi = sinphi / cosphi;
                Nl1 = gN(this.a, this.e, this.sin_p12);
                Nl = gN(this.a, this.e, sinphi);
                psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
                Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
                if (Az === 0) {
                  s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
                } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
                  s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
                } else {
                  s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
                }
                G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
                H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
                GH = G * H;
                Hs = H * H;
                s2 = s * s;
                s3 = s2 * s;
                s4 = s3 * s;
                s5 = s4 * s;
                c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
                p.x = this.x0 + c * Math.sin(Az);
                p.y = this.y0 + c * Math.cos(Az);
                return p;
              }
            }
          }
          function inverse$24(p) {
            p.x -= this.x0;
            p.y -= this.y0;
            var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A2, B, D, Ee, F, sinpsi;
            if (this.sphere) {
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              if (rh > 2 * HALF_PI * this.a) {
                return;
              }
              z = rh / this.a;
              sinz = Math.sin(z);
              cosz = Math.cos(z);
              lon = this.long0;
              if (Math.abs(rh) <= EPSLN) {
                lat = this.lat0;
              } else {
                lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
                con = Math.abs(this.lat0) - HALF_PI;
                if (Math.abs(con) <= EPSLN) {
                  if (this.lat0 >= 0) {
                    lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
                  } else {
                    lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
                  }
                } else {
                  lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
                }
              }
              p.x = lon;
              p.y = lat;
              return p;
            } else {
              e0 = e0fn(this.es);
              e1 = e1fn(this.es);
              e2 = e2fn(this.es);
              e3 = e3fn(this.es);
              if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
                Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
                rh = Math.sqrt(p.x * p.x + p.y * p.y);
                M = Mlp - rh;
                lat = imlfn(M / this.a, e0, e1, e2, e3);
                lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
                p.x = lon;
                p.y = lat;
                return p;
              } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
                Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
                rh = Math.sqrt(p.x * p.x + p.y * p.y);
                M = rh - Mlp;
                lat = imlfn(M / this.a, e0, e1, e2, e3);
                lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
                p.x = lon;
                p.y = lat;
                return p;
              } else {
                rh = Math.sqrt(p.x * p.x + p.y * p.y);
                Az = Math.atan2(p.x, p.y);
                N1 = gN(this.a, this.e, this.sin_p12);
                cosAz = Math.cos(Az);
                tmp = this.e * this.cos_p12 * cosAz;
                A2 = -tmp * tmp / (1 - this.es);
                B = 3 * this.es * (1 - A2) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
                D = rh / N1;
                Ee = D - A2 * (1 + A2) * Math.pow(D, 3) / 6 - B * (1 + 3 * A2) * Math.pow(D, 4) / 24;
                F = 1 - A2 * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
                psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
                lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
                sinpsi = Math.sin(psi);
                lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
                p.x = lon;
                p.y = lat;
                return p;
              }
            }
          }
          var names$26 = ["Azimuthal_Equidistant", "aeqd"];
          var aeqd = {
            init: init$25,
            forward: forward$24,
            inverse: inverse$24,
            names: names$26
          };
          function init$26() {
            this.sin_p14 = Math.sin(this.lat0);
            this.cos_p14 = Math.cos(this.lat0);
          }
          function forward$25(p) {
            var sinphi, cosphi;
            var dlon;
            var coslon;
            var ksp;
            var g, x, y;
            var lon = p.x;
            var lat = p.y;
            dlon = adjust_lon(lon - this.long0);
            sinphi = Math.sin(lat);
            cosphi = Math.cos(lat);
            coslon = Math.cos(dlon);
            g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
            ksp = 1;
            if (g > 0 || Math.abs(g) <= EPSLN) {
              x = this.a * ksp * cosphi * Math.sin(dlon);
              y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
            }
            p.x = x;
            p.y = y;
            return p;
          }
          function inverse$25(p) {
            var rh;
            var z;
            var sinz, cosz;
            var con;
            var lon, lat;
            p.x -= this.x0;
            p.y -= this.y0;
            rh = Math.sqrt(p.x * p.x + p.y * p.y);
            z = asinz(rh / this.a);
            sinz = Math.sin(z);
            cosz = Math.cos(z);
            lon = this.long0;
            if (Math.abs(rh) <= EPSLN) {
              lat = this.lat0;
              p.x = lon;
              p.y = lat;
              return p;
            }
            lat = asinz(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
            con = Math.abs(this.lat0) - HALF_PI;
            if (Math.abs(con) <= EPSLN) {
              if (this.lat0 >= 0) {
                lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
              } else {
                lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
              }
              p.x = lon;
              p.y = lat;
              return p;
            }
            lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
            p.x = lon;
            p.y = lat;
            return p;
          }
          var names$27 = ["ortho"];
          var ortho = {
            init: init$26,
            forward: forward$25,
            inverse: inverse$25,
            names: names$27
          };
          var FACE_ENUM = {
            FRONT: 1,
            RIGHT: 2,
            BACK: 3,
            LEFT: 4,
            TOP: 5,
            BOTTOM: 6
          };
          var AREA_ENUM = {
            AREA_0: 1,
            AREA_1: 2,
            AREA_2: 3,
            AREA_3: 4
          };
          function init$27() {
            this.x0 = this.x0 || 0;
            this.y0 = this.y0 || 0;
            this.lat0 = this.lat0 || 0;
            this.long0 = this.long0 || 0;
            this.lat_ts = this.lat_ts || 0;
            this.title = this.title || "Quadrilateralized Spherical Cube";
            if (this.lat0 >= HALF_PI - FORTPI / 2) {
              this.face = FACE_ENUM.TOP;
            } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
              this.face = FACE_ENUM.BOTTOM;
            } else if (Math.abs(this.long0) <= FORTPI) {
              this.face = FACE_ENUM.FRONT;
            } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
              this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
            } else {
              this.face = FACE_ENUM.BACK;
            }
            if (this.es !== 0) {
              this.one_minus_f = 1 - (this.a - this.b) / this.a;
              this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
            }
          }
          function forward$26(p) {
            var xy = { x: 0, y: 0 };
            var lat, lon;
            var theta, phi;
            var t, mu;
            var area = { value: 0 };
            p.x -= this.long0;
            if (this.es !== 0) {
              lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
            } else {
              lat = p.y;
            }
            lon = p.x;
            if (this.face === FACE_ENUM.TOP) {
              phi = HALF_PI - lat;
              if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
                area.value = AREA_ENUM.AREA_0;
                theta = lon - HALF_PI;
              } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
                area.value = AREA_ENUM.AREA_1;
                theta = lon > 0 ? lon - SPI : lon + SPI;
              } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
                area.value = AREA_ENUM.AREA_2;
                theta = lon + HALF_PI;
              } else {
                area.value = AREA_ENUM.AREA_3;
                theta = lon;
              }
            } else if (this.face === FACE_ENUM.BOTTOM) {
              phi = HALF_PI + lat;
              if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
                area.value = AREA_ENUM.AREA_0;
                theta = -lon + HALF_PI;
              } else if (lon < FORTPI && lon >= -FORTPI) {
                area.value = AREA_ENUM.AREA_1;
                theta = -lon;
              } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
                area.value = AREA_ENUM.AREA_2;
                theta = -lon - HALF_PI;
              } else {
                area.value = AREA_ENUM.AREA_3;
                theta = lon > 0 ? -lon + SPI : -lon - SPI;
              }
            } else {
              var q, r, s;
              var sinlat, coslat;
              var sinlon, coslon;
              if (this.face === FACE_ENUM.RIGHT) {
                lon = qsc_shift_lon_origin(lon, +HALF_PI);
              } else if (this.face === FACE_ENUM.BACK) {
                lon = qsc_shift_lon_origin(lon, +SPI);
              } else if (this.face === FACE_ENUM.LEFT) {
                lon = qsc_shift_lon_origin(lon, -HALF_PI);
              }
              sinlat = Math.sin(lat);
              coslat = Math.cos(lat);
              sinlon = Math.sin(lon);
              coslon = Math.cos(lon);
              q = coslat * coslon;
              r = coslat * sinlon;
              s = sinlat;
              if (this.face === FACE_ENUM.FRONT) {
                phi = Math.acos(q);
                theta = qsc_fwd_equat_face_theta(phi, s, r, area);
              } else if (this.face === FACE_ENUM.RIGHT) {
                phi = Math.acos(r);
                theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
              } else if (this.face === FACE_ENUM.BACK) {
                phi = Math.acos(-q);
                theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
              } else if (this.face === FACE_ENUM.LEFT) {
                phi = Math.acos(-r);
                theta = qsc_fwd_equat_face_theta(phi, s, q, area);
              } else {
                phi = theta = 0;
                area.value = AREA_ENUM.AREA_0;
              }
            }
            mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
            t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
            if (area.value === AREA_ENUM.AREA_1) {
              mu += HALF_PI;
            } else if (area.value === AREA_ENUM.AREA_2) {
              mu += SPI;
            } else if (area.value === AREA_ENUM.AREA_3) {
              mu += 1.5 * SPI;
            }
            xy.x = t * Math.cos(mu);
            xy.y = t * Math.sin(mu);
            xy.x = xy.x * this.a + this.x0;
            xy.y = xy.y * this.a + this.y0;
            p.x = xy.x;
            p.y = xy.y;
            return p;
          }
          function inverse$26(p) {
            var lp = { lam: 0, phi: 0 };
            var mu, nu, cosmu, tannu;
            var tantheta, theta, cosphi, phi;
            var t;
            var area = { value: 0 };
            p.x = (p.x - this.x0) / this.a;
            p.y = (p.y - this.y0) / this.a;
            nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
            mu = Math.atan2(p.y, p.x);
            if (p.x >= 0 && p.x >= Math.abs(p.y)) {
              area.value = AREA_ENUM.AREA_0;
            } else if (p.y >= 0 && p.y >= Math.abs(p.x)) {
              area.value = AREA_ENUM.AREA_1;
              mu -= HALF_PI;
            } else if (p.x < 0 && -p.x >= Math.abs(p.y)) {
              area.value = AREA_ENUM.AREA_2;
              mu = mu < 0 ? mu + SPI : mu - SPI;
            } else {
              area.value = AREA_ENUM.AREA_3;
              mu += HALF_PI;
            }
            t = SPI / 12 * Math.tan(mu);
            tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
            theta = Math.atan(tantheta);
            cosmu = Math.cos(mu);
            tannu = Math.tan(nu);
            cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
            if (cosphi < -1) {
              cosphi = -1;
            } else if (cosphi > 1) {
              cosphi = 1;
            }
            if (this.face === FACE_ENUM.TOP) {
              phi = Math.acos(cosphi);
              lp.phi = HALF_PI - phi;
              if (area.value === AREA_ENUM.AREA_0) {
                lp.lam = theta + HALF_PI;
              } else if (area.value === AREA_ENUM.AREA_1) {
                lp.lam = theta < 0 ? theta + SPI : theta - SPI;
              } else if (area.value === AREA_ENUM.AREA_2) {
                lp.lam = theta - HALF_PI;
              } else {
                lp.lam = theta;
              }
            } else if (this.face === FACE_ENUM.BOTTOM) {
              phi = Math.acos(cosphi);
              lp.phi = phi - HALF_PI;
              if (area.value === AREA_ENUM.AREA_0) {
                lp.lam = -theta + HALF_PI;
              } else if (area.value === AREA_ENUM.AREA_1) {
                lp.lam = -theta;
              } else if (area.value === AREA_ENUM.AREA_2) {
                lp.lam = -theta - HALF_PI;
              } else {
                lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
              }
            } else {
              var q, r, s;
              q = cosphi;
              t = q * q;
              if (t >= 1) {
                s = 0;
              } else {
                s = Math.sqrt(1 - t) * Math.sin(theta);
              }
              t += s * s;
              if (t >= 1) {
                r = 0;
              } else {
                r = Math.sqrt(1 - t);
              }
              if (area.value === AREA_ENUM.AREA_1) {
                t = r;
                r = -s;
                s = t;
              } else if (area.value === AREA_ENUM.AREA_2) {
                r = -r;
                s = -s;
              } else if (area.value === AREA_ENUM.AREA_3) {
                t = r;
                r = s;
                s = -t;
              }
              if (this.face === FACE_ENUM.RIGHT) {
                t = q;
                q = -r;
                r = t;
              } else if (this.face === FACE_ENUM.BACK) {
                q = -q;
                r = -r;
              } else if (this.face === FACE_ENUM.LEFT) {
                t = q;
                q = r;
                r = -t;
              }
              lp.phi = Math.acos(-s) - HALF_PI;
              lp.lam = Math.atan2(r, q);
              if (this.face === FACE_ENUM.RIGHT) {
                lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
              } else if (this.face === FACE_ENUM.BACK) {
                lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
              } else if (this.face === FACE_ENUM.LEFT) {
                lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
              }
            }
            if (this.es !== 0) {
              var invert_sign;
              var tanphi, xa;
              invert_sign = lp.phi < 0 ? 1 : 0;
              tanphi = Math.tan(lp.phi);
              xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
              lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
              if (invert_sign) {
                lp.phi = -lp.phi;
              }
            }
            lp.lam += this.long0;
            p.x = lp.lam;
            p.y = lp.phi;
            return p;
          }
          function qsc_fwd_equat_face_theta(phi, y, x, area) {
            var theta;
            if (phi < EPSLN) {
              area.value = AREA_ENUM.AREA_0;
              theta = 0;
            } else {
              theta = Math.atan2(y, x);
              if (Math.abs(theta) <= FORTPI) {
                area.value = AREA_ENUM.AREA_0;
              } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
                area.value = AREA_ENUM.AREA_1;
                theta -= HALF_PI;
              } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
                area.value = AREA_ENUM.AREA_2;
                theta = theta >= 0 ? theta - SPI : theta + SPI;
              } else {
                area.value = AREA_ENUM.AREA_3;
                theta += HALF_PI;
              }
            }
            return theta;
          }
          function qsc_shift_lon_origin(lon, offset) {
            var slon = lon + offset;
            if (slon < -SPI) {
              slon += TWO_PI;
            } else if (slon > +SPI) {
              slon -= TWO_PI;
            }
            return slon;
          }
          var names$28 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
          var qsc = {
            init: init$27,
            forward: forward$26,
            inverse: inverse$26,
            names: names$28
          };
          var COEFS_X = [
            [1, 22199e-21, -715515e-10, 31103e-10],
            [0.9986, -482243e-9, -24897e-9, -13309e-10],
            [0.9954, -83103e-8, -448605e-10, -986701e-12],
            [0.99, -135364e-8, -59661e-9, 36777e-10],
            [0.9822, -167442e-8, -449547e-11, -572411e-11],
            [0.973, -214868e-8, -903571e-10, 18736e-12],
            [0.96, -305085e-8, -900761e-10, 164917e-11],
            [0.9427, -382792e-8, -653386e-10, -26154e-10],
            [0.9216, -467746e-8, -10457e-8, 481243e-11],
            [0.8962, -536223e-8, -323831e-10, -543432e-11],
            [0.8679, -609363e-8, -113898e-9, 332484e-11],
            [0.835, -698325e-8, -640253e-10, 934959e-12],
            [0.7986, -755338e-8, -500009e-10, 935324e-12],
            [0.7597, -798324e-8, -35971e-9, -227626e-11],
            [0.7186, -851367e-8, -701149e-10, -86303e-10],
            [0.6732, -986209e-8, -199569e-9, 191974e-10],
            [0.6213, -0.010418, 883923e-10, 624051e-11],
            [0.5722, -906601e-8, 182e-6, 624051e-11],
            [0.5322, -677797e-8, 275608e-9, 624051e-11]
          ];
          var COEFS_Y = [
            [-520417e-23, 0.0124, 121431e-23, -845284e-16],
            [0.062, 0.0124, -126793e-14, 422642e-15],
            [0.124, 0.0124, 507171e-14, -160604e-14],
            [0.186, 0.0123999, -190189e-13, 600152e-14],
            [0.248, 0.0124002, 710039e-13, -224e-10],
            [0.31, 0.0123992, -264997e-12, 835986e-13],
            [0.372, 0.0124029, 988983e-12, -311994e-12],
            [0.434, 0.0123893, -369093e-11, -435621e-12],
            [0.4958, 0.0123198, -102252e-10, -345523e-12],
            [0.5571, 0.0121916, -154081e-10, -582288e-12],
            [0.6176, 0.0119938, -241424e-10, -525327e-12],
            [0.6769, 0.011713, -320223e-10, -516405e-12],
            [0.7346, 0.0113541, -397684e-10, -609052e-12],
            [0.7903, 0.0109107, -489042e-10, -104739e-11],
            [0.8435, 0.0103431, -64615e-9, -140374e-14],
            [0.8936, 969686e-8, -64636e-9, -8547e-9],
            [0.9394, 840947e-8, -192841e-9, -42106e-10],
            [0.9761, 616527e-8, -256e-6, -42106e-10],
            [1, 328947e-8, -319159e-9, -42106e-10]
          ];
          var FXC = 0.8487;
          var FYC = 1.3523;
          var C1 = R2D / 5;
          var RC1 = 1 / C1;
          var NODES = 18;
          var poly3_val = function(coefs, x) {
            return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
          };
          var poly3_der = function(coefs, x) {
            return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
          };
          function newton_rapshon(f_df, start2, max_err, iters) {
            var x = start2;
            for (; iters; --iters) {
              var upd = f_df(x);
              x -= upd;
              if (Math.abs(upd) < max_err) {
                break;
              }
            }
            return x;
          }
          function init$28() {
            this.x0 = this.x0 || 0;
            this.y0 = this.y0 || 0;
            this.long0 = this.long0 || 0;
            this.es = 0;
            this.title = this.title || "Robinson";
          }
          function forward$27(ll) {
            var lon = adjust_lon(ll.x - this.long0);
            var dphi = Math.abs(ll.y);
            var i = Math.floor(dphi * C1);
            if (i < 0) {
              i = 0;
            } else if (i >= NODES) {
              i = NODES - 1;
            }
            dphi = R2D * (dphi - RC1 * i);
            var xy = {
              x: poly3_val(COEFS_X[i], dphi) * lon,
              y: poly3_val(COEFS_Y[i], dphi)
            };
            if (ll.y < 0) {
              xy.y = -xy.y;
            }
            xy.x = xy.x * this.a * FXC + this.x0;
            xy.y = xy.y * this.a * FYC + this.y0;
            return xy;
          }
          function inverse$27(xy) {
            var ll = {
              x: (xy.x - this.x0) / (this.a * FXC),
              y: Math.abs(xy.y - this.y0) / (this.a * FYC)
            };
            if (ll.y >= 1) {
              ll.x /= COEFS_X[NODES][0];
              ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
            } else {
              var i = Math.floor(ll.y * NODES);
              if (i < 0) {
                i = 0;
              } else if (i >= NODES) {
                i = NODES - 1;
              }
              for (; ; ) {
                if (COEFS_Y[i][0] > ll.y) {
                  --i;
                } else if (COEFS_Y[i + 1][0] <= ll.y) {
                  ++i;
                } else {
                  break;
                }
              }
              var coefs = COEFS_Y[i];
              var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
              t = newton_rapshon(function(x) {
                return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
              }, t, EPSLN, 100);
              ll.x /= poly3_val(COEFS_X[i], t);
              ll.y = (5 * i + t) * D2R;
              if (xy.y < 0) {
                ll.y = -ll.y;
              }
            }
            ll.x = adjust_lon(ll.x + this.long0);
            return ll;
          }
          var names$29 = ["Robinson", "robin"];
          var robin = {
            init: init$28,
            forward: forward$27,
            inverse: inverse$27,
            names: names$29
          };
          function init$29() {
            this.name = "geocent";
          }
          function forward$28(p) {
            var point = geodeticToGeocentric(p, this.es, this.a);
            return point;
          }
          function inverse$28(p) {
            var point = geocentricToGeodetic(p, this.es, this.a, this.b);
            return point;
          }
          var names$30 = ["Geocentric", "geocentric", "geocent", "Geocent"];
          var geocent = {
            init: init$29,
            forward: forward$28,
            inverse: inverse$28,
            names: names$30
          };
          var mode = {
            N_POLE: 0,
            S_POLE: 1,
            EQUIT: 2,
            OBLIQ: 3
          };
          var params = {
            h: { def: 1e5, num: true },
            azi: { def: 0, num: true, degrees: true },
            tilt: { def: 0, num: true, degrees: true },
            long0: { def: 0, num: true },
            lat0: { def: 0, num: true }
          };
          function init$30() {
            Object.keys(params).forEach(function(p) {
              if (typeof this[p] === "undefined") {
                this[p] = params[p].def;
              } else if (params[p].num && isNaN(this[p])) {
                throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
              } else if (params[p].num) {
                this[p] = parseFloat(this[p]);
              }
              if (params[p].degrees) {
                this[p] = this[p] * D2R;
              }
            }.bind(this));
            if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
              this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
            } else if (Math.abs(this.lat0) < EPSLN) {
              this.mode = mode.EQUIT;
            } else {
              this.mode = mode.OBLIQ;
              this.sinph0 = Math.sin(this.lat0);
              this.cosph0 = Math.cos(this.lat0);
            }
            this.pn1 = this.h / this.a;
            if (this.pn1 <= 0 || this.pn1 > 1e10) {
              throw new Error("Invalid height");
            }
            this.p = 1 + this.pn1;
            this.rp = 1 / this.p;
            this.h1 = 1 / this.pn1;
            this.pfact = (this.p + 1) * this.h1;
            this.es = 0;
            var omega = this.tilt;
            var gamma = this.azi;
            this.cg = Math.cos(gamma);
            this.sg = Math.sin(gamma);
            this.cw = Math.cos(omega);
            this.sw = Math.sin(omega);
          }
          function forward$29(p) {
            p.x -= this.long0;
            var sinphi = Math.sin(p.y);
            var cosphi = Math.cos(p.y);
            var coslam = Math.cos(p.x);
            var x, y;
            switch (this.mode) {
              case mode.OBLIQ:
                y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
                break;
              case mode.EQUIT:
                y = cosphi * coslam;
                break;
              case mode.S_POLE:
                y = -sinphi;
                break;
              case mode.N_POLE:
                y = sinphi;
                break;
            }
            y = this.pn1 / (this.p - y);
            x = y * cosphi * Math.sin(p.x);
            switch (this.mode) {
              case mode.OBLIQ:
                y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
                break;
              case mode.EQUIT:
                y *= sinphi;
                break;
              case mode.N_POLE:
                y *= -(cosphi * coslam);
                break;
              case mode.S_POLE:
                y *= cosphi * coslam;
                break;
            }
            var yt, ba;
            yt = y * this.cg + x * this.sg;
            ba = 1 / (yt * this.sw * this.h1 + this.cw);
            x = (x * this.cg - y * this.sg) * this.cw * ba;
            y = yt * ba;
            p.x = x * this.a;
            p.y = y * this.a;
            return p;
          }
          function inverse$29(p) {
            p.x /= this.a;
            p.y /= this.a;
            var r = { x: p.x, y: p.y };
            var bm, bq, yt;
            yt = 1 / (this.pn1 - p.y * this.sw);
            bm = this.pn1 * p.x * yt;
            bq = this.pn1 * p.y * this.cw * yt;
            p.x = bm * this.cg + bq * this.sg;
            p.y = bq * this.cg - bm * this.sg;
            var rh = hypot(p.x, p.y);
            if (Math.abs(rh) < EPSLN) {
              r.x = 0;
              r.y = p.y;
            } else {
              var cosz, sinz;
              sinz = 1 - rh * rh * this.pfact;
              sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
              cosz = Math.sqrt(1 - sinz * sinz);
              switch (this.mode) {
                case mode.OBLIQ:
                  r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
                  p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
                  p.x *= sinz * this.cosph0;
                  break;
                case mode.EQUIT:
                  r.y = Math.asin(p.y * sinz / rh);
                  p.y = cosz * rh;
                  p.x *= sinz;
                  break;
                case mode.N_POLE:
                  r.y = Math.asin(cosz);
                  p.y = -p.y;
                  break;
                case mode.S_POLE:
                  r.y = -Math.asin(cosz);
                  break;
              }
              r.x = Math.atan2(p.x, p.y);
            }
            p.x = r.x + this.long0;
            p.y = r.y;
            return p;
          }
          var names$31 = ["Tilted_Perspective", "tpers"];
          var tpers = {
            init: init$30,
            forward: forward$29,
            inverse: inverse$29,
            names: names$31
          };
          var includedProjections = function(proj4) {
            proj4.Proj.projections.add(tmerc);
            proj4.Proj.projections.add(etmerc);
            proj4.Proj.projections.add(utm);
            proj4.Proj.projections.add(sterea);
            proj4.Proj.projections.add(stere);
            proj4.Proj.projections.add(somerc);
            proj4.Proj.projections.add(omerc);
            proj4.Proj.projections.add(lcc);
            proj4.Proj.projections.add(krovak);
            proj4.Proj.projections.add(cass);
            proj4.Proj.projections.add(laea);
            proj4.Proj.projections.add(aea);
            proj4.Proj.projections.add(gnom);
            proj4.Proj.projections.add(cea);
            proj4.Proj.projections.add(eqc);
            proj4.Proj.projections.add(poly);
            proj4.Proj.projections.add(nzmg);
            proj4.Proj.projections.add(mill);
            proj4.Proj.projections.add(sinu);
            proj4.Proj.projections.add(moll);
            proj4.Proj.projections.add(eqdc);
            proj4.Proj.projections.add(vandg);
            proj4.Proj.projections.add(aeqd);
            proj4.Proj.projections.add(ortho);
            proj4.Proj.projections.add(qsc);
            proj4.Proj.projections.add(robin);
            proj4.Proj.projections.add(geocent);
            proj4.Proj.projections.add(tpers);
          };
          proj4$1.defaultDatum = "WGS84";
          proj4$1.Proj = Projection;
          proj4$1.WGS84 = new proj4$1.Proj("WGS84");
          proj4$1.Point = Point;
          proj4$1.toPoint = toPoint;
          proj4$1.defs = defs;
          proj4$1.nadgrid = nadgrid;
          proj4$1.transform = transform;
          proj4$1.mgrs = mgrs;
          proj4$1.version = "2.7.4";
          includedProjections(proj4$1);
          return proj4$1;
        });
      }, {}], 18: [function(require2, module3, exports3) {
        var buffer = require2("buffer");
        var Buffer = buffer.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module3.exports = buffer;
        } else {
          copyProps(buffer, exports3);
          exports3.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer.prototype);
        copyProps(Buffer, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      }, { "buffer": 8 }], 19: [function(require2, module3, exports3) {
        "use strict";
        var Buffer = require2("safe-buffer").Buffer;
        var isEncoding = Buffer.isEncoding || function(encoding) {
          encoding = "" + encoding;
          switch (encoding && encoding.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function _normalizeEncoding(enc) {
          if (!enc)
            return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried)
                  return;
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }
        ;
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }
        exports3.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0)
            return "";
          var r;
          var i;
          if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === void 0)
              return "";
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i);
          return r || "";
        };
        StringDecoder.prototype.end = utf8End;
        StringDecoder.prototype.text = utf8Text;
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };
        function utf8CheckByte(byte) {
          if (byte <= 127)
            return 0;
          else if (byte >> 5 === 6)
            return 2;
          else if (byte >> 4 === 14)
            return 3;
          else if (byte >> 3 === 30)
            return 4;
          return byte >> 6 === 2 ? -1 : -2;
        }
        function utf8CheckIncomplete(self2, buf, i) {
          var j = buf.length - 1;
          if (j < i)
            return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2)
                nb = 0;
              else
                self2.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }
        function utf8CheckExtraBytes(self2, buf, p) {
          if ((buf[0] & 192) !== 128) {
            self2.lastNeed = 0;
            return "\uFFFD";
          }
          if (self2.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
              self2.lastNeed = 1;
              return "\uFFFD";
            }
            if (self2.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 192) !== 128) {
                self2.lastNeed = 2;
                return "\uFFFD";
              }
            }
          }
        }
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed;
          var r = utf8CheckExtraBytes(this, buf, p);
          if (r !== void 0)
            return r;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p, 0, buf.length);
          this.lastNeed -= buf.length;
        }
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed)
            return buf.toString("utf8", i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i, end);
        }
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + "\uFFFD";
          return r;
        }
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
              var c = r.charCodeAt(r.length - 1);
              if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
              }
            }
            return r;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i, buf.length - 1);
        }
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
          }
          return r;
        }
        function base64Text(buf, i) {
          var n = (buf.length - i) % 3;
          if (n === 0)
            return buf.toString("base64", i);
          this.lastNeed = 3 - n;
          this.lastTotal = 3;
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i, buf.length - n);
        }
        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r;
        }
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      }, { "safe-buffer": 18 }], 20: [function(require2, module3, exports3) {
        module3.exports = require2("./lib/encoding.js");
      }, { "./lib/encoding.js": 21 }], 21: [function(require2, module3, exports3) {
        (function(global2) {
          "use strict";
          if (typeof module3 !== "undefined" && module3.exports && !global2["encoding-indexes"]) {
            require2("./encoding-indexes.js");
          }
          function inRange(a, min, max) {
            return min <= a && a <= max;
          }
          function includes(array, item) {
            return array.indexOf(item) !== -1;
          }
          var floor = Math.floor;
          function ToDictionary(o) {
            if (o === void 0)
              return {};
            if (o === Object(o))
              return o;
            throw TypeError("Could not convert argument to dictionary");
          }
          function stringToCodePoints(string) {
            var s = String(string);
            var n = s.length;
            var i = 0;
            var u = [];
            while (i < n) {
              var c = s.charCodeAt(i);
              if (c < 55296 || c > 57343) {
                u.push(c);
              } else if (56320 <= c && c <= 57343) {
                u.push(65533);
              } else if (55296 <= c && c <= 56319) {
                if (i === n - 1) {
                  u.push(65533);
                } else {
                  var d = s.charCodeAt(i + 1);
                  if (56320 <= d && d <= 57343) {
                    var a = c & 1023;
                    var b = d & 1023;
                    u.push(65536 + (a << 10) + b);
                    i += 1;
                  } else {
                    u.push(65533);
                  }
                }
              }
              i += 1;
            }
            return u;
          }
          function codePointsToString(code_points) {
            var s = "";
            for (var i = 0; i < code_points.length; ++i) {
              var cp = code_points[i];
              if (cp <= 65535) {
                s += String.fromCharCode(cp);
              } else {
                cp -= 65536;
                s += String.fromCharCode(
                  (cp >> 10) + 55296,
                  (cp & 1023) + 56320
                );
              }
            }
            return s;
          }
          function isASCIIByte(a) {
            return 0 <= a && a <= 127;
          }
          var isASCIICodePoint = isASCIIByte;
          var end_of_stream = -1;
          function Stream(tokens) {
            this.tokens = [].slice.call(tokens);
            this.tokens.reverse();
          }
          Stream.prototype = {
            endOfStream: function() {
              return !this.tokens.length;
            },
            read: function() {
              if (!this.tokens.length)
                return end_of_stream;
              return this.tokens.pop();
            },
            prepend: function(token) {
              if (Array.isArray(token)) {
                var tokens = token;
                while (tokens.length)
                  this.tokens.push(tokens.pop());
              } else {
                this.tokens.push(token);
              }
            },
            push: function(token) {
              if (Array.isArray(token)) {
                var tokens = token;
                while (tokens.length)
                  this.tokens.unshift(tokens.shift());
              } else {
                this.tokens.unshift(token);
              }
            }
          };
          var finished = -1;
          function decoderError(fatal, opt_code_point) {
            if (fatal)
              throw TypeError("Decoder error");
            return opt_code_point || 65533;
          }
          function encoderError(code_point) {
            throw TypeError("The code point " + code_point + " could not be encoded.");
          }
          function Decoder() {
          }
          Decoder.prototype = {
            handler: function(stream, bite) {
            }
          };
          function Encoder() {
          }
          Encoder.prototype = {
            handler: function(stream, code_point) {
            }
          };
          function getEncoding(label) {
            label = String(label).trim().toLowerCase();
            if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
              return label_to_encoding[label];
            }
            return null;
          }
          var encodings = [
            {
              "encodings": [
                {
                  "labels": [
                    "unicode-1-1-utf-8",
                    "utf-8",
                    "utf8"
                  ],
                  "name": "UTF-8"
                }
              ],
              "heading": "The Encoding"
            },
            {
              "encodings": [
                {
                  "labels": [
                    "866",
                    "cp866",
                    "csibm866",
                    "ibm866"
                  ],
                  "name": "IBM866"
                },
                {
                  "labels": [
                    "csisolatin2",
                    "iso-8859-2",
                    "iso-ir-101",
                    "iso8859-2",
                    "iso88592",
                    "iso_8859-2",
                    "iso_8859-2:1987",
                    "l2",
                    "latin2"
                  ],
                  "name": "ISO-8859-2"
                },
                {
                  "labels": [
                    "csisolatin3",
                    "iso-8859-3",
                    "iso-ir-109",
                    "iso8859-3",
                    "iso88593",
                    "iso_8859-3",
                    "iso_8859-3:1988",
                    "l3",
                    "latin3"
                  ],
                  "name": "ISO-8859-3"
                },
                {
                  "labels": [
                    "csisolatin4",
                    "iso-8859-4",
                    "iso-ir-110",
                    "iso8859-4",
                    "iso88594",
                    "iso_8859-4",
                    "iso_8859-4:1988",
                    "l4",
                    "latin4"
                  ],
                  "name": "ISO-8859-4"
                },
                {
                  "labels": [
                    "csisolatincyrillic",
                    "cyrillic",
                    "iso-8859-5",
                    "iso-ir-144",
                    "iso8859-5",
                    "iso88595",
                    "iso_8859-5",
                    "iso_8859-5:1988"
                  ],
                  "name": "ISO-8859-5"
                },
                {
                  "labels": [
                    "arabic",
                    "asmo-708",
                    "csiso88596e",
                    "csiso88596i",
                    "csisolatinarabic",
                    "ecma-114",
                    "iso-8859-6",
                    "iso-8859-6-e",
                    "iso-8859-6-i",
                    "iso-ir-127",
                    "iso8859-6",
                    "iso88596",
                    "iso_8859-6",
                    "iso_8859-6:1987"
                  ],
                  "name": "ISO-8859-6"
                },
                {
                  "labels": [
                    "csisolatingreek",
                    "ecma-118",
                    "elot_928",
                    "greek",
                    "greek8",
                    "iso-8859-7",
                    "iso-ir-126",
                    "iso8859-7",
                    "iso88597",
                    "iso_8859-7",
                    "iso_8859-7:1987",
                    "sun_eu_greek"
                  ],
                  "name": "ISO-8859-7"
                },
                {
                  "labels": [
                    "csiso88598e",
                    "csisolatinhebrew",
                    "hebrew",
                    "iso-8859-8",
                    "iso-8859-8-e",
                    "iso-ir-138",
                    "iso8859-8",
                    "iso88598",
                    "iso_8859-8",
                    "iso_8859-8:1988",
                    "visual"
                  ],
                  "name": "ISO-8859-8"
                },
                {
                  "labels": [
                    "csiso88598i",
                    "iso-8859-8-i",
                    "logical"
                  ],
                  "name": "ISO-8859-8-I"
                },
                {
                  "labels": [
                    "csisolatin6",
                    "iso-8859-10",
                    "iso-ir-157",
                    "iso8859-10",
                    "iso885910",
                    "l6",
                    "latin6"
                  ],
                  "name": "ISO-8859-10"
                },
                {
                  "labels": [
                    "iso-8859-13",
                    "iso8859-13",
                    "iso885913"
                  ],
                  "name": "ISO-8859-13"
                },
                {
                  "labels": [
                    "iso-8859-14",
                    "iso8859-14",
                    "iso885914"
                  ],
                  "name": "ISO-8859-14"
                },
                {
                  "labels": [
                    "csisolatin9",
                    "iso-8859-15",
                    "iso8859-15",
                    "iso885915",
                    "iso_8859-15",
                    "l9"
                  ],
                  "name": "ISO-8859-15"
                },
                {
                  "labels": [
                    "iso-8859-16"
                  ],
                  "name": "ISO-8859-16"
                },
                {
                  "labels": [
                    "cskoi8r",
                    "koi",
                    "koi8",
                    "koi8-r",
                    "koi8_r"
                  ],
                  "name": "KOI8-R"
                },
                {
                  "labels": [
                    "koi8-ru",
                    "koi8-u"
                  ],
                  "name": "KOI8-U"
                },
                {
                  "labels": [
                    "csmacintosh",
                    "mac",
                    "macintosh",
                    "x-mac-roman"
                  ],
                  "name": "macintosh"
                },
                {
                  "labels": [
                    "dos-874",
                    "iso-8859-11",
                    "iso8859-11",
                    "iso885911",
                    "tis-620",
                    "windows-874"
                  ],
                  "name": "windows-874"
                },
                {
                  "labels": [
                    "cp1250",
                    "windows-1250",
                    "x-cp1250"
                  ],
                  "name": "windows-1250"
                },
                {
                  "labels": [
                    "cp1251",
                    "windows-1251",
                    "x-cp1251"
                  ],
                  "name": "windows-1251"
                },
                {
                  "labels": [
                    "ansi_x3.4-1968",
                    "ascii",
                    "cp1252",
                    "cp819",
                    "csisolatin1",
                    "ibm819",
                    "iso-8859-1",
                    "iso-ir-100",
                    "iso8859-1",
                    "iso88591",
                    "iso_8859-1",
                    "iso_8859-1:1987",
                    "l1",
                    "latin1",
                    "us-ascii",
                    "windows-1252",
                    "x-cp1252"
                  ],
                  "name": "windows-1252"
                },
                {
                  "labels": [
                    "cp1253",
                    "windows-1253",
                    "x-cp1253"
                  ],
                  "name": "windows-1253"
                },
                {
                  "labels": [
                    "cp1254",
                    "csisolatin5",
                    "iso-8859-9",
                    "iso-ir-148",
                    "iso8859-9",
                    "iso88599",
                    "iso_8859-9",
                    "iso_8859-9:1989",
                    "l5",
                    "latin5",
                    "windows-1254",
                    "x-cp1254"
                  ],
                  "name": "windows-1254"
                },
                {
                  "labels": [
                    "cp1255",
                    "windows-1255",
                    "x-cp1255"
                  ],
                  "name": "windows-1255"
                },
                {
                  "labels": [
                    "cp1256",
                    "windows-1256",
                    "x-cp1256"
                  ],
                  "name": "windows-1256"
                },
                {
                  "labels": [
                    "cp1257",
                    "windows-1257",
                    "x-cp1257"
                  ],
                  "name": "windows-1257"
                },
                {
                  "labels": [
                    "cp1258",
                    "windows-1258",
                    "x-cp1258"
                  ],
                  "name": "windows-1258"
                },
                {
                  "labels": [
                    "x-mac-cyrillic",
                    "x-mac-ukrainian"
                  ],
                  "name": "x-mac-cyrillic"
                }
              ],
              "heading": "Legacy single-byte encodings"
            },
            {
              "encodings": [
                {
                  "labels": [
                    "chinese",
                    "csgb2312",
                    "csiso58gb231280",
                    "gb2312",
                    "gb_2312",
                    "gb_2312-80",
                    "gbk",
                    "iso-ir-58",
                    "x-gbk"
                  ],
                  "name": "GBK"
                },
                {
                  "labels": [
                    "gb18030"
                  ],
                  "name": "gb18030"
                }
              ],
              "heading": "Legacy multi-byte Chinese (simplified) encodings"
            },
            {
              "encodings": [
                {
                  "labels": [
                    "big5",
                    "big5-hkscs",
                    "cn-big5",
                    "csbig5",
                    "x-x-big5"
                  ],
                  "name": "Big5"
                }
              ],
              "heading": "Legacy multi-byte Chinese (traditional) encodings"
            },
            {
              "encodings": [
                {
                  "labels": [
                    "cseucpkdfmtjapanese",
                    "euc-jp",
                    "x-euc-jp"
                  ],
                  "name": "EUC-JP"
                },
                {
                  "labels": [
                    "csiso2022jp",
                    "iso-2022-jp"
                  ],
                  "name": "ISO-2022-JP"
                },
                {
                  "labels": [
                    "csshiftjis",
                    "ms932",
                    "ms_kanji",
                    "shift-jis",
                    "shift_jis",
                    "sjis",
                    "windows-31j",
                    "x-sjis"
                  ],
                  "name": "Shift_JIS"
                }
              ],
              "heading": "Legacy multi-byte Japanese encodings"
            },
            {
              "encodings": [
                {
                  "labels": [
                    "cseuckr",
                    "csksc56011987",
                    "euc-kr",
                    "iso-ir-149",
                    "korean",
                    "ks_c_5601-1987",
                    "ks_c_5601-1989",
                    "ksc5601",
                    "ksc_5601",
                    "windows-949"
                  ],
                  "name": "EUC-KR"
                }
              ],
              "heading": "Legacy multi-byte Korean encodings"
            },
            {
              "encodings": [
                {
                  "labels": [
                    "csiso2022kr",
                    "hz-gb-2312",
                    "iso-2022-cn",
                    "iso-2022-cn-ext",
                    "iso-2022-kr"
                  ],
                  "name": "replacement"
                },
                {
                  "labels": [
                    "utf-16be"
                  ],
                  "name": "UTF-16BE"
                },
                {
                  "labels": [
                    "utf-16",
                    "utf-16le"
                  ],
                  "name": "UTF-16LE"
                },
                {
                  "labels": [
                    "x-user-defined"
                  ],
                  "name": "x-user-defined"
                }
              ],
              "heading": "Legacy miscellaneous encodings"
            }
          ];
          var label_to_encoding = {};
          encodings.forEach(function(category) {
            category.encodings.forEach(function(encoding) {
              encoding.labels.forEach(function(label) {
                label_to_encoding[label] = encoding;
              });
            });
          });
          var encoders = {};
          var decoders = {};
          function indexCodePointFor(pointer, index2) {
            if (!index2)
              return null;
            return index2[pointer] || null;
          }
          function indexPointerFor(code_point, index2) {
            var pointer = index2.indexOf(code_point);
            return pointer === -1 ? null : pointer;
          }
          function index(name) {
            if (!("encoding-indexes" in global2)) {
              throw Error("Indexes missing. Did you forget to include encoding-indexes.js first?");
            }
            return global2["encoding-indexes"][name];
          }
          function indexGB18030RangesCodePointFor(pointer) {
            if (pointer > 39419 && pointer < 189e3 || pointer > 1237575)
              return null;
            if (pointer === 7457)
              return 59335;
            var offset = 0;
            var code_point_offset = 0;
            var idx = index("gb18030-ranges");
            var i;
            for (i = 0; i < idx.length; ++i) {
              var entry = idx[i];
              if (entry[0] <= pointer) {
                offset = entry[0];
                code_point_offset = entry[1];
              } else {
                break;
              }
            }
            return code_point_offset + pointer - offset;
          }
          function indexGB18030RangesPointerFor(code_point) {
            if (code_point === 59335)
              return 7457;
            var offset = 0;
            var pointer_offset = 0;
            var idx = index("gb18030-ranges");
            var i;
            for (i = 0; i < idx.length; ++i) {
              var entry = idx[i];
              if (entry[1] <= code_point) {
                offset = entry[1];
                pointer_offset = entry[0];
              } else {
                break;
              }
            }
            return pointer_offset + code_point - offset;
          }
          function indexShiftJISPointerFor(code_point) {
            shift_jis_index = shift_jis_index || index("jis0208").map(function(code_point2, pointer) {
              return inRange(pointer, 8272, 8835) ? null : code_point2;
            });
            var index_ = shift_jis_index;
            return index_.indexOf(code_point);
          }
          var shift_jis_index;
          function indexBig5PointerFor(code_point) {
            big5_index_no_hkscs = big5_index_no_hkscs || index("big5").map(function(code_point2, pointer) {
              return pointer < (161 - 129) * 157 ? null : code_point2;
            });
            var index_ = big5_index_no_hkscs;
            if (code_point === 9552 || code_point === 9566 || code_point === 9569 || code_point === 9578 || code_point === 21313 || code_point === 21317) {
              return index_.lastIndexOf(code_point);
            }
            return indexPointerFor(code_point, index_);
          }
          var big5_index_no_hkscs;
          var DEFAULT_ENCODING = "utf-8";
          function TextDecoder2(label, options) {
            if (!(this instanceof TextDecoder2))
              throw TypeError("Called as a function. Did you forget 'new'?");
            label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
            options = ToDictionary(options);
            this._encoding = null;
            this._decoder = null;
            this._ignoreBOM = false;
            this._BOMseen = false;
            this._error_mode = "replacement";
            this._do_not_flush = false;
            var encoding = getEncoding(label);
            if (encoding === null || encoding.name === "replacement")
              throw RangeError("Unknown encoding: " + label);
            if (!decoders[encoding.name]) {
              throw Error("Decoder not present. Did you forget to include encoding-indexes.js first?");
            }
            var dec = this;
            dec._encoding = encoding;
            if (Boolean(options["fatal"]))
              dec._error_mode = "fatal";
            if (Boolean(options["ignoreBOM"]))
              dec._ignoreBOM = true;
            if (!Object.defineProperty) {
              this.encoding = dec._encoding.name.toLowerCase();
              this.fatal = dec._error_mode === "fatal";
              this.ignoreBOM = dec._ignoreBOM;
            }
            return dec;
          }
          if (Object.defineProperty) {
            Object.defineProperty(TextDecoder2.prototype, "encoding", {
              get: function() {
                return this._encoding.name.toLowerCase();
              }
            });
            Object.defineProperty(TextDecoder2.prototype, "fatal", {
              get: function() {
                return this._error_mode === "fatal";
              }
            });
            Object.defineProperty(TextDecoder2.prototype, "ignoreBOM", {
              get: function() {
                return this._ignoreBOM;
              }
            });
          }
          TextDecoder2.prototype.decode = function decode(input, options) {
            var bytes;
            if (typeof input === "object" && input instanceof ArrayBuffer) {
              bytes = new Uint8Array(input);
            } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
              bytes = new Uint8Array(
                input.buffer,
                input.byteOffset,
                input.byteLength
              );
            } else {
              bytes = new Uint8Array(0);
            }
            options = ToDictionary(options);
            if (!this._do_not_flush) {
              this._decoder = decoders[this._encoding.name]({
                fatal: this._error_mode === "fatal"
              });
              this._BOMseen = false;
            }
            this._do_not_flush = Boolean(options["stream"]);
            var input_stream = new Stream(bytes);
            var output = [];
            var result;
            while (true) {
              var token = input_stream.read();
              if (token === end_of_stream)
                break;
              result = this._decoder.handler(input_stream, token);
              if (result === finished)
                break;
              if (result !== null) {
                if (Array.isArray(result))
                  output.push.apply(output, result);
                else
                  output.push(result);
              }
            }
            if (!this._do_not_flush) {
              do {
                result = this._decoder.handler(input_stream, input_stream.read());
                if (result === finished)
                  break;
                if (result === null)
                  continue;
                if (Array.isArray(result))
                  output.push.apply(output, result);
                else
                  output.push(result);
              } while (!input_stream.endOfStream());
              this._decoder = null;
            }
            function serializeStream(stream) {
              if (includes(["UTF-8", "UTF-16LE", "UTF-16BE"], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {
                if (stream.length > 0 && stream[0] === 65279) {
                  this._BOMseen = true;
                  stream.shift();
                } else if (stream.length > 0) {
                  this._BOMseen = true;
                } else {
                }
              }
              return codePointsToString(stream);
            }
            return serializeStream.call(this, output);
          };
          function TextEncoder(label, options) {
            if (!(this instanceof TextEncoder))
              throw TypeError("Called as a function. Did you forget 'new'?");
            options = ToDictionary(options);
            this._encoding = null;
            this._encoder = null;
            this._do_not_flush = false;
            this._fatal = Boolean(options["fatal"]) ? "fatal" : "replacement";
            var enc = this;
            if (Boolean(options["NONSTANDARD_allowLegacyEncoding"])) {
              label = label !== void 0 ? String(label) : DEFAULT_ENCODING;
              var encoding = getEncoding(label);
              if (encoding === null || encoding.name === "replacement")
                throw RangeError("Unknown encoding: " + label);
              if (!encoders[encoding.name]) {
                throw Error("Encoder not present. Did you forget to include encoding-indexes.js first?");
              }
              enc._encoding = encoding;
            } else {
              enc._encoding = getEncoding("utf-8");
              if (label !== void 0 && "console" in global2) {
                console.warn("TextEncoder constructor called with encoding label, which is ignored.");
              }
            }
            if (!Object.defineProperty)
              this.encoding = enc._encoding.name.toLowerCase();
            return enc;
          }
          if (Object.defineProperty) {
            Object.defineProperty(TextEncoder.prototype, "encoding", {
              get: function() {
                return this._encoding.name.toLowerCase();
              }
            });
          }
          TextEncoder.prototype.encode = function encode(opt_string, options) {
            opt_string = opt_string === void 0 ? "" : String(opt_string);
            options = ToDictionary(options);
            if (!this._do_not_flush)
              this._encoder = encoders[this._encoding.name]({
                fatal: this._fatal === "fatal"
              });
            this._do_not_flush = Boolean(options["stream"]);
            var input = new Stream(stringToCodePoints(opt_string));
            var output = [];
            var result;
            while (true) {
              var token = input.read();
              if (token === end_of_stream)
                break;
              result = this._encoder.handler(input, token);
              if (result === finished)
                break;
              if (Array.isArray(result))
                output.push.apply(output, result);
              else
                output.push(result);
            }
            if (!this._do_not_flush) {
              while (true) {
                result = this._encoder.handler(input, input.read());
                if (result === finished)
                  break;
                if (Array.isArray(result))
                  output.push.apply(output, result);
                else
                  output.push(result);
              }
              this._encoder = null;
            }
            return new Uint8Array(output);
          };
          function UTF8Decoder(options) {
            var fatal = options.fatal;
            var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream && utf8_bytes_needed !== 0) {
                utf8_bytes_needed = 0;
                return decoderError(fatal);
              }
              if (bite === end_of_stream)
                return finished;
              if (utf8_bytes_needed === 0) {
                if (inRange(bite, 0, 127)) {
                  return bite;
                } else if (inRange(bite, 194, 223)) {
                  utf8_bytes_needed = 1;
                  utf8_code_point = bite & 31;
                } else if (inRange(bite, 224, 239)) {
                  if (bite === 224)
                    utf8_lower_boundary = 160;
                  if (bite === 237)
                    utf8_upper_boundary = 159;
                  utf8_bytes_needed = 2;
                  utf8_code_point = bite & 15;
                } else if (inRange(bite, 240, 244)) {
                  if (bite === 240)
                    utf8_lower_boundary = 144;
                  if (bite === 244)
                    utf8_upper_boundary = 143;
                  utf8_bytes_needed = 3;
                  utf8_code_point = bite & 7;
                } else {
                  return decoderError(fatal);
                }
                return null;
              }
              if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
                utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
                utf8_lower_boundary = 128;
                utf8_upper_boundary = 191;
                stream.prepend(bite);
                return decoderError(fatal);
              }
              utf8_lower_boundary = 128;
              utf8_upper_boundary = 191;
              utf8_code_point = utf8_code_point << 6 | bite & 63;
              utf8_bytes_seen += 1;
              if (utf8_bytes_seen !== utf8_bytes_needed)
                return null;
              var code_point = utf8_code_point;
              utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
              return code_point;
            };
          }
          function UTF8Encoder(options) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (isASCIICodePoint(code_point))
                return code_point;
              var count, offset;
              if (inRange(code_point, 128, 2047)) {
                count = 1;
                offset = 192;
              } else if (inRange(code_point, 2048, 65535)) {
                count = 2;
                offset = 224;
              } else if (inRange(code_point, 65536, 1114111)) {
                count = 3;
                offset = 240;
              }
              var bytes = [(code_point >> 6 * count) + offset];
              while (count > 0) {
                var temp = code_point >> 6 * (count - 1);
                bytes.push(128 | temp & 63);
                count -= 1;
              }
              return bytes;
            };
          }
          encoders["UTF-8"] = function(options) {
            return new UTF8Encoder(options);
          };
          decoders["UTF-8"] = function(options) {
            return new UTF8Decoder(options);
          };
          function SingleByteDecoder(index2, options) {
            var fatal = options.fatal;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream)
                return finished;
              if (isASCIIByte(bite))
                return bite;
              var code_point = index2[bite - 128];
              if (code_point === null)
                return decoderError(fatal);
              return code_point;
            };
          }
          function SingleByteEncoder(index2, options) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (isASCIICodePoint(code_point))
                return code_point;
              var pointer = indexPointerFor(code_point, index2);
              if (pointer === null)
                encoderError(code_point);
              return pointer + 128;
            };
          }
          (function() {
            if (!("encoding-indexes" in global2))
              return;
            encodings.forEach(function(category) {
              if (category.heading !== "Legacy single-byte encodings")
                return;
              category.encodings.forEach(function(encoding) {
                var name = encoding.name;
                var idx = index(name.toLowerCase());
                decoders[name] = function(options) {
                  return new SingleByteDecoder(idx, options);
                };
                encoders[name] = function(options) {
                  return new SingleByteEncoder(idx, options);
                };
              });
            });
          })();
          decoders["GBK"] = function(options) {
            return new GB18030Decoder(options);
          };
          encoders["GBK"] = function(options) {
            return new GB18030Encoder(options, true);
          };
          function GB18030Decoder(options) {
            var fatal = options.fatal;
            var gb18030_first = 0, gb18030_second = 0, gb18030_third = 0;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream && gb18030_first === 0 && gb18030_second === 0 && gb18030_third === 0) {
                return finished;
              }
              if (bite === end_of_stream && (gb18030_first !== 0 || gb18030_second !== 0 || gb18030_third !== 0)) {
                gb18030_first = 0;
                gb18030_second = 0;
                gb18030_third = 0;
                decoderError(fatal);
              }
              var code_point;
              if (gb18030_third !== 0) {
                code_point = null;
                if (inRange(bite, 48, 57)) {
                  code_point = indexGB18030RangesCodePointFor(
                    (((gb18030_first - 129) * 10 + gb18030_second - 48) * 126 + gb18030_third - 129) * 10 + bite - 48
                  );
                }
                var buffer = [gb18030_second, gb18030_third, bite];
                gb18030_first = 0;
                gb18030_second = 0;
                gb18030_third = 0;
                if (code_point === null) {
                  stream.prepend(buffer);
                  return decoderError(fatal);
                }
                return code_point;
              }
              if (gb18030_second !== 0) {
                if (inRange(bite, 129, 254)) {
                  gb18030_third = bite;
                  return null;
                }
                stream.prepend([gb18030_second, bite]);
                gb18030_first = 0;
                gb18030_second = 0;
                return decoderError(fatal);
              }
              if (gb18030_first !== 0) {
                if (inRange(bite, 48, 57)) {
                  gb18030_second = bite;
                  return null;
                }
                var lead = gb18030_first;
                var pointer = null;
                gb18030_first = 0;
                var offset = bite < 127 ? 64 : 65;
                if (inRange(bite, 64, 126) || inRange(bite, 128, 254))
                  pointer = (lead - 129) * 190 + (bite - offset);
                code_point = pointer === null ? null : indexCodePointFor(pointer, index("gb18030"));
                if (code_point === null && isASCIIByte(bite))
                  stream.prepend(bite);
                if (code_point === null)
                  return decoderError(fatal);
                return code_point;
              }
              if (isASCIIByte(bite))
                return bite;
              if (bite === 128)
                return 8364;
              if (inRange(bite, 129, 254)) {
                gb18030_first = bite;
                return null;
              }
              return decoderError(fatal);
            };
          }
          function GB18030Encoder(options, gbk_flag) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (isASCIICodePoint(code_point))
                return code_point;
              if (code_point === 58853)
                return encoderError(code_point);
              if (gbk_flag && code_point === 8364)
                return 128;
              var pointer = indexPointerFor(code_point, index("gb18030"));
              if (pointer !== null) {
                var lead = floor(pointer / 190) + 129;
                var trail = pointer % 190;
                var offset = trail < 63 ? 64 : 65;
                return [lead, trail + offset];
              }
              if (gbk_flag)
                return encoderError(code_point);
              pointer = indexGB18030RangesPointerFor(code_point);
              var byte1 = floor(pointer / 10 / 126 / 10);
              pointer = pointer - byte1 * 10 * 126 * 10;
              var byte2 = floor(pointer / 10 / 126);
              pointer = pointer - byte2 * 10 * 126;
              var byte3 = floor(pointer / 10);
              var byte4 = pointer - byte3 * 10;
              return [
                byte1 + 129,
                byte2 + 48,
                byte3 + 129,
                byte4 + 48
              ];
            };
          }
          encoders["gb18030"] = function(options) {
            return new GB18030Encoder(options);
          };
          decoders["gb18030"] = function(options) {
            return new GB18030Decoder(options);
          };
          function Big5Decoder(options) {
            var fatal = options.fatal;
            var Big5_lead = 0;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream && Big5_lead !== 0) {
                Big5_lead = 0;
                return decoderError(fatal);
              }
              if (bite === end_of_stream && Big5_lead === 0)
                return finished;
              if (Big5_lead !== 0) {
                var lead = Big5_lead;
                var pointer = null;
                Big5_lead = 0;
                var offset = bite < 127 ? 64 : 98;
                if (inRange(bite, 64, 126) || inRange(bite, 161, 254))
                  pointer = (lead - 129) * 157 + (bite - offset);
                switch (pointer) {
                  case 1133:
                    return [202, 772];
                  case 1135:
                    return [202, 780];
                  case 1164:
                    return [234, 772];
                  case 1166:
                    return [234, 780];
                }
                var code_point = pointer === null ? null : indexCodePointFor(pointer, index("big5"));
                if (code_point === null && isASCIIByte(bite))
                  stream.prepend(bite);
                if (code_point === null)
                  return decoderError(fatal);
                return code_point;
              }
              if (isASCIIByte(bite))
                return bite;
              if (inRange(bite, 129, 254)) {
                Big5_lead = bite;
                return null;
              }
              return decoderError(fatal);
            };
          }
          function Big5Encoder(options) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (isASCIICodePoint(code_point))
                return code_point;
              var pointer = indexBig5PointerFor(code_point);
              if (pointer === null)
                return encoderError(code_point);
              var lead = floor(pointer / 157) + 129;
              if (lead < 161)
                return encoderError(code_point);
              var trail = pointer % 157;
              var offset = trail < 63 ? 64 : 98;
              return [lead, trail + offset];
            };
          }
          encoders["Big5"] = function(options) {
            return new Big5Encoder(options);
          };
          decoders["Big5"] = function(options) {
            return new Big5Decoder(options);
          };
          function EUCJPDecoder(options) {
            var fatal = options.fatal;
            var eucjp_jis0212_flag = false, eucjp_lead = 0;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream && eucjp_lead !== 0) {
                eucjp_lead = 0;
                return decoderError(fatal);
              }
              if (bite === end_of_stream && eucjp_lead === 0)
                return finished;
              if (eucjp_lead === 142 && inRange(bite, 161, 223)) {
                eucjp_lead = 0;
                return 65377 - 161 + bite;
              }
              if (eucjp_lead === 143 && inRange(bite, 161, 254)) {
                eucjp_jis0212_flag = true;
                eucjp_lead = bite;
                return null;
              }
              if (eucjp_lead !== 0) {
                var lead = eucjp_lead;
                eucjp_lead = 0;
                var code_point = null;
                if (inRange(lead, 161, 254) && inRange(bite, 161, 254)) {
                  code_point = indexCodePointFor(
                    (lead - 161) * 94 + (bite - 161),
                    index(!eucjp_jis0212_flag ? "jis0208" : "jis0212")
                  );
                }
                eucjp_jis0212_flag = false;
                if (!inRange(bite, 161, 254))
                  stream.prepend(bite);
                if (code_point === null)
                  return decoderError(fatal);
                return code_point;
              }
              if (isASCIIByte(bite))
                return bite;
              if (bite === 142 || bite === 143 || inRange(bite, 161, 254)) {
                eucjp_lead = bite;
                return null;
              }
              return decoderError(fatal);
            };
          }
          function EUCJPEncoder(options) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (isASCIICodePoint(code_point))
                return code_point;
              if (code_point === 165)
                return 92;
              if (code_point === 8254)
                return 126;
              if (inRange(code_point, 65377, 65439))
                return [142, code_point - 65377 + 161];
              if (code_point === 8722)
                code_point = 65293;
              var pointer = indexPointerFor(code_point, index("jis0208"));
              if (pointer === null)
                return encoderError(code_point);
              var lead = floor(pointer / 94) + 161;
              var trail = pointer % 94 + 161;
              return [lead, trail];
            };
          }
          encoders["EUC-JP"] = function(options) {
            return new EUCJPEncoder(options);
          };
          decoders["EUC-JP"] = function(options) {
            return new EUCJPDecoder(options);
          };
          function ISO2022JPDecoder(options) {
            var fatal = options.fatal;
            var states = {
              ASCII: 0,
              Roman: 1,
              Katakana: 2,
              LeadByte: 3,
              TrailByte: 4,
              EscapeStart: 5,
              Escape: 6
            };
            var iso2022jp_decoder_state = states.ASCII, iso2022jp_decoder_output_state = states.ASCII, iso2022jp_lead = 0, iso2022jp_output_flag = false;
            this.handler = function(stream, bite) {
              switch (iso2022jp_decoder_state) {
                default:
                case states.ASCII:
                  if (bite === 27) {
                    iso2022jp_decoder_state = states.EscapeStart;
                    return null;
                  }
                  if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27) {
                    iso2022jp_output_flag = false;
                    return bite;
                  }
                  if (bite === end_of_stream) {
                    return finished;
                  }
                  iso2022jp_output_flag = false;
                  return decoderError(fatal);
                case states.Roman:
                  if (bite === 27) {
                    iso2022jp_decoder_state = states.EscapeStart;
                    return null;
                  }
                  if (bite === 92) {
                    iso2022jp_output_flag = false;
                    return 165;
                  }
                  if (bite === 126) {
                    iso2022jp_output_flag = false;
                    return 8254;
                  }
                  if (inRange(bite, 0, 127) && bite !== 14 && bite !== 15 && bite !== 27 && bite !== 92 && bite !== 126) {
                    iso2022jp_output_flag = false;
                    return bite;
                  }
                  if (bite === end_of_stream) {
                    return finished;
                  }
                  iso2022jp_output_flag = false;
                  return decoderError(fatal);
                case states.Katakana:
                  if (bite === 27) {
                    iso2022jp_decoder_state = states.EscapeStart;
                    return null;
                  }
                  if (inRange(bite, 33, 95)) {
                    iso2022jp_output_flag = false;
                    return 65377 - 33 + bite;
                  }
                  if (bite === end_of_stream) {
                    return finished;
                  }
                  iso2022jp_output_flag = false;
                  return decoderError(fatal);
                case states.LeadByte:
                  if (bite === 27) {
                    iso2022jp_decoder_state = states.EscapeStart;
                    return null;
                  }
                  if (inRange(bite, 33, 126)) {
                    iso2022jp_output_flag = false;
                    iso2022jp_lead = bite;
                    iso2022jp_decoder_state = states.TrailByte;
                    return null;
                  }
                  if (bite === end_of_stream) {
                    return finished;
                  }
                  iso2022jp_output_flag = false;
                  return decoderError(fatal);
                case states.TrailByte:
                  if (bite === 27) {
                    iso2022jp_decoder_state = states.EscapeStart;
                    return decoderError(fatal);
                  }
                  if (inRange(bite, 33, 126)) {
                    iso2022jp_decoder_state = states.LeadByte;
                    var pointer = (iso2022jp_lead - 33) * 94 + bite - 33;
                    var code_point = indexCodePointFor(pointer, index("jis0208"));
                    if (code_point === null)
                      return decoderError(fatal);
                    return code_point;
                  }
                  if (bite === end_of_stream) {
                    iso2022jp_decoder_state = states.LeadByte;
                    stream.prepend(bite);
                    return decoderError(fatal);
                  }
                  iso2022jp_decoder_state = states.LeadByte;
                  return decoderError(fatal);
                case states.EscapeStart:
                  if (bite === 36 || bite === 40) {
                    iso2022jp_lead = bite;
                    iso2022jp_decoder_state = states.Escape;
                    return null;
                  }
                  stream.prepend(bite);
                  iso2022jp_output_flag = false;
                  iso2022jp_decoder_state = iso2022jp_decoder_output_state;
                  return decoderError(fatal);
                case states.Escape:
                  var lead = iso2022jp_lead;
                  iso2022jp_lead = 0;
                  var state = null;
                  if (lead === 40 && bite === 66)
                    state = states.ASCII;
                  if (lead === 40 && bite === 74)
                    state = states.Roman;
                  if (lead === 40 && bite === 73)
                    state = states.Katakana;
                  if (lead === 36 && (bite === 64 || bite === 66))
                    state = states.LeadByte;
                  if (state !== null) {
                    iso2022jp_decoder_state = iso2022jp_decoder_state = state;
                    var output_flag = iso2022jp_output_flag;
                    iso2022jp_output_flag = true;
                    return !output_flag ? null : decoderError(fatal);
                  }
                  stream.prepend([lead, bite]);
                  iso2022jp_output_flag = false;
                  iso2022jp_decoder_state = iso2022jp_decoder_output_state;
                  return decoderError(fatal);
              }
            };
          }
          function ISO2022JPEncoder(options) {
            var fatal = options.fatal;
            var states = {
              ASCII: 0,
              Roman: 1,
              jis0208: 2
            };
            var iso2022jp_state = states.ASCII;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {
                stream.prepend(code_point);
                iso2022jp_state = states.ASCII;
                return [27, 40, 66];
              }
              if (code_point === end_of_stream && iso2022jp_state === states.ASCII)
                return finished;
              if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 14 || code_point === 15 || code_point === 27)) {
                return encoderError(65533);
              }
              if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point))
                return code_point;
              if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 92 && code_point !== 126 || (code_point == 165 || code_point == 8254))) {
                if (isASCIICodePoint(code_point))
                  return code_point;
                if (code_point === 165)
                  return 92;
                if (code_point === 8254)
                  return 126;
              }
              if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {
                stream.prepend(code_point);
                iso2022jp_state = states.ASCII;
                return [27, 40, 66];
              }
              if ((code_point === 165 || code_point === 8254) && iso2022jp_state !== states.Roman) {
                stream.prepend(code_point);
                iso2022jp_state = states.Roman;
                return [27, 40, 74];
              }
              if (code_point === 8722)
                code_point = 65293;
              var pointer = indexPointerFor(code_point, index("jis0208"));
              if (pointer === null)
                return encoderError(code_point);
              if (iso2022jp_state !== states.jis0208) {
                stream.prepend(code_point);
                iso2022jp_state = states.jis0208;
                return [27, 36, 66];
              }
              var lead = floor(pointer / 94) + 33;
              var trail = pointer % 94 + 33;
              return [lead, trail];
            };
          }
          encoders["ISO-2022-JP"] = function(options) {
            return new ISO2022JPEncoder(options);
          };
          decoders["ISO-2022-JP"] = function(options) {
            return new ISO2022JPDecoder(options);
          };
          function ShiftJISDecoder(options) {
            var fatal = options.fatal;
            var Shift_JIS_lead = 0;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream && Shift_JIS_lead !== 0) {
                Shift_JIS_lead = 0;
                return decoderError(fatal);
              }
              if (bite === end_of_stream && Shift_JIS_lead === 0)
                return finished;
              if (Shift_JIS_lead !== 0) {
                var lead = Shift_JIS_lead;
                var pointer = null;
                Shift_JIS_lead = 0;
                var offset = bite < 127 ? 64 : 65;
                var lead_offset = lead < 160 ? 129 : 193;
                if (inRange(bite, 64, 126) || inRange(bite, 128, 252))
                  pointer = (lead - lead_offset) * 188 + bite - offset;
                if (inRange(pointer, 8836, 10715))
                  return 57344 - 8836 + pointer;
                var code_point = pointer === null ? null : indexCodePointFor(pointer, index("jis0208"));
                if (code_point === null && isASCIIByte(bite))
                  stream.prepend(bite);
                if (code_point === null)
                  return decoderError(fatal);
                return code_point;
              }
              if (isASCIIByte(bite) || bite === 128)
                return bite;
              if (inRange(bite, 161, 223))
                return 65377 - 161 + bite;
              if (inRange(bite, 129, 159) || inRange(bite, 224, 252)) {
                Shift_JIS_lead = bite;
                return null;
              }
              return decoderError(fatal);
            };
          }
          function ShiftJISEncoder(options) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (isASCIICodePoint(code_point) || code_point === 128)
                return code_point;
              if (code_point === 165)
                return 92;
              if (code_point === 8254)
                return 126;
              if (inRange(code_point, 65377, 65439))
                return code_point - 65377 + 161;
              if (code_point === 8722)
                code_point = 65293;
              var pointer = indexShiftJISPointerFor(code_point);
              if (pointer === null)
                return encoderError(code_point);
              var lead = floor(pointer / 188);
              var lead_offset = lead < 31 ? 129 : 193;
              var trail = pointer % 188;
              var offset = trail < 63 ? 64 : 65;
              return [lead + lead_offset, trail + offset];
            };
          }
          encoders["Shift_JIS"] = function(options) {
            return new ShiftJISEncoder(options);
          };
          decoders["Shift_JIS"] = function(options) {
            return new ShiftJISDecoder(options);
          };
          function EUCKRDecoder(options) {
            var fatal = options.fatal;
            var euckr_lead = 0;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream && euckr_lead !== 0) {
                euckr_lead = 0;
                return decoderError(fatal);
              }
              if (bite === end_of_stream && euckr_lead === 0)
                return finished;
              if (euckr_lead !== 0) {
                var lead = euckr_lead;
                var pointer = null;
                euckr_lead = 0;
                if (inRange(bite, 65, 254))
                  pointer = (lead - 129) * 190 + (bite - 65);
                var code_point = pointer === null ? null : indexCodePointFor(pointer, index("euc-kr"));
                if (pointer === null && isASCIIByte(bite))
                  stream.prepend(bite);
                if (code_point === null)
                  return decoderError(fatal);
                return code_point;
              }
              if (isASCIIByte(bite))
                return bite;
              if (inRange(bite, 129, 254)) {
                euckr_lead = bite;
                return null;
              }
              return decoderError(fatal);
            };
          }
          function EUCKREncoder(options) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (isASCIICodePoint(code_point))
                return code_point;
              var pointer = indexPointerFor(code_point, index("euc-kr"));
              if (pointer === null)
                return encoderError(code_point);
              var lead = floor(pointer / 190) + 129;
              var trail = pointer % 190 + 65;
              return [lead, trail];
            };
          }
          encoders["EUC-KR"] = function(options) {
            return new EUCKREncoder(options);
          };
          decoders["EUC-KR"] = function(options) {
            return new EUCKRDecoder(options);
          };
          function convertCodeUnitToBytes(code_unit, utf16be) {
            var byte1 = code_unit >> 8;
            var byte2 = code_unit & 255;
            if (utf16be)
              return [byte1, byte2];
            return [byte2, byte1];
          }
          function UTF16Decoder(utf16_be, options) {
            var fatal = options.fatal;
            var utf16_lead_byte = null, utf16_lead_surrogate = null;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {
                return decoderError(fatal);
              }
              if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {
                return finished;
              }
              if (utf16_lead_byte === null) {
                utf16_lead_byte = bite;
                return null;
              }
              var code_unit;
              if (utf16_be) {
                code_unit = (utf16_lead_byte << 8) + bite;
              } else {
                code_unit = (bite << 8) + utf16_lead_byte;
              }
              utf16_lead_byte = null;
              if (utf16_lead_surrogate !== null) {
                var lead_surrogate = utf16_lead_surrogate;
                utf16_lead_surrogate = null;
                if (inRange(code_unit, 56320, 57343)) {
                  return 65536 + (lead_surrogate - 55296) * 1024 + (code_unit - 56320);
                }
                stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
                return decoderError(fatal);
              }
              if (inRange(code_unit, 55296, 56319)) {
                utf16_lead_surrogate = code_unit;
                return null;
              }
              if (inRange(code_unit, 56320, 57343))
                return decoderError(fatal);
              return code_unit;
            };
          }
          function UTF16Encoder(utf16_be, options) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (inRange(code_point, 0, 65535))
                return convertCodeUnitToBytes(code_point, utf16_be);
              var lead = convertCodeUnitToBytes(
                (code_point - 65536 >> 10) + 55296,
                utf16_be
              );
              var trail = convertCodeUnitToBytes(
                (code_point - 65536 & 1023) + 56320,
                utf16_be
              );
              return lead.concat(trail);
            };
          }
          encoders["UTF-16BE"] = function(options) {
            return new UTF16Encoder(true, options);
          };
          decoders["UTF-16BE"] = function(options) {
            return new UTF16Decoder(true, options);
          };
          encoders["UTF-16LE"] = function(options) {
            return new UTF16Encoder(false, options);
          };
          decoders["UTF-16LE"] = function(options) {
            return new UTF16Decoder(false, options);
          };
          function XUserDefinedDecoder(options) {
            var fatal = options.fatal;
            this.handler = function(stream, bite) {
              if (bite === end_of_stream)
                return finished;
              if (isASCIIByte(bite))
                return bite;
              return 63360 + bite - 128;
            };
          }
          function XUserDefinedEncoder(options) {
            var fatal = options.fatal;
            this.handler = function(stream, code_point) {
              if (code_point === end_of_stream)
                return finished;
              if (isASCIICodePoint(code_point))
                return code_point;
              if (inRange(code_point, 63360, 63487))
                return code_point - 63360 + 128;
              return encoderError(code_point);
            };
          }
          encoders["x-user-defined"] = function(options) {
            return new XUserDefinedEncoder(options);
          };
          decoders["x-user-defined"] = function(options) {
            return new XUserDefinedDecoder(options);
          };
          if (!global2["TextEncoder"])
            global2["TextEncoder"] = TextEncoder;
          if (!global2["TextDecoder"])
            global2["TextDecoder"] = TextDecoder2;
          if (typeof module3 !== "undefined" && module3.exports) {
            module3.exports = {
              TextEncoder: global2["TextEncoder"],
              TextDecoder: global2["TextDecoder"],
              EncodingIndexes: global2["encoding-indexes"]
            };
          }
        })(this || {});
      }, { "./encoding-indexes.js": 7 }], 22: [function(require2, module3, exports3) {
        (function(setImmediate, clearImmediate) {
          (function() {
            var nextTick = require2("process/browser.js").nextTick;
            var apply = Function.prototype.apply;
            var slice = Array.prototype.slice;
            var immediateIds = {};
            var nextImmediateId = 0;
            exports3.setTimeout = function() {
              return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
            };
            exports3.setInterval = function() {
              return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
            };
            exports3.clearTimeout = exports3.clearInterval = function(timeout) {
              timeout.close();
            };
            function Timeout(id, clearFn) {
              this._id = id;
              this._clearFn = clearFn;
            }
            Timeout.prototype.unref = Timeout.prototype.ref = function() {
            };
            Timeout.prototype.close = function() {
              this._clearFn.call(window, this._id);
            };
            exports3.enroll = function(item, msecs) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = msecs;
            };
            exports3.unenroll = function(item) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = -1;
            };
            exports3._unrefActive = exports3.active = function(item) {
              clearTimeout(item._idleTimeoutId);
              var msecs = item._idleTimeout;
              if (msecs >= 0) {
                item._idleTimeoutId = setTimeout(function onTimeout() {
                  if (item._onTimeout)
                    item._onTimeout();
                }, msecs);
              }
            };
            exports3.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
              var id = nextImmediateId++;
              var args = arguments.length < 2 ? false : slice.call(arguments, 1);
              immediateIds[id] = true;
              nextTick(function onNextTick() {
                if (immediateIds[id]) {
                  if (args) {
                    fn.apply(null, args);
                  } else {
                    fn.call(null);
                  }
                  exports3.clearImmediate(id);
                }
              });
              return id;
            };
            exports3.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
              delete immediateIds[id];
            };
          }).call(this);
        }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
      }, { "process/browser.js": 16, "timers": 22 }], 23: [function(require2, module3, exports3) {
        (function(global2) {
          (function() {
            "use strict";
            let proj4 = require2("proj4");
            if (proj4.default) {
              proj4 = proj4.default;
            }
            const unzip = require2("./unzip");
            const binaryAjax = require2("./binaryajax");
            const parseShp = require2("./parseShp");
            const parseDbf = require2("parsedbf");
            const Promise2 = require2("lie");
            const Cache = require2("lru-cache");
            const Buffer = require2("buffer").Buffer;
            const URL = global2.URL;
            const cache = new Cache({
              max: 20
            });
            function toBuffer(b) {
              if (!b) {
                throw new Error("forgot to pass buffer");
              }
              if (Buffer.isBuffer(b)) {
                return b;
              }
              if (isArrayBuffer(b)) {
                return Buffer.from(b);
              }
              if (isArrayBuffer(b.buffer)) {
                if (b.BYTES_PER_ELEMENT === 1) {
                  return Buffer.from(b);
                }
                return Buffer.from(b.buffer);
              }
            }
            function isArrayBuffer(subject) {
              return subject instanceof global2.ArrayBuffer || Object.prototype.toString.call(subject) === "[object ArrayBuffer]";
            }
            function shp(base, whiteList) {
              if (typeof base === "string" && cache.has(base)) {
                return Promise2.resolve(cache.get(base));
              }
              return shp.getShapefile(base, whiteList).then(function(resp) {
                if (typeof base === "string") {
                  cache.set(base, resp);
                }
                return resp;
              });
            }
            shp.combine = function([shp2, dbf]) {
              const out = {};
              out.type = "FeatureCollection";
              out.features = [];
              let i = 0;
              const len = shp2.length;
              if (!dbf) {
                dbf = [];
              }
              while (i < len) {
                out.features.push({
                  type: "Feature",
                  geometry: shp2[i],
                  properties: dbf[i] || {}
                });
                i++;
              }
              return out;
            };
            shp.parseZip = async function(buffer, whiteList) {
              let key;
              buffer = toBuffer(buffer);
              const zip = await unzip(buffer);
              const names = [];
              whiteList = whiteList || [];
              for (key in zip) {
                if (key.indexOf("__MACOSX") !== -1) {
                  continue;
                }
                if (key.slice(-3).toLowerCase() === "shp") {
                  names.push(key.slice(0, -4));
                  zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];
                } else if (key.slice(-3).toLowerCase() === "prj") {
                  zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);
                } else if (key.slice(-4).toLowerCase() === "json" || whiteList.indexOf(key.split(".").pop()) > -1) {
                  names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());
                } else if (key.slice(-3).toLowerCase() === "dbf" || key.slice(-3).toLowerCase() === "cpg") {
                  zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];
                }
              }
              if (!names.length) {
                throw new Error("no layers founds");
              }
              const geojson = names.map(function(name) {
                let parsed, dbf;
                const lastDotIdx = name.lastIndexOf(".");
                if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf("json") > -1) {
                  parsed = JSON.parse(zip[name]);
                  parsed.fileName = name.slice(0, lastDotIdx);
                } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {
                  parsed = zip[name];
                  parsed.fileName = name;
                } else {
                  if (zip[name + ".dbf"]) {
                    dbf = parseDbf(zip[name + ".dbf"], zip[name + ".cpg"]);
                  }
                  parsed = shp.combine([parseShp(zip[name + ".shp"], zip[name + ".prj"]), dbf]);
                  parsed.fileName = name;
                }
                return parsed;
              });
              if (geojson.length === 1) {
                return geojson[0];
              } else {
                return geojson;
              }
            };
            async function getZip(base, whiteList) {
              const a = await binaryAjax(base);
              return shp.parseZip(a, whiteList);
            }
            const handleShp = async (base) => {
              const args = await Promise2.all([
                binaryAjax(base, "shp"),
                binaryAjax(base, "prj")
              ]);
              let prj = false;
              try {
                if (args[1]) {
                  prj = proj4(args[1]);
                }
              } catch (e) {
                prj = false;
              }
              return parseShp(args[0], prj);
            };
            const handleDbf = async (base) => {
              const [dbf, cpg] = await Promise2.all([
                binaryAjax(base, "dbf"),
                binaryAjax(base, "cpg")
              ]);
              if (!dbf) {
                return;
              }
              return parseDbf(dbf, cpg);
            };
            const checkSuffix = (base, suffix) => {
              const url = new URL(base);
              return url.pathname.slice(-4).toLowerCase() === suffix;
            };
            shp.getShapefile = async function(base, whiteList) {
              if (typeof base !== "string") {
                return shp.parseZip(base);
              }
              if (checkSuffix(base, ".zip")) {
                return getZip(base, whiteList);
              }
              const results = await Promise2.all([
                handleShp(base),
                handleDbf(base)
              ]);
              return shp.combine(results);
            };
            shp.parseShp = function(shp2, prj) {
              shp2 = toBuffer(shp2);
              if (Buffer.isBuffer(prj)) {
                prj = prj.toString();
              }
              if (typeof prj === "string") {
                try {
                  prj = proj4(prj);
                } catch (e) {
                  prj = false;
                }
              }
              return parseShp(shp2, prj);
            };
            shp.parseDbf = function(dbf, cpg) {
              dbf = toBuffer(dbf);
              return parseDbf(dbf, cpg);
            };
            module3.exports = shp;
          }).call(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./binaryajax": 2, "./parseShp": 4, "./unzip": 5, "buffer": 8, "lie": 12, "lru-cache": 13, "parsedbf": 15, "proj4": 17 }] }, {}, [23])(23);
    });
  }
});

// dep:shpjs_dist_shp
var shpjs_dist_shp_default = require_shp();
export {
  shpjs_dist_shp_default as default
};
/*!

JSZip v3.6.0 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=shpjs_dist_shp.js.map
