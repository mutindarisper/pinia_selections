import {
  __commonJS,
  __require
} from "./chunk-S5KM4IGW.js";

// node_modules/shpjs/dist/shp.js
var require_shp = __commonJS({
  "node_modules/shpjs/dist/shp.js"(exports, module) {
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.shp = f();
      }
    })(function() {
      var define2, module2, exports2;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof __require == "function" && __require;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof __require == "function" && __require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(require2, module3, exports3) {
        "use strict";
        var Promise2 = require2("lie");
        module3.exports = binaryAjax;
        function binaryAjax(url) {
          return new Promise2(function(resolve, reject) {
            var type = url.slice(-3);
            var ajax = new XMLHttpRequest();
            ajax.open("GET", url, true);
            if (type !== "prj") {
              ajax.responseType = "arraybuffer";
            }
            ajax.addEventListener("load", function() {
              if (ajax.status > 399) {
                if (type === "prj") {
                  return resolve(false);
                } else {
                  return reject(new Error(ajax.status));
                }
              }
              resolve(ajax.response);
            }, false);
            ajax.send();
          });
        }
      }, { "lie": 34 }], 2: [function(require2, module3, exports3) {
        "use strict";
        function isClockWise(array) {
          var sum = 0;
          var i = 1;
          var len = array.length;
          var prev, cur;
          while (i < len) {
            prev = cur || array[0];
            cur = array[i];
            sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
            i++;
          }
          return sum > 0;
        }
        function polyReduce(a, b) {
          if (isClockWise(b) || !a.length) {
            a.push([b]);
          } else {
            a[a.length - 1].push(b);
          }
          return a;
        }
        ParseShp.prototype.parsePoint = function(data) {
          return {
            "type": "Point",
            "coordinates": this.parseCoord(data, 0)
          };
        };
        ParseShp.prototype.parseZPoint = function(data) {
          var pointXY = this.parsePoint(data);
          pointXY.coordinates.push(this.parseCoord(data, 16));
          return pointXY;
        };
        ParseShp.prototype.parsePointArray = function(data, offset, num) {
          var out = [];
          var done = 0;
          while (done < num) {
            out.push(this.parseCoord(data, offset));
            offset += 16;
            done++;
          }
          return out;
        };
        ParseShp.prototype.parseZPointArray = function(data, zOffset, num, coordinates) {
          var i = 0;
          while (i < num) {
            coordinates[i].push(data.getFloat64(zOffset, true));
            i++;
            zOffset += 8;
          }
          return coordinates;
        };
        ParseShp.prototype.parseArrayGroup = function(data, offset, partOffset, num, tot) {
          var out = [];
          var done = 0;
          var curNum, nextNum = 0, pointNumber;
          while (done < num) {
            done++;
            partOffset += 4;
            curNum = nextNum;
            if (done === num) {
              nextNum = tot;
            } else {
              nextNum = data.getInt32(partOffset, true);
            }
            pointNumber = nextNum - curNum;
            if (!pointNumber) {
              continue;
            }
            out.push(this.parsePointArray(data, offset, pointNumber));
            offset += pointNumber << 4;
          }
          return out;
        };
        ParseShp.prototype.parseZArrayGroup = function(data, zOffset, num, coordinates) {
          var i = 0;
          while (i < num) {
            coordinates[i] = this.parseZPointArray(data, zOffset, coordinates[i].length, coordinates[i]);
            zOffset += coordinates[i].length << 3;
            i++;
          }
          return coordinates;
        };
        ParseShp.prototype.parseMultiPoint = function(data) {
          var out = {};
          var mins = this.parseCoord(data, 0);
          var maxs = this.parseCoord(data, 16);
          out.bbox = [
            mins[0],
            mins[1],
            maxs[0],
            maxs[1]
          ];
          var num = data.getInt32(32, true);
          var offset = 36;
          if (num === 1) {
            out.type = "Point";
            out.coordinates = this.parseCoord(data, offset);
          } else {
            out.type = "MultiPoint";
            out.coordinates = this.parsePointArray(data, offset, num);
          }
          return out;
        };
        ParseShp.prototype.parseZMultiPoint = function(data) {
          var geoJson = this.parseMultiPoint(data);
          var num;
          if (geoJson.type === "Point") {
            geoJson.coordinates.push(data.getFloat64(72, true));
            return geoJson;
          } else {
            num = geoJson.coordinates.length;
          }
          var zOffset = 56 + (num << 4);
          geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);
          return geoJson;
        };
        ParseShp.prototype.parsePolyline = function(data) {
          var out = {};
          var mins = this.parseCoord(data, 0);
          var maxs = this.parseCoord(data, 16);
          out.bbox = [
            mins[0],
            mins[1],
            maxs[0],
            maxs[1]
          ];
          var numParts = data.getInt32(32, true);
          var num = data.getInt32(36, true);
          var offset, partOffset;
          if (numParts === 1) {
            out.type = "LineString";
            offset = 44;
            out.coordinates = this.parsePointArray(data, offset, num);
          } else {
            out.type = "MultiLineString";
            offset = 40 + (numParts << 2);
            partOffset = 40;
            out.coordinates = this.parseArrayGroup(data, offset, partOffset, numParts, num);
          }
          return out;
        };
        ParseShp.prototype.parseZPolyline = function(data) {
          var geoJson = this.parsePolyline(data);
          var num = geoJson.coordinates.length;
          var zOffset = 60 + (num << 4);
          if (geoJson.type === "LineString") {
            geoJson.coordinates = this.parseZPointArray(data, zOffset, num, geoJson.coordinates);
            return geoJson;
          } else {
            geoJson.coordinates = this.parseZArrayGroup(data, zOffset, num, geoJson.coordinates);
            return geoJson;
          }
        };
        ParseShp.prototype.polyFuncs = function(out) {
          if (out.type === "LineString") {
            out.type = "Polygon";
            out.coordinates = [out.coordinates];
            return out;
          } else {
            out.coordinates = out.coordinates.reduce(polyReduce, []);
            if (out.coordinates.length === 1) {
              out.type = "Polygon";
              out.coordinates = out.coordinates[0];
              return out;
            } else {
              out.type = "MultiPolygon";
              return out;
            }
          }
        };
        ParseShp.prototype.parsePolygon = function(data) {
          return this.polyFuncs(this.parsePolyline(data));
        };
        ParseShp.prototype.parseZPolygon = function(data) {
          return this.polyFuncs(this.parseZPolyline(data));
        };
        var shpFuncObj = {
          1: "parsePoint",
          3: "parsePolyline",
          5: "parsePolygon",
          8: "parseMultiPoint",
          11: "parseZPoint",
          13: "parseZPolyline",
          15: "parseZPolygon",
          18: "parseZMultiPoint"
        };
        function makeParseCoord(trans) {
          if (trans) {
            return function(data, offset) {
              return trans.inverse([data.getFloat64(offset, true), data.getFloat64(offset + 8, true)]);
            };
          } else {
            return function(data, offset) {
              return [data.getFloat64(offset, true), data.getFloat64(offset + 8, true)];
            };
          }
        }
        function ParseShp(buffer, trans) {
          if (!(this instanceof ParseShp)) {
            return new ParseShp(buffer, trans);
          }
          this.buffer = buffer;
          this.shpFuncs(trans);
          this.rows = this.getRows();
        }
        ParseShp.prototype.shpFuncs = function(tran) {
          var num = this.getShpCode();
          if (num > 20) {
            num -= 20;
          }
          if (!(num in shpFuncObj)) {
            throw new Error("I don't know that shp type");
          }
          this.parseFunc = this[shpFuncObj[num]];
          this.parseCoord = makeParseCoord(tran);
        };
        ParseShp.prototype.getShpCode = function() {
          return this.parseHeader().shpCode;
        };
        ParseShp.prototype.parseHeader = function() {
          var view = new DataView(this.buffer, 0, 100);
          return {
            length: view.getInt32(6 << 2, false),
            version: view.getInt32(7 << 2, true),
            shpCode: view.getInt32(8 << 2, true),
            bbox: [
              view.getFloat64(9 << 2, true),
              view.getFloat64(11 << 2, true),
              view.getFloat64(13 << 2, true),
              view.getFloat64(13 << 2, true)
            ]
          };
        };
        ParseShp.prototype.getRows = function() {
          var offset = 100;
          var len = this.buffer.byteLength;
          var out = [];
          var current;
          while (offset < len) {
            current = this.getRow(offset);
            offset += 8;
            offset += current.len;
            if (current.type) {
              out.push(this.parseFunc(current.data));
            }
          }
          return out;
        };
        ParseShp.prototype.getRow = function(offset) {
          var view = new DataView(this.buffer, offset, 12);
          var len = view.getInt32(4, false) << 1;
          var data = new DataView(this.buffer, offset + 12, len - 4);
          return {
            id: view.getInt32(0, false),
            len,
            data,
            type: view.getInt32(8, true)
          };
        };
        module3.exports = function(buffer, trans) {
          return new ParseShp(buffer, trans).rows;
        };
      }, {}], 3: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = toArrayBuffer;
        function toArrayBuffer(buffer) {
          var arrayBuffer = new ArrayBuffer(buffer.length);
          var view = new Uint8Array(arrayBuffer);
          var i = -1;
          var len = buffer.length;
          while (++i < len) {
            view[i] = buffer[i];
          }
          return arrayBuffer;
        }
      }, {}], 4: [function(require2, module3, exports3) {
        "use strict";
        var JSZip = require2("jszip");
        module3.exports = function(buffer) {
          var zip = new JSZip(buffer);
          var files = zip.file(/.+/);
          var out = {};
          files.forEach(function(a) {
            if (a.name.slice(-3).toLowerCase() === "shp" || a.name.slice(-3).toLowerCase() === "dbf") {
              out[a.name] = a.asText();
              out[a.name] = a.asArrayBuffer();
            } else {
              out[a.name] = a.asText();
            }
          });
          return out;
        };
      }, { "jszip": 19 }], 5: [function(require2, module3, exports3) {
        "use strict";
        exports3.toByteArray = toByteArray;
        exports3.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        function init() {
          var i;
          var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var len = code.length;
          for (i = 0; i < len; i++) {
            lookup[i] = code[i];
          }
          for (i = 0; i < len; ++i) {
            revLookup[code.charCodeAt(i)] = i;
          }
          revLookup["-".charCodeAt(0)] = 62;
          revLookup["_".charCodeAt(0)] = 63;
        }
        init();
        function toByteArray(b64) {
          var i, j, l, tmp, placeHolders, arr;
          var len = b64.length;
          if (len % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
          arr = new Arr(len * 3 / 4 - placeHolders);
          l = placeHolders > 0 ? len - 4 : len;
          var L = 0;
          for (i = 0, j = 0; i < l; i += 4, j += 3) {
            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
            arr[L++] = (tmp & 16711680) >> 16;
            arr[L++] = (tmp & 65280) >> 8;
            arr[L++] = tmp & 255;
          }
          if (placeHolders === 2) {
            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
            arr[L++] = tmp & 255;
          } else if (placeHolders === 1) {
            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3;
          var output = "";
          var parts = [];
          var maxChunkLength = 16383;
          for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            output += lookup[tmp >> 2];
            output += lookup[tmp << 4 & 63];
            output += "==";
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            output += lookup[tmp >> 10];
            output += lookup[tmp >> 4 & 63];
            output += lookup[tmp << 2 & 63];
            output += "=";
          }
          parts.push(output);
          return parts.join("");
        }
      }, {}], 6: [function(require2, module3, exports3) {
        (function(global2) {
          "use strict";
          var base64 = require2("base64-js");
          var ieee754 = require2("ieee754");
          var isArray = require2("isarray");
          exports3.Buffer = Buffer;
          exports3.SlowBuffer = SlowBuffer;
          exports3.INSPECT_MAX_BYTES = 50;
          Buffer.poolSize = 8192;
          var rootParent = {};
          Buffer.TYPED_ARRAY_SUPPORT = global2.TYPED_ARRAY_SUPPORT !== void 0 ? global2.TYPED_ARRAY_SUPPORT : typedArraySupport();
          function typedArraySupport() {
            try {
              var arr = new Uint8Array(1);
              arr.foo = function() {
                return 42;
              };
              return arr.foo() === 42 && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0;
            } catch (e) {
              return false;
            }
          }
          function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function Buffer(arg) {
            if (!(this instanceof Buffer)) {
              if (arguments.length > 1)
                return new Buffer(arg, arguments[1]);
              return new Buffer(arg);
            }
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              this.length = 0;
              this.parent = void 0;
            }
            if (typeof arg === "number") {
              return fromNumber(this, arg);
            }
            if (typeof arg === "string") {
              return fromString(this, arg, arguments.length > 1 ? arguments[1] : "utf8");
            }
            return fromObject(this, arg);
          }
          Buffer._augment = function(arr) {
            arr.__proto__ = Buffer.prototype;
            return arr;
          };
          function fromNumber(that, length) {
            that = allocate(that, length < 0 ? 0 : checked(length) | 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < length; i++) {
                that[i] = 0;
              }
            }
            return that;
          }
          function fromString(that, string, encoding) {
            if (typeof encoding !== "string" || encoding === "")
              encoding = "utf8";
            var length = byteLength(string, encoding) | 0;
            that = allocate(that, length);
            that.write(string, encoding);
            return that;
          }
          function fromObject(that, object) {
            if (Buffer.isBuffer(object))
              return fromBuffer(that, object);
            if (isArray(object))
              return fromArray(that, object);
            if (object == null) {
              throw new TypeError("must start with number, buffer, array or string");
            }
            if (typeof ArrayBuffer !== "undefined") {
              if (object.buffer instanceof ArrayBuffer) {
                return fromTypedArray(that, object);
              }
              if (object instanceof ArrayBuffer) {
                return fromArrayBuffer(that, object);
              }
            }
            if (object.length)
              return fromArrayLike(that, object);
            return fromJsonObject(that, object);
          }
          function fromBuffer(that, buffer) {
            var length = checked(buffer.length) | 0;
            that = allocate(that, length);
            buffer.copy(that, 0, 0, length);
            return that;
          }
          function fromArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromTypedArray(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromArrayBuffer(that, array) {
            array.byteLength;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              that = new Uint8Array(array);
              that.__proto__ = Buffer.prototype;
            } else {
              that = fromTypedArray(that, new Uint8Array(array));
            }
            return that;
          }
          function fromArrayLike(that, array) {
            var length = checked(array.length) | 0;
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromJsonObject(that, object) {
            var array;
            var length = 0;
            if (object.type === "Buffer" && isArray(object.data)) {
              array = object.data;
              length = checked(array.length) | 0;
            }
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;
            if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
              Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true
              });
            }
          } else {
            Buffer.prototype.length = void 0;
            Buffer.prototype.parent = void 0;
          }
          function allocate(that, length) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              that = new Uint8Array(length);
              that.__proto__ = Buffer.prototype;
            } else {
              that.length = length;
            }
            var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
            if (fromPool)
              that.parent = rootParent;
            return that;
          }
          function checked(length) {
            if (length >= kMaxLength()) {
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
            }
            return length | 0;
          }
          function SlowBuffer(subject, encoding) {
            if (!(this instanceof SlowBuffer))
              return new SlowBuffer(subject, encoding);
            var buf = new Buffer(subject, encoding);
            delete buf.parent;
            return buf;
          }
          Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
          };
          Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError("Arguments must be Buffers");
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            var i = 0;
            var len = Math.min(x, y);
            while (i < len) {
              if (a[i] !== b[i])
                break;
              ++i;
            }
            if (i !== len) {
              x = a[i];
              y = b[i];
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!isArray(list))
              throw new TypeError("list argument must be an Array of Buffers.");
            if (list.length === 0) {
              return new Buffer(0);
            }
            var i;
            if (length === void 0) {
              length = 0;
              for (i = 0; i < list.length; i++) {
                length += list[i].length;
              }
            }
            var buf = new Buffer(length);
            var pos = 0;
            for (i = 0; i < list.length; i++) {
              var item = list[i];
              item.copy(buf, pos);
              pos += item.length;
            }
            return buf;
          };
          function byteLength(string, encoding) {
            if (typeof string !== "string")
              string = "" + string;
            var len = string.length;
            if (len === 0)
              return 0;
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "ascii":
                case "binary":
                case "raw":
                case "raws":
                  return len;
                case "utf8":
                case "utf-8":
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase)
                    return utf8ToBytes(string).length;
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            start = start | 0;
            end = end === void 0 || end === Infinity ? this.length : end | 0;
            if (!encoding)
              encoding = "utf8";
            if (start < 0)
              start = 0;
            if (end > this.length)
              end = this.length;
            if (end <= start)
              return "";
            while (true) {
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "binary":
                  return binarySlice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.prototype._isBuffer = true;
          Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0)
              return "";
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            if (this === b)
              return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = "";
            var max = exports3.INSPECT_MAX_BYTES;
            if (this.length > 0) {
              str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
              if (this.length > max)
                str += " ... ";
            }
            return "<Buffer " + str + ">";
          };
          Buffer.prototype.compare = function compare(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            if (this === b)
              return 0;
            return Buffer.compare(this, b);
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
            if (byteOffset > 2147483647)
              byteOffset = 2147483647;
            else if (byteOffset < -2147483648)
              byteOffset = -2147483648;
            byteOffset >>= 0;
            if (this.length === 0)
              return -1;
            if (byteOffset >= this.length)
              return -1;
            if (byteOffset < 0)
              byteOffset = Math.max(this.length + byteOffset, 0);
            if (typeof val === "string") {
              if (val.length === 0)
                return -1;
              return String.prototype.indexOf.call(this, val, byteOffset);
            }
            if (Buffer.isBuffer(val)) {
              return arrayIndexOf(this, val, byteOffset);
            }
            if (typeof val === "number") {
              if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === "function") {
                return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
              }
              return arrayIndexOf(this, [val], byteOffset);
            }
            function arrayIndexOf(arr, val2, byteOffset2) {
              var foundIndex = -1;
              for (var i = 0; byteOffset2 + i < arr.length; i++) {
                if (arr[byteOffset2 + i] === val2[foundIndex === -1 ? 0 : i - foundIndex]) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === val2.length)
                    return byteOffset2 + foundIndex;
                } else {
                  foundIndex = -1;
                }
              }
              return -1;
            }
            throw new TypeError("val must be string, number or Buffer");
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (strLen % 2 !== 0)
              throw new Error("Invalid hex string");
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; i++) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed))
                throw new Error("Invalid hex string");
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === void 0) {
              encoding = "utf8";
              length = this.length;
              offset = 0;
            } else if (length === void 0 && typeof offset === "string") {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset | 0;
              if (isFinite(length)) {
                length = length | 0;
                if (encoding === void 0)
                  encoding = "utf8";
              } else {
                encoding = length;
                length = void 0;
              }
            } else {
              var swap = encoding;
              encoding = offset;
              offset = length | 0;
              length = swap;
            }
            var remaining = this.length - offset;
            if (length === void 0 || length > remaining)
              length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError("attempt to write outside buffer bounds");
            }
            if (!encoding)
              encoding = "utf8";
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);
                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);
                case "ascii":
                  return asciiWrite(this, string, offset, length);
                case "binary":
                  return binaryWrite(this, string, offset, length);
                case "base64":
                  return base64Write(this, string, offset, length);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 128) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                      tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                      if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                      if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                      if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(
                String,
                codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
              );
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function binarySlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = "";
            for (var i = start; i < end; i++) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === void 0 ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer.prototype;
            } else {
              var sliceLen = end - start;
              newBuf = new Buffer(sliceLen, void 0);
              for (var i = 0; i < sliceLen; i++) {
                newBuf[i] = this[i + start];
              }
            }
            if (newBuf.length)
              newBuf.parent = this.parent || this;
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert) {
              checkOffset(offset, byteLength2, this.length);
            }
            var val = this[offset + --byteLength2];
            var mul = 1;
            while (byteLength2 > 0 && (mul *= 256)) {
              val += this[offset + --byteLength2] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var i = byteLength2;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128))
              return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError("buffer must be a Buffer instance");
            if (value > max || value < min)
              throw new RangeError("value is out of bounds");
            if (offset + ext > buf.length)
              throw new RangeError("index out of range");
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkInt(this, value, offset, byteLength2, Math.pow(2, 8 * byteLength2), 0);
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkInt(this, value, offset, byteLength2, Math.pow(2, 8 * byteLength2), 0);
            var i = byteLength2 - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            this[offset] = value & 255;
            return offset + 1;
          };
          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
              buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
          }
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
              buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
            }
          }
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            if (value < 0)
              value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0)
              value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError("index out of range");
            if (offset < 0)
              throw new RangeError("index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            if (targetStart < 0) {
              throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length)
              throw new RangeError("sourceStart out of bounds");
            if (end < 0)
              throw new RangeError("sourceEnd out of bounds");
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            var i;
            if (this === target && start < targetStart && targetStart < end) {
              for (i = len - 1; i >= 0; i--) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
              for (i = 0; i < len; i++) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(
                target,
                this.subarray(start, start + len),
                targetStart
              );
            }
            return len;
          };
          Buffer.prototype.fill = function fill(value, start, end) {
            if (!value)
              value = 0;
            if (!start)
              start = 0;
            if (!end)
              end = this.length;
            if (end < start)
              throw new RangeError("end < start");
            if (end === start)
              return;
            if (this.length === 0)
              return;
            if (start < 0 || start >= this.length)
              throw new RangeError("start out of bounds");
            if (end < 0 || end > this.length)
              throw new RangeError("end out of bounds");
            var i;
            if (typeof value === "number") {
              for (i = start; i < end; i++) {
                this[i] = value;
              }
            } else {
              var bytes = utf8ToBytes(value.toString());
              var len = bytes.length;
              for (i = start; i < end; i++) {
                this[i] = bytes[i % len];
              }
            }
            return this;
          };
          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, "");
            if (str.length < 2)
              return "";
            while (str.length % 4 !== 0) {
              str = str + "=";
            }
            return str;
          }
          function stringtrim(str) {
            if (str.trim)
              return str.trim();
            return str.replace(/^\s+|\s+$/g, "");
          }
          function toHex(n) {
            if (n < 16)
              return "0" + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; i++) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              if (codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(
                  codePoint >> 6 | 192,
                  codePoint & 63 | 128
                );
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(
                  codePoint >> 12 | 224,
                  codePoint >> 6 & 63 | 128,
                  codePoint & 63 | 128
                );
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(
                  codePoint >> 18 | 240,
                  codePoint >> 12 & 63 | 128,
                  codePoint >> 6 & 63 | 128,
                  codePoint & 63 | 128
                );
              } else {
                throw new Error("Invalid code point");
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
              if ((units -= 2) < 0)
                break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
              if (i + offset >= dst.length || i >= src.length)
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "base64-js": 5, "ieee754": 8, "isarray": 7 }], 7: [function(require2, module3, exports3) {
        var toString = {}.toString;
        module3.exports = Array.isArray || function(arr) {
          return toString.call(arr) == "[object Array]";
        };
      }, {}], 8: [function(require2, module3, exports3) {
        exports3.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports3.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      }, {}], 9: [function(require2, module3, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i = -1;
              while (++i < len) {
                oldQueue[i]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module3.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 10: [function(require2, module3, exports3) {
        module3.exports = function(obj) {
          return !!(obj != null && (obj._isBuffer || obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj)));
        };
      }, {}], 11: [function(require2, module3, exports3) {
        "use strict";
        var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        exports3.encode = function(input, utf8) {
          var output = "";
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
          var i = 0;
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
          }
          return output;
        };
        exports3.decode = function(input, utf8) {
          var output = "";
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
              output = output + String.fromCharCode(chr3);
            }
          }
          return output;
        };
      }, {}], 12: [function(require2, module3, exports3) {
        "use strict";
        function CompressedObject() {
          this.compressedSize = 0;
          this.uncompressedSize = 0;
          this.crc32 = 0;
          this.compressionMethod = null;
          this.compressedContent = null;
        }
        CompressedObject.prototype = {
          getContent: function() {
            return null;
          },
          getCompressedContent: function() {
            return null;
          }
        };
        module3.exports = CompressedObject;
      }, {}], 13: [function(require2, module3, exports3) {
        "use strict";
        exports3.STORE = {
          magic: "\0\0",
          compress: function(content, compressionOptions) {
            return content;
          },
          uncompress: function(content) {
            return content;
          },
          compressInputType: null,
          uncompressInputType: null
        };
        exports3.DEFLATE = require2("./flate");
      }, { "./flate": 18 }], 14: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("./utils");
        var table = [
          0,
          1996959894,
          3993919788,
          2567524794,
          124634137,
          1886057615,
          3915621685,
          2657392035,
          249268274,
          2044508324,
          3772115230,
          2547177864,
          162941995,
          2125561021,
          3887607047,
          2428444049,
          498536548,
          1789927666,
          4089016648,
          2227061214,
          450548861,
          1843258603,
          4107580753,
          2211677639,
          325883990,
          1684777152,
          4251122042,
          2321926636,
          335633487,
          1661365465,
          4195302755,
          2366115317,
          997073096,
          1281953886,
          3579855332,
          2724688242,
          1006888145,
          1258607687,
          3524101629,
          2768942443,
          901097722,
          1119000684,
          3686517206,
          2898065728,
          853044451,
          1172266101,
          3705015759,
          2882616665,
          651767980,
          1373503546,
          3369554304,
          3218104598,
          565507253,
          1454621731,
          3485111705,
          3099436303,
          671266974,
          1594198024,
          3322730930,
          2970347812,
          795835527,
          1483230225,
          3244367275,
          3060149565,
          1994146192,
          31158534,
          2563907772,
          4023717930,
          1907459465,
          112637215,
          2680153253,
          3904427059,
          2013776290,
          251722036,
          2517215374,
          3775830040,
          2137656763,
          141376813,
          2439277719,
          3865271297,
          1802195444,
          476864866,
          2238001368,
          4066508878,
          1812370925,
          453092731,
          2181625025,
          4111451223,
          1706088902,
          314042704,
          2344532202,
          4240017532,
          1658658271,
          366619977,
          2362670323,
          4224994405,
          1303535960,
          984961486,
          2747007092,
          3569037538,
          1256170817,
          1037604311,
          2765210733,
          3554079995,
          1131014506,
          879679996,
          2909243462,
          3663771856,
          1141124467,
          855842277,
          2852801631,
          3708648649,
          1342533948,
          654459306,
          3188396048,
          3373015174,
          1466479909,
          544179635,
          3110523913,
          3462522015,
          1591671054,
          702138776,
          2966460450,
          3352799412,
          1504918807,
          783551873,
          3082640443,
          3233442989,
          3988292384,
          2596254646,
          62317068,
          1957810842,
          3939845945,
          2647816111,
          81470997,
          1943803523,
          3814918930,
          2489596804,
          225274430,
          2053790376,
          3826175755,
          2466906013,
          167816743,
          2097651377,
          4027552580,
          2265490386,
          503444072,
          1762050814,
          4150417245,
          2154129355,
          426522225,
          1852507879,
          4275313526,
          2312317920,
          282753626,
          1742555852,
          4189708143,
          2394877945,
          397917763,
          1622183637,
          3604390888,
          2714866558,
          953729732,
          1340076626,
          3518719985,
          2797360999,
          1068828381,
          1219638859,
          3624741850,
          2936675148,
          906185462,
          1090812512,
          3747672003,
          2825379669,
          829329135,
          1181335161,
          3412177804,
          3160834842,
          628085408,
          1382605366,
          3423369109,
          3138078467,
          570562233,
          1426400815,
          3317316542,
          2998733608,
          733239954,
          1555261956,
          3268935591,
          3050360625,
          752459403,
          1541320221,
          2607071920,
          3965973030,
          1969922972,
          40735498,
          2617837225,
          3943577151,
          1913087877,
          83908371,
          2512341634,
          3803740692,
          2075208622,
          213261112,
          2463272603,
          3855990285,
          2094854071,
          198958881,
          2262029012,
          4057260610,
          1759359992,
          534414190,
          2176718541,
          4139329115,
          1873836001,
          414664567,
          2282248934,
          4279200368,
          1711684554,
          285281116,
          2405801727,
          4167216745,
          1634467795,
          376229701,
          2685067896,
          3608007406,
          1308918612,
          956543938,
          2808555105,
          3495958263,
          1231636301,
          1047427035,
          2932959818,
          3654703836,
          1088359270,
          936918e3,
          2847714899,
          3736837829,
          1202900863,
          817233897,
          3183342108,
          3401237130,
          1404277552,
          615818150,
          3134207493,
          3453421203,
          1423857449,
          601450431,
          3009837614,
          3294710456,
          1567103746,
          711928724,
          3020668471,
          3272380065,
          1510334235,
          755167117
        ];
        module3.exports = function crc32(input, crc) {
          if (typeof input === "undefined" || !input.length) {
            return 0;
          }
          var isArray = utils.getTypeOf(input) !== "string";
          if (typeof crc == "undefined") {
            crc = 0;
          }
          var x = 0;
          var y = 0;
          var b = 0;
          crc = crc ^ -1;
          for (var i = 0, iTop = input.length; i < iTop; i++) {
            b = isArray ? input[i] : input.charCodeAt(i);
            y = (crc ^ b) & 255;
            x = table[y];
            crc = crc >>> 8 ^ x;
          }
          return crc ^ -1;
        };
      }, { "./utils": 31 }], 15: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("./utils");
        function DataReader(data) {
          this.data = null;
          this.length = 0;
          this.index = 0;
        }
        DataReader.prototype = {
          checkOffset: function(offset) {
            this.checkIndex(this.index + offset);
          },
          checkIndex: function(newIndex) {
            if (this.length < newIndex || newIndex < 0) {
              throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
            }
          },
          setIndex: function(newIndex) {
            this.checkIndex(newIndex);
            this.index = newIndex;
          },
          skip: function(n) {
            this.setIndex(this.index + n);
          },
          byteAt: function(i) {
          },
          readInt: function(size) {
            var result = 0, i;
            this.checkOffset(size);
            for (i = this.index + size - 1; i >= this.index; i--) {
              result = (result << 8) + this.byteAt(i);
            }
            this.index += size;
            return result;
          },
          readString: function(size) {
            return utils.transformTo("string", this.readData(size));
          },
          readData: function(size) {
          },
          lastIndexOfSignature: function(sig) {
          },
          readDate: function() {
            var dostime = this.readInt(4);
            return new Date(
              (dostime >> 25 & 127) + 1980,
              (dostime >> 21 & 15) - 1,
              dostime >> 16 & 31,
              dostime >> 11 & 31,
              dostime >> 5 & 63,
              (dostime & 31) << 1
            );
          }
        };
        module3.exports = DataReader;
      }, { "./utils": 31 }], 16: [function(require2, module3, exports3) {
        "use strict";
        exports3.base64 = false;
        exports3.binary = false;
        exports3.dir = false;
        exports3.createFolders = false;
        exports3.date = null;
        exports3.compression = null;
        exports3.compressionOptions = null;
        exports3.comment = null;
        exports3.unixPermissions = null;
        exports3.dosPermissions = null;
      }, {}], 17: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("./utils");
        exports3.string2binary = function(str) {
          return utils.string2binary(str);
        };
        exports3.string2Uint8Array = function(str) {
          return utils.transformTo("uint8array", str);
        };
        exports3.uint8Array2String = function(array) {
          return utils.transformTo("string", array);
        };
        exports3.string2Blob = function(str) {
          var buffer = utils.transformTo("arraybuffer", str);
          return utils.arrayBuffer2Blob(buffer);
        };
        exports3.arrayBuffer2Blob = function(buffer) {
          return utils.arrayBuffer2Blob(buffer);
        };
        exports3.transformTo = function(outputType, input) {
          return utils.transformTo(outputType, input);
        };
        exports3.getTypeOf = function(input) {
          return utils.getTypeOf(input);
        };
        exports3.checkSupport = function(type) {
          return utils.checkSupport(type);
        };
        exports3.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;
        exports3.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;
        exports3.pretty = function(str) {
          return utils.pretty(str);
        };
        exports3.findCompression = function(compressionMethod) {
          return utils.findCompression(compressionMethod);
        };
        exports3.isRegExp = function(object) {
          return utils.isRegExp(object);
        };
      }, { "./utils": 31 }], 18: [function(require2, module3, exports3) {
        "use strict";
        var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
        var pako = require2("pako");
        exports3.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
        exports3.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
        exports3.magic = "\b\0";
        exports3.compress = function(input, compressionOptions) {
          return pako.deflateRaw(input, {
            level: compressionOptions.level || -1
          });
        };
        exports3.uncompress = function(input) {
          return pako.inflateRaw(input);
        };
      }, { "pako": 37 }], 19: [function(require2, module3, exports3) {
        "use strict";
        var base64 = require2("./base64");
        function JSZip(data, options) {
          if (!(this instanceof JSZip))
            return new JSZip(data, options);
          this.files = {};
          this.comment = null;
          this.root = "";
          if (data) {
            this.load(data, options);
          }
          this.clone = function() {
            var newObj = new JSZip();
            for (var i in this) {
              if (typeof this[i] !== "function") {
                newObj[i] = this[i];
              }
            }
            return newObj;
          };
        }
        JSZip.prototype = require2("./object");
        JSZip.prototype.load = require2("./load");
        JSZip.support = require2("./support");
        JSZip.defaults = require2("./defaults");
        JSZip.utils = require2("./deprecatedPublicUtils");
        JSZip.base64 = {
          encode: function(input) {
            return base64.encode(input);
          },
          decode: function(input) {
            return base64.decode(input);
          }
        };
        JSZip.compressions = require2("./compressions");
        module3.exports = JSZip;
      }, { "./base64": 11, "./compressions": 13, "./defaults": 16, "./deprecatedPublicUtils": 17, "./load": 20, "./object": 23, "./support": 27 }], 20: [function(require2, module3, exports3) {
        "use strict";
        var base64 = require2("./base64");
        var ZipEntries = require2("./zipEntries");
        module3.exports = function(data, options) {
          var files, zipEntries, i, input;
          options = options || {};
          if (options.base64) {
            data = base64.decode(data);
          }
          zipEntries = new ZipEntries(data, options);
          files = zipEntries.files;
          for (i = 0; i < files.length; i++) {
            input = files[i];
            this.file(input.fileName, input.decompressed, {
              binary: true,
              optimizedBinaryString: true,
              date: input.date,
              dir: input.dir,
              comment: input.fileComment.length ? input.fileComment : null,
              unixPermissions: input.unixPermissions,
              dosPermissions: input.dosPermissions,
              createFolders: options.createFolders
            });
          }
          if (zipEntries.zipComment.length) {
            this.comment = zipEntries.zipComment;
          }
          return this;
        };
      }, { "./base64": 11, "./zipEntries": 32 }], 21: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          module3.exports = function(data, encoding) {
            return new Buffer(data, encoding);
          };
          module3.exports.test = function(b) {
            return Buffer.isBuffer(b);
          };
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 6 }], 22: [function(require2, module3, exports3) {
        "use strict";
        var Uint8ArrayReader = require2("./uint8ArrayReader");
        function NodeBufferReader(data) {
          this.data = data;
          this.length = this.data.length;
          this.index = 0;
        }
        NodeBufferReader.prototype = new Uint8ArrayReader();
        NodeBufferReader.prototype.readData = function(size) {
          this.checkOffset(size);
          var result = this.data.slice(this.index, this.index + size);
          this.index += size;
          return result;
        };
        module3.exports = NodeBufferReader;
      }, { "./uint8ArrayReader": 28 }], 23: [function(require2, module3, exports3) {
        "use strict";
        var support = require2("./support");
        var utils = require2("./utils");
        var crc32 = require2("./crc32");
        var signature = require2("./signature");
        var defaults = require2("./defaults");
        var base64 = require2("./base64");
        var compressions = require2("./compressions");
        var CompressedObject = require2("./compressedObject");
        var nodeBuffer = require2("./nodeBuffer");
        var utf8 = require2("./utf8");
        var StringWriter = require2("./stringWriter");
        var Uint8ArrayWriter = require2("./uint8ArrayWriter");
        var getRawData = function(file) {
          if (file._data instanceof CompressedObject) {
            file._data = file._data.getContent();
            file.options.binary = true;
            file.options.base64 = false;
            if (utils.getTypeOf(file._data) === "uint8array") {
              var copy = file._data;
              file._data = new Uint8Array(copy.length);
              if (copy.length !== 0) {
                file._data.set(copy, 0);
              }
            }
          }
          return file._data;
        };
        var getBinaryData = function(file) {
          var result = getRawData(file), type = utils.getTypeOf(result);
          if (type === "string") {
            if (!file.options.binary) {
              if (support.nodebuffer) {
                return nodeBuffer(result, "utf-8");
              }
            }
            return file.asBinary();
          }
          return result;
        };
        var dataToString = function(asUTF8) {
          var result = getRawData(this);
          if (result === null || typeof result === "undefined") {
            return "";
          }
          if (this.options.base64) {
            result = base64.decode(result);
          }
          if (asUTF8 && this.options.binary) {
            result = out.utf8decode(result);
          } else {
            result = utils.transformTo("string", result);
          }
          if (!asUTF8 && !this.options.binary) {
            result = utils.transformTo("string", out.utf8encode(result));
          }
          return result;
        };
        var ZipObject = function(name, data, options) {
          this.name = name;
          this.dir = options.dir;
          this.date = options.date;
          this.comment = options.comment;
          this.unixPermissions = options.unixPermissions;
          this.dosPermissions = options.dosPermissions;
          this._data = data;
          this.options = options;
          this._initialMetadata = {
            dir: options.dir,
            date: options.date
          };
        };
        ZipObject.prototype = {
          asText: function() {
            return dataToString.call(this, true);
          },
          asBinary: function() {
            return dataToString.call(this, false);
          },
          asNodeBuffer: function() {
            var result = getBinaryData(this);
            return utils.transformTo("nodebuffer", result);
          },
          asUint8Array: function() {
            var result = getBinaryData(this);
            return utils.transformTo("uint8array", result);
          },
          asArrayBuffer: function() {
            return this.asUint8Array().buffer;
          }
        };
        var decToHex = function(dec, bytes) {
          var hex = "", i;
          for (i = 0; i < bytes; i++) {
            hex += String.fromCharCode(dec & 255);
            dec = dec >>> 8;
          }
          return hex;
        };
        var extend = function() {
          var result = {}, i, attr;
          for (i = 0; i < arguments.length; i++) {
            for (attr in arguments[i]) {
              if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
              }
            }
          }
          return result;
        };
        var prepareFileAttrs = function(o) {
          o = o || {};
          if (o.base64 === true && (o.binary === null || o.binary === void 0)) {
            o.binary = true;
          }
          o = extend(o, defaults);
          o.date = o.date || new Date();
          if (o.compression !== null)
            o.compression = o.compression.toUpperCase();
          return o;
        };
        var fileAdd = function(name, data, o) {
          var dataType = utils.getTypeOf(data), parent;
          o = prepareFileAttrs(o);
          if (typeof o.unixPermissions === "string") {
            o.unixPermissions = parseInt(o.unixPermissions, 8);
          }
          if (o.unixPermissions && o.unixPermissions & 16384) {
            o.dir = true;
          }
          if (o.dosPermissions && o.dosPermissions & 16) {
            o.dir = true;
          }
          if (o.dir) {
            name = forceTrailingSlash(name);
          }
          if (o.createFolders && (parent = parentFolder(name))) {
            folderAdd.call(this, parent, true);
          }
          if (o.dir || data === null || typeof data === "undefined") {
            o.base64 = false;
            o.binary = false;
            data = null;
            dataType = null;
          } else if (dataType === "string") {
            if (o.binary && !o.base64) {
              if (o.optimizedBinaryString !== true) {
                data = utils.string2binary(data);
              }
            }
          } else {
            o.base64 = false;
            o.binary = true;
            if (!dataType && !(data instanceof CompressedObject)) {
              throw new Error("The data of '" + name + "' is in an unsupported format !");
            }
            if (dataType === "arraybuffer") {
              data = utils.transformTo("uint8array", data);
            }
          }
          var object = new ZipObject(name, data, o);
          this.files[name] = object;
          return object;
        };
        var parentFolder = function(path) {
          if (path.slice(-1) == "/") {
            path = path.substring(0, path.length - 1);
          }
          var lastSlash = path.lastIndexOf("/");
          return lastSlash > 0 ? path.substring(0, lastSlash) : "";
        };
        var forceTrailingSlash = function(path) {
          if (path.slice(-1) != "/") {
            path += "/";
          }
          return path;
        };
        var folderAdd = function(name, createFolders) {
          createFolders = typeof createFolders !== "undefined" ? createFolders : false;
          name = forceTrailingSlash(name);
          if (!this.files[name]) {
            fileAdd.call(this, name, null, {
              dir: true,
              createFolders
            });
          }
          return this.files[name];
        };
        var generateCompressedObjectFrom = function(file, compression, compressionOptions) {
          var result = new CompressedObject(), content;
          if (file._data instanceof CompressedObject) {
            result.uncompressedSize = file._data.uncompressedSize;
            result.crc32 = file._data.crc32;
            if (result.uncompressedSize === 0 || file.dir) {
              compression = compressions["STORE"];
              result.compressedContent = "";
              result.crc32 = 0;
            } else if (file._data.compressionMethod === compression.magic) {
              result.compressedContent = file._data.getCompressedContent();
            } else {
              content = file._data.getContent();
              result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
            }
          } else {
            content = getBinaryData(file);
            if (!content || content.length === 0 || file.dir) {
              compression = compressions["STORE"];
              content = "";
            }
            result.uncompressedSize = content.length;
            result.crc32 = crc32(content);
            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
          }
          result.compressedSize = result.compressedContent.length;
          result.compressionMethod = compression.magic;
          return result;
        };
        var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
          var result = unixPermissions;
          if (!unixPermissions) {
            result = isDir ? 16893 : 33204;
          }
          return (result & 65535) << 16;
        };
        var generateDosExternalFileAttr = function(dosPermissions, isDir) {
          return (dosPermissions || 0) & 63;
        };
        var generateZipParts = function(name, file, compressedObject, offset, platform) {
          var data = compressedObject.compressedContent, utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment || "", utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, o = file.options, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir, date;
          if (file._initialMetadata.dir !== file.dir) {
            dir = file.dir;
          } else {
            dir = o.dir;
          }
          if (file._initialMetadata.date !== file.date) {
            date = file.date;
          } else {
            date = o.date;
          }
          var extFileAttr = 0;
          var versionMadeBy = 0;
          if (dir) {
            extFileAttr |= 16;
          }
          if (platform === "UNIX") {
            versionMadeBy = 798;
            extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
          } else {
            versionMadeBy = 20;
            extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
          }
          dosTime = date.getHours();
          dosTime = dosTime << 6;
          dosTime = dosTime | date.getMinutes();
          dosTime = dosTime << 5;
          dosTime = dosTime | date.getSeconds() / 2;
          dosDate = date.getFullYear() - 1980;
          dosDate = dosDate << 4;
          dosDate = dosDate | date.getMonth() + 1;
          dosDate = dosDate << 5;
          dosDate = dosDate | date.getDate();
          if (useUTF8ForFileName) {
            unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(utfEncodedFileName), 4) + utfEncodedFileName;
            extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
          }
          if (useUTF8ForComment) {
            unicodeCommentExtraField = decToHex(1, 1) + decToHex(this.crc32(utfEncodedComment), 4) + utfEncodedComment;
            extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
          }
          var header = "";
          header += "\n\0";
          header += useUTF8ForFileName || useUTF8ForComment ? "\0\b" : "\0\0";
          header += compressedObject.compressionMethod;
          header += decToHex(dosTime, 2);
          header += decToHex(dosDate, 2);
          header += decToHex(compressedObject.crc32, 4);
          header += decToHex(compressedObject.compressedSize, 4);
          header += decToHex(compressedObject.uncompressedSize, 4);
          header += decToHex(utfEncodedFileName.length, 2);
          header += decToHex(extraFields.length, 2);
          var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;
          var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(utfEncodedComment.length, 2) + "\0\0\0\0" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + utfEncodedFileName + extraFields + utfEncodedComment;
          return {
            fileRecord,
            dirRecord,
            compressedObject
          };
        };
        var out = {
          load: function(stream, options) {
            throw new Error("Load method is not defined. Is the file jszip-load.js included ?");
          },
          filter: function(search) {
            var result = [], filename, relativePath, file, fileClone;
            for (filename in this.files) {
              if (!this.files.hasOwnProperty(filename)) {
                continue;
              }
              file = this.files[filename];
              fileClone = new ZipObject(file.name, file._data, extend(file.options));
              relativePath = filename.slice(this.root.length, filename.length);
              if (filename.slice(0, this.root.length) === this.root && search(relativePath, fileClone)) {
                result.push(fileClone);
              }
            }
            return result;
          },
          file: function(name, data, o) {
            if (arguments.length === 1) {
              if (utils.isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                  return !file.dir && regexp.test(relativePath);
                });
              } else {
                return this.filter(function(relativePath, file) {
                  return !file.dir && relativePath === name;
                })[0] || null;
              }
            } else {
              name = this.root + name;
              fileAdd.call(this, name, data, o);
            }
            return this;
          },
          folder: function(arg) {
            if (!arg) {
              return this;
            }
            if (utils.isRegExp(arg)) {
              return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
              });
            }
            var name = this.root + arg;
            var newFolder = folderAdd.call(this, name);
            var ret = this.clone();
            ret.root = newFolder.name;
            return ret;
          },
          remove: function(name) {
            name = this.root + name;
            var file = this.files[name];
            if (!file) {
              if (name.slice(-1) != "/") {
                name += "/";
              }
              file = this.files[name];
            }
            if (file && !file.dir) {
              delete this.files[name];
            } else {
              var kids = this.filter(function(relativePath, file2) {
                return file2.name.slice(0, name.length) === name;
              });
              for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
              }
            }
            return this;
          },
          generate: function(options) {
            options = extend(options || {}, {
              base64: true,
              compression: "STORE",
              compressionOptions: null,
              type: "base64",
              platform: "DOS",
              comment: null,
              mimeType: "application/zip"
            });
            utils.checkSupport(options.type);
            if (options.platform === "darwin" || options.platform === "freebsd" || options.platform === "linux" || options.platform === "sunos") {
              options.platform = "UNIX";
            }
            if (options.platform === "win32") {
              options.platform = "DOS";
            }
            var zipData = [], localDirLength = 0, centralDirLength = 0, writer, i, utfEncodedComment = utils.transformTo("string", this.utf8encode(options.comment || this.comment || ""));
            for (var name in this.files) {
              if (!this.files.hasOwnProperty(name)) {
                continue;
              }
              var file = this.files[name];
              var compressionName = file.options.compression || options.compression.toUpperCase();
              var compression = compressions[compressionName];
              if (!compression) {
                throw new Error(compressionName + " is not a valid compression method !");
              }
              var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
              var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);
              var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform);
              localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
              centralDirLength += zipPart.dirRecord.length;
              zipData.push(zipPart);
            }
            var dirEnd = "";
            dirEnd = signature.CENTRAL_DIRECTORY_END + "\0\0\0\0" + decToHex(zipData.length, 2) + decToHex(zipData.length, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(utfEncodedComment.length, 2) + utfEncodedComment;
            var typeName = options.type.toLowerCase();
            if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
              writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);
            } else {
              writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);
            }
            for (i = 0; i < zipData.length; i++) {
              writer.append(zipData[i].fileRecord);
              writer.append(zipData[i].compressedObject.compressedContent);
            }
            for (i = 0; i < zipData.length; i++) {
              writer.append(zipData[i].dirRecord);
            }
            writer.append(dirEnd);
            var zip = writer.finalize();
            switch (options.type.toLowerCase()) {
              case "uint8array":
              case "arraybuffer":
              case "nodebuffer":
                return utils.transformTo(options.type.toLowerCase(), zip);
              case "blob":
                return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip), options.mimeType);
              case "base64":
                return options.base64 ? base64.encode(zip) : zip;
              default:
                return zip;
            }
          },
          crc32: function(input, crc) {
            return crc32(input, crc);
          },
          utf8encode: function(string) {
            return utils.transformTo("string", utf8.utf8encode(string));
          },
          utf8decode: function(input) {
            return utf8.utf8decode(input);
          }
        };
        module3.exports = out;
      }, { "./base64": 11, "./compressedObject": 12, "./compressions": 13, "./crc32": 14, "./defaults": 16, "./nodeBuffer": 21, "./signature": 24, "./stringWriter": 26, "./support": 27, "./uint8ArrayWriter": 29, "./utf8": 30, "./utils": 31 }], 24: [function(require2, module3, exports3) {
        "use strict";
        exports3.LOCAL_FILE_HEADER = "PK";
        exports3.CENTRAL_FILE_HEADER = "PK";
        exports3.CENTRAL_DIRECTORY_END = "PK";
        exports3.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
        exports3.ZIP64_CENTRAL_DIRECTORY_END = "PK";
        exports3.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 25: [function(require2, module3, exports3) {
        "use strict";
        var DataReader = require2("./dataReader");
        var utils = require2("./utils");
        function StringReader(data, optimizedBinaryString) {
          this.data = data;
          if (!optimizedBinaryString) {
            this.data = utils.string2binary(this.data);
          }
          this.length = this.data.length;
          this.index = 0;
        }
        StringReader.prototype = new DataReader();
        StringReader.prototype.byteAt = function(i) {
          return this.data.charCodeAt(i);
        };
        StringReader.prototype.lastIndexOfSignature = function(sig) {
          return this.data.lastIndexOf(sig);
        };
        StringReader.prototype.readData = function(size) {
          this.checkOffset(size);
          var result = this.data.slice(this.index, this.index + size);
          this.index += size;
          return result;
        };
        module3.exports = StringReader;
      }, { "./dataReader": 15, "./utils": 31 }], 26: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("./utils");
        var StringWriter = function() {
          this.data = [];
        };
        StringWriter.prototype = {
          append: function(input) {
            input = utils.transformTo("string", input);
            this.data.push(input);
          },
          finalize: function() {
            return this.data.join("");
          }
        };
        module3.exports = StringWriter;
      }, { "./utils": 31 }], 27: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          exports3.base64 = true;
          exports3.array = true;
          exports3.string = true;
          exports3.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
          exports3.nodebuffer = typeof Buffer !== "undefined";
          exports3.uint8array = typeof Uint8Array !== "undefined";
          if (typeof ArrayBuffer === "undefined") {
            exports3.blob = false;
          } else {
            var buffer = new ArrayBuffer(0);
            try {
              exports3.blob = new Blob([buffer], {
                type: "application/zip"
              }).size === 0;
            } catch (e) {
              try {
                var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                var builder = new Builder();
                builder.append(buffer);
                exports3.blob = builder.getBlob("application/zip").size === 0;
              } catch (e2) {
                exports3.blob = false;
              }
            }
          }
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 6 }], 28: [function(require2, module3, exports3) {
        "use strict";
        var DataReader = require2("./dataReader");
        function Uint8ArrayReader(data) {
          if (data) {
            this.data = data;
            this.length = this.data.length;
            this.index = 0;
          }
        }
        Uint8ArrayReader.prototype = new DataReader();
        Uint8ArrayReader.prototype.byteAt = function(i) {
          return this.data[i];
        };
        Uint8ArrayReader.prototype.lastIndexOfSignature = function(sig) {
          var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
          for (var i = this.length - 4; i >= 0; --i) {
            if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
              return i;
            }
          }
          return -1;
        };
        Uint8ArrayReader.prototype.readData = function(size) {
          this.checkOffset(size);
          if (size === 0) {
            return new Uint8Array(0);
          }
          var result = this.data.subarray(this.index, this.index + size);
          this.index += size;
          return result;
        };
        module3.exports = Uint8ArrayReader;
      }, { "./dataReader": 15 }], 29: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("./utils");
        var Uint8ArrayWriter = function(length) {
          this.data = new Uint8Array(length);
          this.index = 0;
        };
        Uint8ArrayWriter.prototype = {
          append: function(input) {
            if (input.length !== 0) {
              input = utils.transformTo("uint8array", input);
              this.data.set(input, this.index);
              this.index += input.length;
            }
          },
          finalize: function() {
            return this.data;
          }
        };
        module3.exports = Uint8ArrayWriter;
      }, { "./utils": 31 }], 30: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("./utils");
        var support = require2("./support");
        var nodeBuffer = require2("./nodeBuffer");
        var _utf8len = new Array(256);
        for (var i = 0; i < 256; i++) {
          _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        var string2buf = function(str) {
          var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
          }
          if (support.uint8array) {
            buf = new Uint8Array(buf_len);
          } else {
            buf = new Array(buf_len);
          }
          for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            if (c < 128) {
              buf[i2++] = c;
            } else if (c < 2048) {
              buf[i2++] = 192 | c >>> 6;
              buf[i2++] = 128 | c & 63;
            } else if (c < 65536) {
              buf[i2++] = 224 | c >>> 12;
              buf[i2++] = 128 | c >>> 6 & 63;
              buf[i2++] = 128 | c & 63;
            } else {
              buf[i2++] = 240 | c >>> 18;
              buf[i2++] = 128 | c >>> 12 & 63;
              buf[i2++] = 128 | c >>> 6 & 63;
              buf[i2++] = 128 | c & 63;
            }
          }
          return buf;
        };
        var utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
        var buf2string = function(buf) {
          var str, i2, out, c, c_len;
          var len = buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i2 = 0; i2 < len; ) {
            c = buf[i2++];
            if (c < 128) {
              utf16buf[out++] = c;
              continue;
            }
            c_len = _utf8len[c];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i2 += c_len - 1;
              continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i2 < len) {
              c = c << 6 | buf[i2++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c < 65536) {
              utf16buf[out++] = c;
            } else {
              c -= 65536;
              utf16buf[out++] = 55296 | c >> 10 & 1023;
              utf16buf[out++] = 56320 | c & 1023;
            }
          }
          if (utf16buf.length !== out) {
            if (utf16buf.subarray) {
              utf16buf = utf16buf.subarray(0, out);
            } else {
              utf16buf.length = out;
            }
          }
          return utils.applyFromCharCode(utf16buf);
        };
        exports3.utf8encode = function utf8encode(str) {
          if (support.nodebuffer) {
            return nodeBuffer(str, "utf-8");
          }
          return string2buf(str);
        };
        exports3.utf8decode = function utf8decode(buf) {
          if (support.nodebuffer) {
            return utils.transformTo("nodebuffer", buf).toString("utf-8");
          }
          buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
          var result = [], k = 0, len = buf.length, chunk = 65536;
          while (k < len) {
            var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
            if (support.uint8array) {
              result.push(buf2string(buf.subarray(k, nextBoundary)));
            } else {
              result.push(buf2string(buf.slice(k, nextBoundary)));
            }
            k = nextBoundary;
          }
          return result.join("");
        };
      }, { "./nodeBuffer": 21, "./support": 27, "./utils": 31 }], 31: [function(require2, module3, exports3) {
        "use strict";
        var support = require2("./support");
        var compressions = require2("./compressions");
        var nodeBuffer = require2("./nodeBuffer");
        exports3.string2binary = function(str) {
          var result = "";
          for (var i = 0; i < str.length; i++) {
            result += String.fromCharCode(str.charCodeAt(i) & 255);
          }
          return result;
        };
        exports3.arrayBuffer2Blob = function(buffer, mimeType) {
          exports3.checkSupport("blob");
          mimeType = mimeType || "application/zip";
          try {
            return new Blob([buffer], {
              type: mimeType
            });
          } catch (e) {
            try {
              var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
              var builder = new Builder();
              builder.append(buffer);
              return builder.getBlob(mimeType);
            } catch (e2) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        function identity(input) {
          return input;
        }
        function stringToArrayLike(str, array) {
          for (var i = 0; i < str.length; ++i) {
            array[i] = str.charCodeAt(i) & 255;
          }
          return array;
        }
        function arrayLikeToString(array) {
          var chunk = 65536;
          var result = [], len = array.length, type = exports3.getTypeOf(array), k = 0, canUseApply = true;
          try {
            switch (type) {
              case "uint8array":
                String.fromCharCode.apply(null, new Uint8Array(0));
                break;
              case "nodebuffer":
                String.fromCharCode.apply(null, nodeBuffer(0));
                break;
            }
          } catch (e) {
            canUseApply = false;
          }
          if (!canUseApply) {
            var resultStr = "";
            for (var i = 0; i < array.length; i++) {
              resultStr += String.fromCharCode(array[i]);
            }
            return resultStr;
          }
          while (k < len && chunk > 1) {
            try {
              if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
              } else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
              }
              k += chunk;
            } catch (e) {
              chunk = Math.floor(chunk / 2);
            }
          }
          return result.join("");
        }
        exports3.applyFromCharCode = arrayLikeToString;
        function arrayLikeToArrayLike(arrayFrom, arrayTo) {
          for (var i = 0; i < arrayFrom.length; i++) {
            arrayTo[i] = arrayFrom[i];
          }
          return arrayTo;
        }
        var transform = {};
        transform["string"] = {
          "string": identity,
          "array": function(input) {
            return stringToArrayLike(input, new Array(input.length));
          },
          "arraybuffer": function(input) {
            return transform["string"]["uint8array"](input).buffer;
          },
          "uint8array": function(input) {
            return stringToArrayLike(input, new Uint8Array(input.length));
          },
          "nodebuffer": function(input) {
            return stringToArrayLike(input, nodeBuffer(input.length));
          }
        };
        transform["array"] = {
          "string": arrayLikeToString,
          "array": identity,
          "arraybuffer": function(input) {
            return new Uint8Array(input).buffer;
          },
          "uint8array": function(input) {
            return new Uint8Array(input);
          },
          "nodebuffer": function(input) {
            return nodeBuffer(input);
          }
        };
        transform["arraybuffer"] = {
          "string": function(input) {
            return arrayLikeToString(new Uint8Array(input));
          },
          "array": function(input) {
            return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
          },
          "arraybuffer": identity,
          "uint8array": function(input) {
            return new Uint8Array(input);
          },
          "nodebuffer": function(input) {
            return nodeBuffer(new Uint8Array(input));
          }
        };
        transform["uint8array"] = {
          "string": arrayLikeToString,
          "array": function(input) {
            return arrayLikeToArrayLike(input, new Array(input.length));
          },
          "arraybuffer": function(input) {
            return input.buffer;
          },
          "uint8array": identity,
          "nodebuffer": function(input) {
            return nodeBuffer(input);
          }
        };
        transform["nodebuffer"] = {
          "string": arrayLikeToString,
          "array": function(input) {
            return arrayLikeToArrayLike(input, new Array(input.length));
          },
          "arraybuffer": function(input) {
            return transform["nodebuffer"]["uint8array"](input).buffer;
          },
          "uint8array": function(input) {
            return arrayLikeToArrayLike(input, new Uint8Array(input.length));
          },
          "nodebuffer": identity
        };
        exports3.transformTo = function(outputType, input) {
          if (!input) {
            input = "";
          }
          if (!outputType) {
            return input;
          }
          exports3.checkSupport(outputType);
          var inputType = exports3.getTypeOf(input);
          var result = transform[inputType][outputType](input);
          return result;
        };
        exports3.getTypeOf = function(input) {
          if (typeof input === "string") {
            return "string";
          }
          if (Object.prototype.toString.call(input) === "[object Array]") {
            return "array";
          }
          if (support.nodebuffer && nodeBuffer.test(input)) {
            return "nodebuffer";
          }
          if (support.uint8array && input instanceof Uint8Array) {
            return "uint8array";
          }
          if (support.arraybuffer && input instanceof ArrayBuffer) {
            return "arraybuffer";
          }
        };
        exports3.checkSupport = function(type) {
          var supported = support[type.toLowerCase()];
          if (!supported) {
            throw new Error(type + " is not supported by this browser");
          }
        };
        exports3.MAX_VALUE_16BITS = 65535;
        exports3.MAX_VALUE_32BITS = -1;
        exports3.pretty = function(str) {
          var res = "", code, i;
          for (i = 0; i < (str || "").length; i++) {
            code = str.charCodeAt(i);
            res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
          }
          return res;
        };
        exports3.findCompression = function(compressionMethod) {
          for (var method in compressions) {
            if (!compressions.hasOwnProperty(method)) {
              continue;
            }
            if (compressions[method].magic === compressionMethod) {
              return compressions[method];
            }
          }
          return null;
        };
        exports3.isRegExp = function(object) {
          return Object.prototype.toString.call(object) === "[object RegExp]";
        };
      }, { "./compressions": 13, "./nodeBuffer": 21, "./support": 27 }], 32: [function(require2, module3, exports3) {
        "use strict";
        var StringReader = require2("./stringReader");
        var NodeBufferReader = require2("./nodeBufferReader");
        var Uint8ArrayReader = require2("./uint8ArrayReader");
        var utils = require2("./utils");
        var sig = require2("./signature");
        var ZipEntry = require2("./zipEntry");
        var support = require2("./support");
        var jszipProto = require2("./object");
        function ZipEntries(data, loadOptions) {
          this.files = [];
          this.loadOptions = loadOptions;
          if (data) {
            this.load(data);
          }
        }
        ZipEntries.prototype = {
          checkSignature: function(expectedSignature) {
            var signature = this.reader.readString(4);
            if (signature !== expectedSignature) {
              throw new Error("Corrupted zip or bug : unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
            }
          },
          readBlockEndOfCentral: function() {
            this.diskNumber = this.reader.readInt(2);
            this.diskWithCentralDirStart = this.reader.readInt(2);
            this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
            this.centralDirRecords = this.reader.readInt(2);
            this.centralDirSize = this.reader.readInt(4);
            this.centralDirOffset = this.reader.readInt(4);
            this.zipCommentLength = this.reader.readInt(2);
            this.zipComment = this.reader.readString(this.zipCommentLength);
            this.zipComment = jszipProto.utf8decode(this.zipComment);
          },
          readBlockZip64EndOfCentral: function() {
            this.zip64EndOfCentralSize = this.reader.readInt(8);
            this.versionMadeBy = this.reader.readString(2);
            this.versionNeeded = this.reader.readInt(2);
            this.diskNumber = this.reader.readInt(4);
            this.diskWithCentralDirStart = this.reader.readInt(4);
            this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
            this.centralDirRecords = this.reader.readInt(8);
            this.centralDirSize = this.reader.readInt(8);
            this.centralDirOffset = this.reader.readInt(8);
            this.zip64ExtensibleData = {};
            var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
            while (index < extraDataSize) {
              extraFieldId = this.reader.readInt(2);
              extraFieldLength = this.reader.readInt(4);
              extraFieldValue = this.reader.readString(extraFieldLength);
              this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
              };
            }
          },
          readBlockZip64EndOfCentralLocator: function() {
            this.diskWithZip64CentralDirStart = this.reader.readInt(4);
            this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
            this.disksCount = this.reader.readInt(4);
            if (this.disksCount > 1) {
              throw new Error("Multi-volumes zip are not supported");
            }
          },
          readLocalFiles: function() {
            var i, file;
            for (i = 0; i < this.files.length; i++) {
              file = this.files[i];
              this.reader.setIndex(file.localHeaderOffset);
              this.checkSignature(sig.LOCAL_FILE_HEADER);
              file.readLocalPart(this.reader);
              file.handleUTF8();
              file.processAttributes();
            }
          },
          readCentralDir: function() {
            var file;
            this.reader.setIndex(this.centralDirOffset);
            while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
              file = new ZipEntry({
                zip64: this.zip64
              }, this.loadOptions);
              file.readCentralPart(this.reader);
              this.files.push(file);
            }
          },
          readEndOfCentral: function() {
            var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
            if (offset === -1) {
              var isGarbage = true;
              try {
                this.reader.setIndex(0);
                this.checkSignature(sig.LOCAL_FILE_HEADER);
                isGarbage = false;
              } catch (e) {
              }
              if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");
              } else {
                throw new Error("Corrupted zip : can't find end of central directory");
              }
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.CENTRAL_DIRECTORY_END);
            this.readBlockEndOfCentral();
            if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
              this.zip64 = true;
              offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
              if (offset === -1) {
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
              }
              this.reader.setIndex(offset);
              this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
              this.readBlockZip64EndOfCentralLocator();
              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
              this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
              this.readBlockZip64EndOfCentral();
            }
          },
          prepareReader: function(data) {
            var type = utils.getTypeOf(data);
            if (type === "string" && !support.uint8array) {
              this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);
            } else if (type === "nodebuffer") {
              this.reader = new NodeBufferReader(data);
            } else {
              this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data));
            }
          },
          load: function(data) {
            this.prepareReader(data);
            this.readEndOfCentral();
            this.readCentralDir();
            this.readLocalFiles();
          }
        };
        module3.exports = ZipEntries;
      }, { "./nodeBufferReader": 22, "./object": 23, "./signature": 24, "./stringReader": 25, "./support": 27, "./uint8ArrayReader": 28, "./utils": 31, "./zipEntry": 33 }], 33: [function(require2, module3, exports3) {
        "use strict";
        var StringReader = require2("./stringReader");
        var utils = require2("./utils");
        var CompressedObject = require2("./compressedObject");
        var jszipProto = require2("./object");
        var MADE_BY_DOS = 0;
        var MADE_BY_UNIX = 3;
        function ZipEntry(options, loadOptions) {
          this.options = options;
          this.loadOptions = loadOptions;
        }
        ZipEntry.prototype = {
          isEncrypted: function() {
            return (this.bitFlag & 1) === 1;
          },
          useUTF8: function() {
            return (this.bitFlag & 2048) === 2048;
          },
          prepareCompressedContent: function(reader, from, length) {
            return function() {
              var previousIndex = reader.index;
              reader.setIndex(from);
              var compressedFileData = reader.readData(length);
              reader.setIndex(previousIndex);
              return compressedFileData;
            };
          },
          prepareContent: function(reader, from, length, compression, uncompressedSize) {
            return function() {
              var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
              var uncompressedFileData = compression.uncompress(compressedFileData);
              if (uncompressedFileData.length !== uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
              }
              return uncompressedFileData;
            };
          },
          readLocalPart: function(reader) {
            var compression, localExtraFieldsLength;
            reader.skip(22);
            this.fileNameLength = reader.readInt(2);
            localExtraFieldsLength = reader.readInt(2);
            this.fileName = reader.readString(this.fileNameLength);
            reader.skip(localExtraFieldsLength);
            if (this.compressedSize == -1 || this.uncompressedSize == -1) {
              throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");
            }
            compression = utils.findCompression(this.compressionMethod);
            if (compression === null) {
              throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + this.fileName + ")");
            }
            this.decompressed = new CompressedObject();
            this.decompressed.compressedSize = this.compressedSize;
            this.decompressed.uncompressedSize = this.uncompressedSize;
            this.decompressed.crc32 = this.crc32;
            this.decompressed.compressionMethod = this.compressionMethod;
            this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
            this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
            if (this.loadOptions.checkCRC32) {
              this.decompressed = utils.transformTo("string", this.decompressed.getContent());
              if (jszipProto.crc32(this.decompressed) !== this.crc32) {
                throw new Error("Corrupted zip : CRC32 mismatch");
              }
            }
          },
          readCentralPart: function(reader) {
            this.versionMadeBy = reader.readInt(2);
            this.versionNeeded = reader.readInt(2);
            this.bitFlag = reader.readInt(2);
            this.compressionMethod = reader.readString(2);
            this.date = reader.readDate();
            this.crc32 = reader.readInt(4);
            this.compressedSize = reader.readInt(4);
            this.uncompressedSize = reader.readInt(4);
            this.fileNameLength = reader.readInt(2);
            this.extraFieldsLength = reader.readInt(2);
            this.fileCommentLength = reader.readInt(2);
            this.diskNumberStart = reader.readInt(2);
            this.internalFileAttributes = reader.readInt(2);
            this.externalFileAttributes = reader.readInt(4);
            this.localHeaderOffset = reader.readInt(4);
            if (this.isEncrypted()) {
              throw new Error("Encrypted zip are not supported");
            }
            this.fileName = reader.readString(this.fileNameLength);
            this.readExtraFields(reader);
            this.parseZIP64ExtraField(reader);
            this.fileComment = reader.readString(this.fileCommentLength);
          },
          processAttributes: function() {
            this.unixPermissions = null;
            this.dosPermissions = null;
            var madeBy = this.versionMadeBy >> 8;
            this.dir = this.externalFileAttributes & 16 ? true : false;
            if (madeBy === MADE_BY_DOS) {
              this.dosPermissions = this.externalFileAttributes & 63;
            }
            if (madeBy === MADE_BY_UNIX) {
              this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
            }
            if (!this.dir && this.fileName.slice(-1) === "/") {
              this.dir = true;
            }
          },
          parseZIP64ExtraField: function(reader) {
            if (!this.extraFields[1]) {
              return;
            }
            var extraReader = new StringReader(this.extraFields[1].value);
            if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
              this.uncompressedSize = extraReader.readInt(8);
            }
            if (this.compressedSize === utils.MAX_VALUE_32BITS) {
              this.compressedSize = extraReader.readInt(8);
            }
            if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
              this.localHeaderOffset = extraReader.readInt(8);
            }
            if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
              this.diskNumberStart = extraReader.readInt(4);
            }
          },
          readExtraFields: function(reader) {
            var start = reader.index, extraFieldId, extraFieldLength, extraFieldValue;
            this.extraFields = this.extraFields || {};
            while (reader.index < start + this.extraFieldsLength) {
              extraFieldId = reader.readInt(2);
              extraFieldLength = reader.readInt(2);
              extraFieldValue = reader.readString(extraFieldLength);
              this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
              };
            }
          },
          handleUTF8: function() {
            if (this.useUTF8()) {
              this.fileName = jszipProto.utf8decode(this.fileName);
              this.fileComment = jszipProto.utf8decode(this.fileComment);
            } else {
              var upath = this.findExtraFieldUnicodePath();
              if (upath !== null) {
                this.fileName = upath;
              }
              var ucomment = this.findExtraFieldUnicodeComment();
              if (ucomment !== null) {
                this.fileComment = ucomment;
              }
            }
          },
          findExtraFieldUnicodePath: function() {
            var upathField = this.extraFields[28789];
            if (upathField) {
              var extraReader = new StringReader(upathField.value);
              if (extraReader.readInt(1) !== 1) {
                return null;
              }
              if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
                return null;
              }
              return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));
            }
            return null;
          },
          findExtraFieldUnicodeComment: function() {
            var ucommentField = this.extraFields[25461];
            if (ucommentField) {
              var extraReader = new StringReader(ucommentField.value);
              if (extraReader.readInt(1) !== 1) {
                return null;
              }
              if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
                return null;
              }
              return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));
            }
            return null;
          }
        };
        module3.exports = ZipEntry;
      }, { "./compressedObject": 12, "./object": 23, "./stringReader": 25, "./utils": 31 }], 34: [function(require2, module3, exports3) {
        "use strict";
        var immediate = require2("immediate");
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module3.exports = exports3 = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e) {
              return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && typeof obj === "object" && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e) {
            out.status = "error";
            out.value = e;
          }
          return out;
        }
        exports3.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        exports3.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        exports3.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            allResolver(iterable[i], i);
          }
          return promise;
          function allResolver(value, i2) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i2] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        exports3.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            resolver(iterable[i]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "immediate": 9 }], 35: [function(require2, module3, exports3) {
        ;
        (function() {
          if (typeof module3 === "object" && module3.exports) {
            module3.exports = LRUCache;
          } else {
            this.LRUCache = LRUCache;
          }
          function hOP(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
          }
          function naiveLength() {
            return 1;
          }
          var didTypeWarning = false;
          function typeCheckKey(key) {
            if (!didTypeWarning && typeof key !== "string" && typeof key !== "number") {
              didTypeWarning = true;
              console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack);
            }
          }
          function LRUCache(options) {
            if (!(this instanceof LRUCache))
              return new LRUCache(options);
            if (typeof options === "number")
              options = { max: options };
            if (!options)
              options = {};
            this._max = options.max;
            if (!this._max || !(typeof this._max === "number") || this._max <= 0)
              this._max = Infinity;
            this._lengthCalculator = options.length || naiveLength;
            if (typeof this._lengthCalculator !== "function")
              this._lengthCalculator = naiveLength;
            this._allowStale = options.stale || false;
            this._maxAge = options.maxAge || null;
            this._dispose = options.dispose;
            this.reset();
          }
          Object.defineProperty(
            LRUCache.prototype,
            "max",
            {
              set: function(mL) {
                if (!mL || !(typeof mL === "number") || mL <= 0)
                  mL = Infinity;
                this._max = mL;
                if (this._length > this._max)
                  trim(this);
              },
              get: function() {
                return this._max;
              },
              enumerable: true
            }
          );
          Object.defineProperty(
            LRUCache.prototype,
            "lengthCalculator",
            {
              set: function(lC) {
                if (typeof lC !== "function") {
                  this._lengthCalculator = naiveLength;
                  this._length = this._itemCount;
                  for (var key in this._cache) {
                    this._cache[key].length = 1;
                  }
                } else {
                  this._lengthCalculator = lC;
                  this._length = 0;
                  for (var key in this._cache) {
                    this._cache[key].length = this._lengthCalculator(this._cache[key].value);
                    this._length += this._cache[key].length;
                  }
                }
                if (this._length > this._max)
                  trim(this);
              },
              get: function() {
                return this._lengthCalculator;
              },
              enumerable: true
            }
          );
          Object.defineProperty(
            LRUCache.prototype,
            "length",
            {
              get: function() {
                return this._length;
              },
              enumerable: true
            }
          );
          Object.defineProperty(
            LRUCache.prototype,
            "itemCount",
            {
              get: function() {
                return this._itemCount;
              },
              enumerable: true
            }
          );
          LRUCache.prototype.forEach = function(fn, thisp) {
            thisp = thisp || this;
            var i = 0;
            var itemCount = this._itemCount;
            for (var k = this._mru - 1; k >= 0 && i < itemCount; k--)
              if (this._lruList[k]) {
                i++;
                var hit = this._lruList[k];
                if (isStale(this, hit)) {
                  del(this, hit);
                  if (!this._allowStale)
                    hit = void 0;
                }
                if (hit) {
                  fn.call(thisp, hit.value, hit.key, this);
                }
              }
          };
          LRUCache.prototype.keys = function() {
            var keys = new Array(this._itemCount);
            var i = 0;
            for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
              if (this._lruList[k]) {
                var hit = this._lruList[k];
                keys[i++] = hit.key;
              }
            return keys;
          };
          LRUCache.prototype.values = function() {
            var values = new Array(this._itemCount);
            var i = 0;
            for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
              if (this._lruList[k]) {
                var hit = this._lruList[k];
                values[i++] = hit.value;
              }
            return values;
          };
          LRUCache.prototype.reset = function() {
            if (this._dispose && this._cache) {
              for (var k in this._cache) {
                this._dispose(k, this._cache[k].value);
              }
            }
            this._cache = /* @__PURE__ */ Object.create(null);
            this._lruList = /* @__PURE__ */ Object.create(null);
            this._mru = 0;
            this._lru = 0;
            this._length = 0;
            this._itemCount = 0;
          };
          LRUCache.prototype.dump = function() {
            var arr = [];
            var i = 0;
            for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--)
              if (this._lruList[k]) {
                var hit = this._lruList[k];
                if (!isStale(this, hit)) {
                  ++i;
                  arr.push({
                    k: hit.key,
                    v: hit.value,
                    e: hit.now + (hit.maxAge || 0)
                  });
                }
              }
            return arr;
          };
          LRUCache.prototype.dumpLru = function() {
            return this._lruList;
          };
          LRUCache.prototype.set = function(key, value, maxAge) {
            maxAge = maxAge || this._maxAge;
            typeCheckKey(key);
            var now = maxAge ? Date.now() : 0;
            var len = this._lengthCalculator(value);
            if (hOP(this._cache, key)) {
              if (len > this._max) {
                del(this, this._cache[key]);
                return false;
              }
              if (this._dispose)
                this._dispose(key, this._cache[key].value);
              this._cache[key].now = now;
              this._cache[key].maxAge = maxAge;
              this._cache[key].value = value;
              this._length += len - this._cache[key].length;
              this._cache[key].length = len;
              this.get(key);
              if (this._length > this._max)
                trim(this);
              return true;
            }
            var hit = new Entry(key, value, this._mru++, len, now, maxAge);
            if (hit.length > this._max) {
              if (this._dispose)
                this._dispose(key, value);
              return false;
            }
            this._length += hit.length;
            this._lruList[hit.lu] = this._cache[key] = hit;
            this._itemCount++;
            if (this._length > this._max)
              trim(this);
            return true;
          };
          LRUCache.prototype.has = function(key) {
            typeCheckKey(key);
            if (!hOP(this._cache, key))
              return false;
            var hit = this._cache[key];
            if (isStale(this, hit)) {
              return false;
            }
            return true;
          };
          LRUCache.prototype.get = function(key) {
            typeCheckKey(key);
            return get(this, key, true);
          };
          LRUCache.prototype.peek = function(key) {
            typeCheckKey(key);
            return get(this, key, false);
          };
          LRUCache.prototype.pop = function() {
            var hit = this._lruList[this._lru];
            del(this, hit);
            return hit || null;
          };
          LRUCache.prototype.del = function(key) {
            typeCheckKey(key);
            del(this, this._cache[key]);
          };
          LRUCache.prototype.load = function(arr) {
            this.reset();
            var now = Date.now();
            for (var l = arr.length - 1; l >= 0; l--) {
              var hit = arr[l];
              typeCheckKey(hit.k);
              var expiresAt = hit.e || 0;
              if (expiresAt === 0) {
                this.set(hit.k, hit.v);
              } else {
                var maxAge = expiresAt - now;
                if (maxAge > 0)
                  this.set(hit.k, hit.v, maxAge);
              }
            }
          };
          function get(self2, key, doUse) {
            typeCheckKey(key);
            var hit = self2._cache[key];
            if (hit) {
              if (isStale(self2, hit)) {
                del(self2, hit);
                if (!self2._allowStale)
                  hit = void 0;
              } else {
                if (doUse)
                  use(self2, hit);
              }
              if (hit)
                hit = hit.value;
            }
            return hit;
          }
          function isStale(self2, hit) {
            if (!hit || !hit.maxAge && !self2._maxAge)
              return false;
            var stale = false;
            var diff = Date.now() - hit.now;
            if (hit.maxAge) {
              stale = diff > hit.maxAge;
            } else {
              stale = self2._maxAge && diff > self2._maxAge;
            }
            return stale;
          }
          function use(self2, hit) {
            shiftLU(self2, hit);
            hit.lu = self2._mru++;
            self2._lruList[hit.lu] = hit;
          }
          function trim(self2) {
            while (self2._lru < self2._mru && self2._length > self2._max)
              del(self2, self2._lruList[self2._lru]);
          }
          function shiftLU(self2, hit) {
            delete self2._lruList[hit.lu];
            while (self2._lru < self2._mru && !self2._lruList[self2._lru])
              self2._lru++;
          }
          function del(self2, hit) {
            if (hit) {
              if (self2._dispose)
                self2._dispose(hit.key, hit.value);
              self2._length -= hit.length;
              self2._itemCount--;
              delete self2._cache[hit.key];
              shiftLU(self2, hit);
            }
          }
          function Entry(key, value, lu, length, now, maxAge) {
            this.key = key;
            this.value = value;
            this.lu = lu;
            this.length = length;
            this.now = now;
            if (maxAge)
              this.maxAge = maxAge;
          }
        })();
      }, {}], 36: [function(require2, module3, exports3) {
        var NUM_100K_SETS = 6;
        var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
        var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
        var A = 65;
        var I = 73;
        var O = 79;
        var V = 86;
        var Z = 90;
        exports3.forward = function(ll, accuracy) {
          accuracy = accuracy || 5;
          return encode(LLtoUTM({
            lat: ll[1],
            lon: ll[0]
          }), accuracy);
        };
        exports3.inverse = function(mgrs) {
          var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
          if (bbox.lat && bbox.lon) {
            return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
          }
          return [bbox.left, bbox.bottom, bbox.right, bbox.top];
        };
        exports3.toPoint = function(mgrs) {
          var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
          if (bbox.lat && bbox.lon) {
            return [bbox.lon, bbox.lat];
          }
          return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
        };
        function degToRad(deg) {
          return deg * (Math.PI / 180);
        }
        function radToDeg(rad) {
          return 180 * (rad / Math.PI);
        }
        function LLtoUTM(ll) {
          var Lat = ll.lat;
          var Long = ll.lon;
          var a = 6378137;
          var eccSquared = 669438e-8;
          var k0 = 0.9996;
          var LongOrigin;
          var eccPrimeSquared;
          var N, T, C, A2, M;
          var LatRad = degToRad(Lat);
          var LongRad = degToRad(Long);
          var LongOriginRad;
          var ZoneNumber;
          ZoneNumber = Math.floor((Long + 180) / 6) + 1;
          if (Long === 180) {
            ZoneNumber = 60;
          }
          if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
            ZoneNumber = 32;
          }
          if (Lat >= 72 && Lat < 84) {
            if (Long >= 0 && Long < 9) {
              ZoneNumber = 31;
            } else if (Long >= 9 && Long < 21) {
              ZoneNumber = 33;
            } else if (Long >= 21 && Long < 33) {
              ZoneNumber = 35;
            } else if (Long >= 33 && Long < 42) {
              ZoneNumber = 37;
            }
          }
          LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
          LongOriginRad = degToRad(LongOrigin);
          eccPrimeSquared = eccSquared / (1 - eccSquared);
          N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
          T = Math.tan(LatRad) * Math.tan(LatRad);
          C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
          A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);
          M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
          var UTMEasting = k0 * N * (A2 + (1 - T + C) * A2 * A2 * A2 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;
          var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T + 9 * C + 4 * C * C) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));
          if (Lat < 0) {
            UTMNorthing += 1e7;
          }
          return {
            northing: Math.round(UTMNorthing),
            easting: Math.round(UTMEasting),
            zoneNumber: ZoneNumber,
            zoneLetter: getLetterDesignator(Lat)
          };
        }
        function UTMtoLL(utm) {
          var UTMNorthing = utm.northing;
          var UTMEasting = utm.easting;
          var zoneLetter = utm.zoneLetter;
          var zoneNumber = utm.zoneNumber;
          if (zoneNumber < 0 || zoneNumber > 60) {
            return null;
          }
          var k0 = 0.9996;
          var a = 6378137;
          var eccSquared = 669438e-8;
          var eccPrimeSquared;
          var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
          var N1, T1, C1, R1, D, M;
          var LongOrigin;
          var mu, phi1Rad;
          var x = UTMEasting - 5e5;
          var y = UTMNorthing;
          if (zoneLetter < "N") {
            y -= 1e7;
          }
          LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
          eccPrimeSquared = eccSquared / (1 - eccSquared);
          M = y / k0;
          mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
          phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
          N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
          T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
          C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
          R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
          D = x / (N1 * k0);
          var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
          lat = radToDeg(lat);
          var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
          lon = LongOrigin + radToDeg(lon);
          var result;
          if (utm.accuracy) {
            var topRight = UTMtoLL({
              northing: utm.northing + utm.accuracy,
              easting: utm.easting + utm.accuracy,
              zoneLetter: utm.zoneLetter,
              zoneNumber: utm.zoneNumber
            });
            result = {
              top: topRight.lat,
              right: topRight.lon,
              bottom: lat,
              left: lon
            };
          } else {
            result = {
              lat,
              lon
            };
          }
          return result;
        }
        function getLetterDesignator(lat) {
          var LetterDesignator = "Z";
          if (84 >= lat && lat >= 72) {
            LetterDesignator = "X";
          } else if (72 > lat && lat >= 64) {
            LetterDesignator = "W";
          } else if (64 > lat && lat >= 56) {
            LetterDesignator = "V";
          } else if (56 > lat && lat >= 48) {
            LetterDesignator = "U";
          } else if (48 > lat && lat >= 40) {
            LetterDesignator = "T";
          } else if (40 > lat && lat >= 32) {
            LetterDesignator = "S";
          } else if (32 > lat && lat >= 24) {
            LetterDesignator = "R";
          } else if (24 > lat && lat >= 16) {
            LetterDesignator = "Q";
          } else if (16 > lat && lat >= 8) {
            LetterDesignator = "P";
          } else if (8 > lat && lat >= 0) {
            LetterDesignator = "N";
          } else if (0 > lat && lat >= -8) {
            LetterDesignator = "M";
          } else if (-8 > lat && lat >= -16) {
            LetterDesignator = "L";
          } else if (-16 > lat && lat >= -24) {
            LetterDesignator = "K";
          } else if (-24 > lat && lat >= -32) {
            LetterDesignator = "J";
          } else if (-32 > lat && lat >= -40) {
            LetterDesignator = "H";
          } else if (-40 > lat && lat >= -48) {
            LetterDesignator = "G";
          } else if (-48 > lat && lat >= -56) {
            LetterDesignator = "F";
          } else if (-56 > lat && lat >= -64) {
            LetterDesignator = "E";
          } else if (-64 > lat && lat >= -72) {
            LetterDesignator = "D";
          } else if (-72 > lat && lat >= -80) {
            LetterDesignator = "C";
          }
          return LetterDesignator;
        }
        function encode(utm, accuracy) {
          var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
          return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
        }
        function get100kID(easting, northing, zoneNumber) {
          var setParm = get100kSetForZone(zoneNumber);
          var setColumn = Math.floor(easting / 1e5);
          var setRow = Math.floor(northing / 1e5) % 20;
          return getLetter100kID(setColumn, setRow, setParm);
        }
        function get100kSetForZone(i) {
          var setParm = i % NUM_100K_SETS;
          if (setParm === 0) {
            setParm = NUM_100K_SETS;
          }
          return setParm;
        }
        function getLetter100kID(column, row, parm) {
          var index = parm - 1;
          var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
          var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
          var colInt = colOrigin + column - 1;
          var rowInt = rowOrigin + row;
          var rollover = false;
          if (colInt > Z) {
            colInt = colInt - Z + A - 1;
            rollover = true;
          }
          if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
            colInt++;
          }
          if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
            colInt++;
            if (colInt === I) {
              colInt++;
            }
          }
          if (colInt > Z) {
            colInt = colInt - Z + A - 1;
          }
          if (rowInt > V) {
            rowInt = rowInt - V + A - 1;
            rollover = true;
          } else {
            rollover = false;
          }
          if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
            rowInt++;
          }
          if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
            rowInt++;
            if (rowInt === I) {
              rowInt++;
            }
          }
          if (rowInt > V) {
            rowInt = rowInt - V + A - 1;
          }
          var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
          return twoLetter;
        }
        function decode(mgrsString) {
          if (mgrsString && mgrsString.length === 0) {
            throw "MGRSPoint coverting from nothing";
          }
          var length = mgrsString.length;
          var hunK = null;
          var sb = "";
          var testChar;
          var i = 0;
          while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
            if (i >= 2) {
              throw "MGRSPoint bad conversion from: " + mgrsString;
            }
            sb += testChar;
            i++;
          }
          var zoneNumber = parseInt(sb, 10);
          if (i === 0 || i + 3 > length) {
            throw "MGRSPoint bad conversion from: " + mgrsString;
          }
          var zoneLetter = mgrsString.charAt(i++);
          if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
            throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
          }
          hunK = mgrsString.substring(i, i += 2);
          var set = get100kSetForZone(zoneNumber);
          var east100k = getEastingFromChar(hunK.charAt(0), set);
          var north100k = getNorthingFromChar(hunK.charAt(1), set);
          while (north100k < getMinNorthing(zoneLetter)) {
            north100k += 2e6;
          }
          var remainder = length - i;
          if (remainder % 2 !== 0) {
            throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
          }
          var sep = remainder / 2;
          var sepEasting = 0;
          var sepNorthing = 0;
          var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
          if (sep > 0) {
            accuracyBonus = 1e5 / Math.pow(10, sep);
            sepEastingString = mgrsString.substring(i, i + sep);
            sepEasting = parseFloat(sepEastingString) * accuracyBonus;
            sepNorthingString = mgrsString.substring(i + sep);
            sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
          }
          easting = sepEasting + east100k;
          northing = sepNorthing + north100k;
          return {
            easting,
            northing,
            zoneLetter,
            zoneNumber,
            accuracy: accuracyBonus
          };
        }
        function getEastingFromChar(e, set) {
          var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
          var eastingValue = 1e5;
          var rewindMarker = false;
          while (curCol !== e.charCodeAt(0)) {
            curCol++;
            if (curCol === I) {
              curCol++;
            }
            if (curCol === O) {
              curCol++;
            }
            if (curCol > Z) {
              if (rewindMarker) {
                throw "Bad character: " + e;
              }
              curCol = A;
              rewindMarker = true;
            }
            eastingValue += 1e5;
          }
          return eastingValue;
        }
        function getNorthingFromChar(n, set) {
          if (n > "V") {
            throw "MGRSPoint given invalid Northing " + n;
          }
          var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
          var northingValue = 0;
          var rewindMarker = false;
          while (curRow !== n.charCodeAt(0)) {
            curRow++;
            if (curRow === I) {
              curRow++;
            }
            if (curRow === O) {
              curRow++;
            }
            if (curRow > V) {
              if (rewindMarker) {
                throw "Bad character: " + n;
              }
              curRow = A;
              rewindMarker = true;
            }
            northingValue += 1e5;
          }
          return northingValue;
        }
        function getMinNorthing(zoneLetter) {
          var northing;
          switch (zoneLetter) {
            case "C":
              northing = 11e5;
              break;
            case "D":
              northing = 2e6;
              break;
            case "E":
              northing = 28e5;
              break;
            case "F":
              northing = 37e5;
              break;
            case "G":
              northing = 46e5;
              break;
            case "H":
              northing = 55e5;
              break;
            case "J":
              northing = 64e5;
              break;
            case "K":
              northing = 73e5;
              break;
            case "L":
              northing = 82e5;
              break;
            case "M":
              northing = 91e5;
              break;
            case "N":
              northing = 0;
              break;
            case "P":
              northing = 8e5;
              break;
            case "Q":
              northing = 17e5;
              break;
            case "R":
              northing = 26e5;
              break;
            case "S":
              northing = 35e5;
              break;
            case "T":
              northing = 44e5;
              break;
            case "U":
              northing = 53e5;
              break;
            case "V":
              northing = 62e5;
              break;
            case "W":
              northing = 7e6;
              break;
            case "X":
              northing = 79e5;
              break;
            default:
              northing = -1;
          }
          if (northing >= 0) {
            return northing;
          } else {
            throw "Invalid zone letter: " + zoneLetter;
          }
        }
      }, {}], 37: [function(require2, module3, exports3) {
        "use strict";
        var assign = require2("./lib/utils/common").assign;
        var deflate = require2("./lib/deflate");
        var inflate = require2("./lib/inflate");
        var constants = require2("./lib/zlib/constants");
        var pako = {};
        assign(pako, deflate, inflate, constants);
        module3.exports = pako;
      }, { "./lib/deflate": 38, "./lib/inflate": 39, "./lib/utils/common": 40, "./lib/zlib/constants": 43 }], 38: [function(require2, module3, exports3) {
        "use strict";
        var zlib_deflate = require2("./zlib/deflate.js");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var msg = require2("./zlib/messages");
        var zstream = require2("./zlib/zstream");
        var toString = Object.prototype.toString;
        var Z_NO_FLUSH = 0;
        var Z_FINISH = 4;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_SYNC_FLUSH = 2;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_DEFLATED = 8;
        var Deflate = function(options) {
          this.options = utils.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
          } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new zstream();
          this.strm.avail_out = 0;
          var status = zlib_deflate.deflateInit2(
            this.strm,
            opt.level,
            opt.method,
            opt.windowBits,
            opt.memLevel,
            opt.strategy
          );
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          if (opt.header) {
            zlib_deflate.deflateSetHeader(this.strm, opt.header);
          }
        };
        Deflate.prototype.push = function(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var status, _mode;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = strings.string2buf(data);
          } else if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_deflate.deflate(strm, _mode);
            if (status !== Z_STREAM_END && status !== Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
          if (_mode === Z_FINISH) {
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (_mode === Z_SYNC_FLUSH) {
            this.onEnd(Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Deflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Deflate.prototype.onEnd = function(status) {
          if (status === Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function deflate(input, options) {
          var deflator = new Deflate(options);
          deflator.push(input, true);
          if (deflator.err) {
            throw deflator.msg;
          }
          return deflator.result;
        }
        function deflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return deflate(input, options);
        }
        function gzip(input, options) {
          options = options || {};
          options.gzip = true;
          return deflate(input, options);
        }
        exports3.Deflate = Deflate;
        exports3.deflate = deflate;
        exports3.deflateRaw = deflateRaw;
        exports3.gzip = gzip;
      }, { "./utils/common": 40, "./utils/strings": 41, "./zlib/deflate.js": 45, "./zlib/messages": 50, "./zlib/zstream": 52 }], 39: [function(require2, module3, exports3) {
        "use strict";
        var zlib_inflate = require2("./zlib/inflate.js");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var c = require2("./zlib/constants");
        var msg = require2("./zlib/messages");
        var zstream = require2("./zlib/zstream");
        var gzheader = require2("./zlib/gzheader");
        var toString = Object.prototype.toString;
        var Inflate = function(options) {
          this.options = utils.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
              opt.windowBits = -15;
            }
          }
          if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
          }
          if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
              opt.windowBits |= 15;
            }
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new zstream();
          this.strm.avail_out = 0;
          var status = zlib_inflate.inflateInit2(
            this.strm,
            opt.windowBits
          );
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
          this.header = new gzheader();
          zlib_inflate.inflateGetHeader(this.strm, this.header);
        };
        Inflate.prototype.push = function(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var status, _mode;
          var next_out_utf8, tail, utf8str;
          var allowBufError = false;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = strings.binstring2buf(data);
          } else if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
            if (status === c.Z_BUF_ERROR && allowBufError === true) {
              status = c.Z_OK;
              allowBufError = false;
            }
            if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.next_out) {
              if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                if (this.options.to === "string") {
                  next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                  tail = strm.next_out - next_out_utf8;
                  utf8str = strings.buf2string(strm.output, next_out_utf8);
                  strm.next_out = tail;
                  strm.avail_out = chunkSize - tail;
                  if (tail) {
                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                  }
                  this.onData(utf8str);
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
              }
            }
            if (strm.avail_in === 0 && strm.avail_out === 0) {
              allowBufError = true;
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
          if (status === c.Z_STREAM_END) {
            _mode = c.Z_FINISH;
          }
          if (_mode === c.Z_FINISH) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === c.Z_OK;
          }
          if (_mode === c.Z_SYNC_FLUSH) {
            this.onEnd(c.Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Inflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Inflate.prototype.onEnd = function(status) {
          if (status === c.Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function inflate(input, options) {
          var inflator = new Inflate(options);
          inflator.push(input, true);
          if (inflator.err) {
            throw inflator.msg;
          }
          return inflator.result;
        }
        function inflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return inflate(input, options);
        }
        exports3.Inflate = Inflate;
        exports3.inflate = inflate;
        exports3.inflateRaw = inflateRaw;
        exports3.ungzip = inflate;
      }, { "./utils/common": 40, "./utils/strings": 41, "./zlib/constants": 43, "./zlib/gzheader": 46, "./zlib/inflate.js": 48, "./zlib/messages": 50, "./zlib/zstream": 52 }], 40: [function(require2, module3, exports3) {
        "use strict";
        var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        exports3.assign = function(obj) {
          var sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            var source = sources.shift();
            if (!source) {
              continue;
            }
            if (typeof source !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (var p in source) {
              if (source.hasOwnProperty(p)) {
                obj[p] = source[p];
              }
            }
          }
          return obj;
        };
        exports3.shrinkBuf = function(buf, size) {
          if (buf.length === size) {
            return buf;
          }
          if (buf.subarray) {
            return buf.subarray(0, size);
          }
          buf.length = size;
          return buf;
        };
        var fnTyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
              dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
              return;
            }
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            len = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              len += chunks[i].length;
            }
            result = new Uint8Array(len);
            pos = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              chunk = chunks[i];
              result.set(chunk, pos);
              pos += chunk.length;
            }
            return result;
          }
        };
        var fnUntyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
          }
        };
        exports3.setTyped = function(on) {
          if (on) {
            exports3.Buf8 = Uint8Array;
            exports3.Buf16 = Uint16Array;
            exports3.Buf32 = Int32Array;
            exports3.assign(exports3, fnTyped);
          } else {
            exports3.Buf8 = Array;
            exports3.Buf16 = Array;
            exports3.Buf32 = Array;
            exports3.assign(exports3, fnUntyped);
          }
        };
        exports3.setTyped(TYPED_OK);
      }, {}], 41: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("./common");
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (__) {
          STR_APPLY_OK = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var _utf8len = new utils.Buf8(256);
        for (var q = 0; q < 256; q++) {
          _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        exports3.string2buf = function(str) {
          var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
          }
          buf = new utils.Buf8(buf_len);
          for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            if (c < 128) {
              buf[i++] = c;
            } else if (c < 2048) {
              buf[i++] = 192 | c >>> 6;
              buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
              buf[i++] = 224 | c >>> 12;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            } else {
              buf[i++] = 240 | c >>> 18;
              buf[i++] = 128 | c >>> 12 & 63;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            }
          }
          return buf;
        };
        function buf2binstring(buf, len) {
          if (len < 65537) {
            if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
              return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
          }
          var result = "";
          for (var i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
          }
          return result;
        }
        exports3.buf2binstring = function(buf) {
          return buf2binstring(buf, buf.length);
        };
        exports3.binstring2buf = function(str) {
          var buf = new utils.Buf8(str.length);
          for (var i = 0, len = buf.length; i < len; i++) {
            buf[i] = str.charCodeAt(i);
          }
          return buf;
        };
        exports3.buf2string = function(buf, max) {
          var i, out, c, c_len;
          var len = max || buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i = 0; i < len; ) {
            c = buf[i++];
            if (c < 128) {
              utf16buf[out++] = c;
              continue;
            }
            c_len = _utf8len[c];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i += c_len - 1;
              continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
              c = c << 6 | buf[i++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c < 65536) {
              utf16buf[out++] = c;
            } else {
              c -= 65536;
              utf16buf[out++] = 55296 | c >> 10 & 1023;
              utf16buf[out++] = 56320 | c & 1023;
            }
          }
          return buf2binstring(utf16buf, out);
        };
        exports3.utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
      }, { "./common": 40 }], 42: [function(require2, module3, exports3) {
        "use strict";
        function adler32(adler, buf, len, pos) {
          var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
          while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
              s1 = s1 + buf[pos++] | 0;
              s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
          }
          return s1 | s2 << 16 | 0;
        }
        module3.exports = adler32;
      }, {}], 43: [function(require2, module3, exports3) {
        module3.exports = {
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_BUF_ERROR: -5,
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          Z_BINARY: 0,
          Z_TEXT: 1,
          Z_UNKNOWN: 2,
          Z_DEFLATED: 8
        };
      }, {}], 44: [function(require2, module3, exports3) {
        "use strict";
        function makeTable() {
          var c, table = [];
          for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
              c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
          }
          return table;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
          var t = crcTable, end = pos + len;
          crc = crc ^ -1;
          for (var i = pos; i < end; i++) {
            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
          }
          return crc ^ -1;
        }
        module3.exports = crc32;
      }, {}], 45: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var trees = require2("./trees");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var msg = require2("./messages");
        var Z_NO_FLUSH = 0;
        var Z_PARTIAL_FLUSH = 1;
        var Z_FULL_FLUSH = 3;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_BUF_ERROR = -5;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_FILTERED = 1;
        var Z_HUFFMAN_ONLY = 2;
        var Z_RLE = 3;
        var Z_FIXED = 4;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_UNKNOWN = 2;
        var Z_DEFLATED = 8;
        var MAX_MEM_LEVEL = 9;
        var MAX_WBITS = 15;
        var DEF_MEM_LEVEL = 8;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        var PRESET_DICT = 32;
        var INIT_STATE = 42;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;
        var BS_NEED_MORE = 1;
        var BS_BLOCK_DONE = 2;
        var BS_FINISH_STARTED = 3;
        var BS_FINISH_DONE = 4;
        var OS_CODE = 3;
        function err(strm, errorCode) {
          strm.msg = msg[errorCode];
          return errorCode;
        }
        function rank(f) {
          return (f << 1) - (f > 4 ? 9 : 0);
        }
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        function flush_pending(strm) {
          var s = strm.state;
          var len = s.pending;
          if (len > strm.avail_out) {
            len = strm.avail_out;
          }
          if (len === 0) {
            return;
          }
          utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
          strm.next_out += len;
          s.pending_out += len;
          strm.total_out += len;
          strm.avail_out -= len;
          s.pending -= len;
          if (s.pending === 0) {
            s.pending_out = 0;
          }
        }
        function flush_block_only(s, last) {
          trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
          s.block_start = s.strstart;
          flush_pending(s.strm);
        }
        function put_byte(s, b) {
          s.pending_buf[s.pending++] = b;
        }
        function putShortMSB(s, b) {
          s.pending_buf[s.pending++] = b >>> 8 & 255;
          s.pending_buf[s.pending++] = b & 255;
        }
        function read_buf(strm, buf, start, size) {
          var len = strm.avail_in;
          if (len > size) {
            len = size;
          }
          if (len === 0) {
            return 0;
          }
          strm.avail_in -= len;
          utils.arraySet(buf, strm.input, strm.next_in, len, start);
          if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
          } else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
          }
          strm.next_in += len;
          strm.total_in += len;
          return len;
        }
        function longest_match(s, cur_match) {
          var chain_length = s.max_chain_length;
          var scan = s.strstart;
          var match;
          var len;
          var best_len = s.prev_length;
          var nice_match = s.nice_match;
          var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
          var _win = s.window;
          var wmask = s.w_mask;
          var prev = s.prev;
          var strend = s.strstart + MAX_MATCH;
          var scan_end1 = _win[scan + best_len - 1];
          var scan_end = _win[scan + best_len];
          if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
          }
          if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
          }
          do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
              continue;
            }
            scan += 2;
            match++;
            do {
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
              s.match_start = cur_match;
              best_len = len;
              if (len >= nice_match) {
                break;
              }
              scan_end1 = _win[scan + best_len - 1];
              scan_end = _win[scan + best_len];
            }
          } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
          if (best_len <= s.lookahead) {
            return best_len;
          }
          return s.lookahead;
        }
        function fill_window(s) {
          var _w_size = s.w_size;
          var p, n, m, more, str;
          do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
              utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
              s.match_start -= _w_size;
              s.strstart -= _w_size;
              s.block_start -= _w_size;
              n = s.hash_size;
              p = n;
              do {
                m = s.head[--p];
                s.head[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              n = _w_size;
              p = n;
              do {
                m = s.prev[--p];
                s.prev[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              more += _w_size;
            }
            if (s.strm.avail_in === 0) {
              break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
              str = s.strstart - s.insert;
              s.ins_h = s.window[str];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
              while (s.insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
                s.insert--;
                if (s.lookahead + s.insert < MIN_MATCH) {
                  break;
                }
              }
            }
          } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
        }
        function deflate_stored(s, flush) {
          var max_block_size = 65535;
          if (max_block_size > s.pending_buf_size - 5) {
            max_block_size = s.pending_buf_size - 5;
          }
          for (; ; ) {
            if (s.lookahead <= 1) {
              fill_window(s);
              if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.strstart += s.lookahead;
            s.lookahead = 0;
            var max_start = s.block_start + max_block_size;
            if (s.strstart === 0 || s.strstart >= max_start) {
              s.lookahead = s.strstart - max_start;
              s.strstart = max_start;
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.strstart > s.block_start) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_NEED_MORE;
        }
        function deflate_fast(s, flush) {
          var hash_head;
          var bflush;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                s.match_length--;
                do {
                  s.strstart++;
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                } while (--s.match_length !== 0);
                s.strstart++;
              } else {
                s.strstart += s.match_length;
                s.match_length = 0;
                s.ins_h = s.window[s.strstart];
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
              }
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_slow(s, flush) {
          var hash_head;
          var bflush;
          var max_insert;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
              if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                s.match_length = MIN_MATCH - 1;
              }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
              max_insert = s.strstart + s.lookahead - MIN_MATCH;
              bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
              s.lookahead -= s.prev_length - 1;
              s.prev_length -= 2;
              do {
                if (++s.strstart <= max_insert) {
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                }
              } while (--s.prev_length !== 0);
              s.match_available = 0;
              s.match_length = MIN_MATCH - 1;
              s.strstart++;
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            } else if (s.match_available) {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
              if (bflush) {
                flush_block_only(s, false);
              }
              s.strstart++;
              s.lookahead--;
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            } else {
              s.match_available = 1;
              s.strstart++;
              s.lookahead--;
            }
          }
          if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_rle(s, flush) {
          var bflush;
          var prev;
          var scan, strend;
          var _win = s.window;
          for (; ; ) {
            if (s.lookahead <= MAX_MATCH) {
              fill_window(s);
              if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
              scan = s.strstart - 1;
              prev = _win[scan];
              if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s.strstart + MAX_MATCH;
                do {
                } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                s.match_length = MAX_MATCH - (strend - scan);
                if (s.match_length > s.lookahead) {
                  s.match_length = s.lookahead;
                }
              }
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              s.strstart += s.match_length;
              s.match_length = 0;
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_huff(s, flush) {
          var bflush;
          for (; ; ) {
            if (s.lookahead === 0) {
              fill_window(s);
              if (s.lookahead === 0) {
                if (flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                break;
              }
            }
            s.match_length = 0;
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        var Config = function(good_length, max_lazy, nice_length, max_chain, func) {
          this.good_length = good_length;
          this.max_lazy = max_lazy;
          this.nice_length = nice_length;
          this.max_chain = max_chain;
          this.func = func;
        };
        var configuration_table;
        configuration_table = [
          new Config(0, 0, 0, 0, deflate_stored),
          new Config(4, 4, 8, 4, deflate_fast),
          new Config(4, 5, 16, 8, deflate_fast),
          new Config(4, 6, 32, 32, deflate_fast),
          new Config(4, 4, 16, 16, deflate_slow),
          new Config(8, 16, 32, 32, deflate_slow),
          new Config(8, 16, 128, 128, deflate_slow),
          new Config(8, 32, 128, 256, deflate_slow),
          new Config(32, 128, 258, 1024, deflate_slow),
          new Config(32, 258, 258, 4096, deflate_slow)
        ];
        function lm_init(s) {
          s.window_size = 2 * s.w_size;
          zero(s.head);
          s.max_lazy_match = configuration_table[s.level].max_lazy;
          s.good_match = configuration_table[s.level].good_length;
          s.nice_match = configuration_table[s.level].nice_length;
          s.max_chain_length = configuration_table[s.level].max_chain;
          s.strstart = 0;
          s.block_start = 0;
          s.lookahead = 0;
          s.insert = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          s.ins_h = 0;
        }
        function DeflateState() {
          this.strm = null;
          this.status = 0;
          this.pending_buf = null;
          this.pending_buf_size = 0;
          this.pending_out = 0;
          this.pending = 0;
          this.wrap = 0;
          this.gzhead = null;
          this.gzindex = 0;
          this.method = Z_DEFLATED;
          this.last_flush = -1;
          this.w_size = 0;
          this.w_bits = 0;
          this.w_mask = 0;
          this.window = null;
          this.window_size = 0;
          this.prev = null;
          this.head = null;
          this.ins_h = 0;
          this.hash_size = 0;
          this.hash_bits = 0;
          this.hash_mask = 0;
          this.hash_shift = 0;
          this.block_start = 0;
          this.match_length = 0;
          this.prev_match = 0;
          this.match_available = 0;
          this.strstart = 0;
          this.match_start = 0;
          this.lookahead = 0;
          this.prev_length = 0;
          this.max_chain_length = 0;
          this.max_lazy_match = 0;
          this.level = 0;
          this.strategy = 0;
          this.good_match = 0;
          this.nice_match = 0;
          this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
          this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
          this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
          zero(this.dyn_ltree);
          zero(this.dyn_dtree);
          zero(this.bl_tree);
          this.l_desc = null;
          this.d_desc = null;
          this.bl_desc = null;
          this.bl_count = new utils.Buf16(MAX_BITS + 1);
          this.heap = new utils.Buf16(2 * L_CODES + 1);
          zero(this.heap);
          this.heap_len = 0;
          this.heap_max = 0;
          this.depth = new utils.Buf16(2 * L_CODES + 1);
          zero(this.depth);
          this.l_buf = 0;
          this.lit_bufsize = 0;
          this.last_lit = 0;
          this.d_buf = 0;
          this.opt_len = 0;
          this.static_len = 0;
          this.matches = 0;
          this.insert = 0;
          this.bi_buf = 0;
          this.bi_valid = 0;
        }
        function deflateResetKeep(strm) {
          var s;
          if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.total_in = strm.total_out = 0;
          strm.data_type = Z_UNKNOWN;
          s = strm.state;
          s.pending = 0;
          s.pending_out = 0;
          if (s.wrap < 0) {
            s.wrap = -s.wrap;
          }
          s.status = s.wrap ? INIT_STATE : BUSY_STATE;
          strm.adler = s.wrap === 2 ? 0 : 1;
          s.last_flush = Z_NO_FLUSH;
          trees._tr_init(s);
          return Z_OK;
        }
        function deflateReset(strm) {
          var ret = deflateResetKeep(strm);
          if (ret === Z_OK) {
            lm_init(strm.state);
          }
          return ret;
        }
        function deflateSetHeader(strm, head) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          if (strm.state.wrap !== 2) {
            return Z_STREAM_ERROR;
          }
          strm.state.gzhead = head;
          return Z_OK;
        }
        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          var wrap = 1;
          if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
          }
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
          }
          if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
          }
          if (windowBits === 8) {
            windowBits = 9;
          }
          var s = new DeflateState();
          strm.state = s;
          s.strm = strm;
          s.wrap = wrap;
          s.gzhead = null;
          s.w_bits = windowBits;
          s.w_size = 1 << s.w_bits;
          s.w_mask = s.w_size - 1;
          s.hash_bits = memLevel + 7;
          s.hash_size = 1 << s.hash_bits;
          s.hash_mask = s.hash_size - 1;
          s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
          s.window = new utils.Buf8(s.w_size * 2);
          s.head = new utils.Buf16(s.hash_size);
          s.prev = new utils.Buf16(s.w_size);
          s.lit_bufsize = 1 << memLevel + 6;
          s.pending_buf_size = s.lit_bufsize * 4;
          s.pending_buf = new utils.Buf8(s.pending_buf_size);
          s.d_buf = s.lit_bufsize >> 1;
          s.l_buf = (1 + 2) * s.lit_bufsize;
          s.level = level;
          s.strategy = strategy;
          s.method = method;
          return deflateReset(strm);
        }
        function deflateInit(strm, level) {
          return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
        }
        function deflate(strm, flush) {
          var old_flush, s;
          var beg, val;
          if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
          }
          s = strm.state;
          if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
          }
          s.strm = strm;
          old_flush = s.last_flush;
          s.last_flush = flush;
          if (s.status === INIT_STATE) {
            if (s.wrap === 2) {
              strm.adler = 0;
              put_byte(s, 31);
              put_byte(s, 139);
              put_byte(s, 8);
              if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
              } else {
                put_byte(
                  s,
                  (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                );
                put_byte(s, s.gzhead.time & 255);
                put_byte(s, s.gzhead.time >> 8 & 255);
                put_byte(s, s.gzhead.time >> 16 & 255);
                put_byte(s, s.gzhead.time >> 24 & 255);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 255);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                  put_byte(s, s.gzhead.extra.length & 255);
                  put_byte(s, s.gzhead.extra.length >> 8 & 255);
                }
                if (s.gzhead.hcrc) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
              }
            } else {
              var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
              var level_flags = -1;
              if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
              } else if (s.level < 6) {
                level_flags = 1;
              } else if (s.level === 6) {
                level_flags = 2;
              } else {
                level_flags = 3;
              }
              header |= level_flags << 6;
              if (s.strstart !== 0) {
                header |= PRESET_DICT;
              }
              header += 31 - header % 31;
              s.status = BUSY_STATE;
              putShortMSB(s, header);
              if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
              }
              strm.adler = 1;
            }
          }
          if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
              beg = s.pending;
              while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    break;
                  }
                }
                put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                s.gzindex++;
              }
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (s.gzindex === s.gzhead.extra.length) {
                s.gzindex = 0;
                s.status = NAME_STATE;
              }
            } else {
              s.status = NAME_STATE;
            }
          }
          if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.name.length) {
                  val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s, val);
              } while (val !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val === 0) {
                s.gzindex = 0;
                s.status = COMMENT_STATE;
              }
            } else {
              s.status = COMMENT_STATE;
            }
          }
          if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.comment.length) {
                  val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s, val);
              } while (val !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val === 0) {
                s.status = HCRC_STATE;
              }
            } else {
              s.status = HCRC_STATE;
            }
          }
          if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
              if (s.pending + 2 > s.pending_buf_size) {
                flush_pending(strm);
              }
              if (s.pending + 2 <= s.pending_buf_size) {
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                strm.adler = 0;
                s.status = BUSY_STATE;
              }
            } else {
              s.status = BUSY_STATE;
            }
          }
          if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
          }
          if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
          }
          if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
            var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
              s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
              if (strm.avail_out === 0) {
                s.last_flush = -1;
              }
              return Z_OK;
            }
            if (bstate === BS_BLOCK_DONE) {
              if (flush === Z_PARTIAL_FLUSH) {
                trees._tr_align(s);
              } else if (flush !== Z_BLOCK) {
                trees._tr_stored_block(s, 0, 0, false);
                if (flush === Z_FULL_FLUSH) {
                  zero(s.head);
                  if (s.lookahead === 0) {
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                  }
                }
              }
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            }
          }
          if (flush !== Z_FINISH) {
            return Z_OK;
          }
          if (s.wrap <= 0) {
            return Z_STREAM_END;
          }
          if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
          } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          flush_pending(strm);
          if (s.wrap > 0) {
            s.wrap = -s.wrap;
          }
          return s.pending !== 0 ? Z_OK : Z_STREAM_END;
        }
        function deflateEnd(strm) {
          var status;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          status = strm.state.status;
          if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.state = null;
          return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
        }
        exports3.deflateInit = deflateInit;
        exports3.deflateInit2 = deflateInit2;
        exports3.deflateReset = deflateReset;
        exports3.deflateResetKeep = deflateResetKeep;
        exports3.deflateSetHeader = deflateSetHeader;
        exports3.deflate = deflate;
        exports3.deflateEnd = deflateEnd;
        exports3.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 40, "./adler32": 42, "./crc32": 44, "./messages": 50, "./trees": 51 }], 46: [function(require2, module3, exports3) {
        "use strict";
        function GZheader() {
          this.text = 0;
          this.time = 0;
          this.xflags = 0;
          this.os = 0;
          this.extra = null;
          this.extra_len = 0;
          this.name = "";
          this.comment = "";
          this.hcrc = 0;
          this.done = false;
        }
        module3.exports = GZheader;
      }, {}], 47: [function(require2, module3, exports3) {
        "use strict";
        var BAD = 30;
        var TYPE = 12;
        module3.exports = function inflate_fast(strm, start) {
          var state;
          var _in;
          var last;
          var _out;
          var beg;
          var end;
          var dmax;
          var wsize;
          var whave;
          var wnext;
          var s_window;
          var hold;
          var bits;
          var lcode;
          var dcode;
          var lmask;
          var dmask;
          var here;
          var op;
          var len;
          var dist;
          var from;
          var from_source;
          var input, output;
          state = strm.state;
          _in = strm.next_in;
          input = strm.input;
          last = _in + (strm.avail_in - 5);
          _out = strm.next_out;
          output = strm.output;
          beg = _out - (start - strm.avail_out);
          end = _out + (strm.avail_out - 257);
          dmax = state.dmax;
          wsize = state.wsize;
          whave = state.whave;
          wnext = state.wnext;
          s_window = state.window;
          hold = state.hold;
          bits = state.bits;
          lcode = state.lencode;
          dcode = state.distcode;
          lmask = (1 << state.lenbits) - 1;
          dmask = (1 << state.distbits) - 1;
          top:
            do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = lcode[hold & lmask];
              dolen:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op === 0) {
                    output[_out++] = here & 65535;
                  } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      len += hold & (1 << op) - 1;
                      hold >>>= op;
                      bits -= op;
                    }
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                          dist = here & 65535;
                          op &= 15;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                          }
                          dist += hold & (1 << op) - 1;
                          if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                          hold >>>= op;
                          bits -= op;
                          op = _out - beg;
                          if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                              if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break top;
                              }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                              from += wsize - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            } else if (wnext < op) {
                              from += wsize + wnext - op;
                              op -= wnext;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = 0;
                                if (wnext < len) {
                                  op = wnext;
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from++];
                                  } while (--op);
                                  from = _out - dist;
                                  from_source = output;
                                }
                              }
                            } else {
                              from += wnext - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                            while (len > 2) {
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              len -= 3;
                            }
                            if (len) {
                              output[_out++] = from_source[from++];
                              if (len > 1) {
                                output[_out++] = from_source[from++];
                              }
                            }
                          } else {
                            from = _out - dist;
                            do {
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              len -= 3;
                            } while (len > 2);
                            if (len) {
                              output[_out++] = output[from++];
                              if (len > 1) {
                                output[_out++] = output[from++];
                              }
                            }
                          }
                        } else if ((op & 64) === 0) {
                          here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dodist;
                        } else {
                          strm.msg = "invalid distance code";
                          state.mode = BAD;
                          break top;
                        }
                        break;
                      }
                  } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                  } else if (op & 32) {
                    state.mode = TYPE;
                    break top;
                  } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } while (_in < last && _out < end);
          len = bits >> 3;
          _in -= len;
          bits -= len << 3;
          hold &= (1 << bits) - 1;
          strm.next_in = _in;
          strm.next_out = _out;
          strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
          strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
          state.hold = hold;
          state.bits = bits;
          return;
        };
      }, {}], 48: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var inflate_fast = require2("./inffast");
        var inflate_table = require2("./inftrees");
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_TREES = 6;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_NEED_DICT = 2;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_MEM_ERROR = -4;
        var Z_BUF_ERROR = -5;
        var Z_DEFLATED = 8;
        var HEAD = 1;
        var FLAGS = 2;
        var TIME = 3;
        var OS = 4;
        var EXLEN = 5;
        var EXTRA = 6;
        var NAME = 7;
        var COMMENT = 8;
        var HCRC = 9;
        var DICTID = 10;
        var DICT = 11;
        var TYPE = 12;
        var TYPEDO = 13;
        var STORED = 14;
        var COPY_ = 15;
        var COPY = 16;
        var TABLE = 17;
        var LENLENS = 18;
        var CODELENS = 19;
        var LEN_ = 20;
        var LEN = 21;
        var LENEXT = 22;
        var DIST = 23;
        var DISTEXT = 24;
        var MATCH = 25;
        var LIT = 26;
        var CHECK = 27;
        var LENGTH = 28;
        var DONE = 29;
        var BAD = 30;
        var MEM = 31;
        var SYNC = 32;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var MAX_WBITS = 15;
        var DEF_WBITS = MAX_WBITS;
        function ZSWAP32(q) {
          return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
        }
        function InflateState() {
          this.mode = 0;
          this.last = false;
          this.wrap = 0;
          this.havedict = false;
          this.flags = 0;
          this.dmax = 0;
          this.check = 0;
          this.total = 0;
          this.head = null;
          this.wbits = 0;
          this.wsize = 0;
          this.whave = 0;
          this.wnext = 0;
          this.window = null;
          this.hold = 0;
          this.bits = 0;
          this.length = 0;
          this.offset = 0;
          this.extra = 0;
          this.lencode = null;
          this.distcode = null;
          this.lenbits = 0;
          this.distbits = 0;
          this.ncode = 0;
          this.nlen = 0;
          this.ndist = 0;
          this.have = 0;
          this.next = null;
          this.lens = new utils.Buf16(320);
          this.work = new utils.Buf16(288);
          this.lendyn = null;
          this.distdyn = null;
          this.sane = 0;
          this.back = 0;
          this.was = 0;
        }
        function inflateResetKeep(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          strm.total_in = strm.total_out = state.total = 0;
          strm.msg = "";
          if (state.wrap) {
            strm.adler = state.wrap & 1;
          }
          state.mode = HEAD;
          state.last = 0;
          state.havedict = 0;
          state.dmax = 32768;
          state.head = null;
          state.hold = 0;
          state.bits = 0;
          state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
          state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
          state.sane = 1;
          state.back = -1;
          return Z_OK;
        }
        function inflateReset(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          state.wsize = 0;
          state.whave = 0;
          state.wnext = 0;
          return inflateResetKeep(strm);
        }
        function inflateReset2(strm, windowBits) {
          var wrap;
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else {
            wrap = (windowBits >> 4) + 1;
            if (windowBits < 48) {
              windowBits &= 15;
            }
          }
          if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR;
          }
          if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
          }
          state.wrap = wrap;
          state.wbits = windowBits;
          return inflateReset(strm);
        }
        function inflateInit2(strm, windowBits) {
          var ret;
          var state;
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          state = new InflateState();
          strm.state = state;
          state.window = null;
          ret = inflateReset2(strm, windowBits);
          if (ret !== Z_OK) {
            strm.state = null;
          }
          return ret;
        }
        function inflateInit(strm) {
          return inflateInit2(strm, DEF_WBITS);
        }
        var virgin = true;
        var lenfix, distfix;
        function fixedtables(state) {
          if (virgin) {
            var sym;
            lenfix = new utils.Buf32(512);
            distfix = new utils.Buf32(32);
            sym = 0;
            while (sym < 144) {
              state.lens[sym++] = 8;
            }
            while (sym < 256) {
              state.lens[sym++] = 9;
            }
            while (sym < 280) {
              state.lens[sym++] = 7;
            }
            while (sym < 288) {
              state.lens[sym++] = 8;
            }
            inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
            sym = 0;
            while (sym < 32) {
              state.lens[sym++] = 5;
            }
            inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
            virgin = false;
          }
          state.lencode = lenfix;
          state.lenbits = 9;
          state.distcode = distfix;
          state.distbits = 5;
        }
        function updatewindow(strm, src, end, copy) {
          var dist;
          var state = strm.state;
          if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new utils.Buf8(state.wsize);
          }
          if (copy >= state.wsize) {
            utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
            state.wnext = 0;
            state.whave = state.wsize;
          } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
              dist = copy;
            }
            utils.arraySet(state.window, src, end - copy, dist, state.wnext);
            copy -= dist;
            if (copy) {
              utils.arraySet(state.window, src, end - copy, copy, 0);
              state.wnext = copy;
              state.whave = state.wsize;
            } else {
              state.wnext += dist;
              if (state.wnext === state.wsize) {
                state.wnext = 0;
              }
              if (state.whave < state.wsize) {
                state.whave += dist;
              }
            }
          }
          return 0;
        }
        function inflate(strm, flush) {
          var state;
          var input, output;
          var next;
          var put;
          var have, left;
          var hold;
          var bits;
          var _in, _out;
          var copy;
          var from;
          var from_source;
          var here = 0;
          var here_bits, here_op, here_val;
          var last_bits, last_op, last_val;
          var len;
          var ret;
          var hbuf = new utils.Buf8(4);
          var opts;
          var n;
          var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.mode === TYPE) {
            state.mode = TYPEDO;
          }
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          _in = have;
          _out = left;
          ret = Z_OK;
          inf_leave:
            for (; ; ) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  }
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                  }
                  state.flags = 0;
                  if (state.head) {
                    state.head.done = false;
                  }
                  if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                  }
                  if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  hold >>>= 4;
                  bits -= 4;
                  len = (hold & 15) + 8;
                  if (state.wbits === 0) {
                    state.wbits = len;
                  } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                  }
                  state.dmax = 1 << len;
                  strm.adler = state.check = 1;
                  state.mode = hold & 512 ? DICTID : TYPE;
                  hold = 0;
                  bits = 0;
                  break;
                case FLAGS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.flags = hold;
                  if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                  }
                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = TIME;
                case TIME:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.time = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = OS;
                case OS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = EXLEN;
                case EXLEN:
                  if (state.flags & 1024) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                      state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                  } else if (state.head) {
                    state.head.extra = null;
                  }
                  state.mode = EXTRA;
                case EXTRA:
                  if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) {
                          state.head.extra = new Array(state.head.extra_len);
                        }
                        utils.arraySet(
                          state.head.extra,
                          input,
                          next,
                          copy,
                          len
                        );
                      }
                      if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                      }
                      have -= copy;
                      next += copy;
                      state.length -= copy;
                    }
                    if (state.length) {
                      break inf_leave;
                    }
                  }
                  state.length = 0;
                  state.mode = NAME;
                case NAME:
                  if (state.flags & 2048) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }
                  state.length = 0;
                  state.mode = COMMENT;
                case COMMENT:
                  if (state.flags & 4096) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }
                  state.mode = HCRC;
                case HCRC:
                  if (state.flags & 512) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                      strm.msg = "header crc mismatch";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }
                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;
                case DICTID:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  strm.adler = state.check = ZSWAP32(hold);
                  hold = 0;
                  bits = 0;
                  state.mode = DICT;
                case DICT:
                  if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT;
                  }
                  strm.adler = state.check = 1;
                  state.mode = TYPE;
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }
                case TYPEDO:
                  if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                  }
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.last = hold & 1;
                  hold >>>= 1;
                  bits -= 1;
                  switch (hold & 3) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      fixedtables(state);
                      state.mode = LEN_;
                      if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      strm.msg = "invalid block type";
                      state.mode = BAD;
                  }
                  hold >>>= 2;
                  bits -= 2;
                  break;
                case STORED:
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                  }
                  state.length = hold & 65535;
                  hold = 0;
                  bits = 0;
                  state.mode = COPY_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  copy = state.length;
                  if (copy) {
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy > left) {
                      copy = left;
                    }
                    if (copy === 0) {
                      break inf_leave;
                    }
                    utils.arraySet(output, input, next, copy, put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.nlen = (hold & 31) + 257;
                  hold >>>= 5;
                  bits -= 5;
                  state.ndist = (hold & 31) + 1;
                  hold >>>= 5;
                  bits -= 5;
                  state.ncode = (hold & 15) + 4;
                  hold >>>= 4;
                  bits -= 4;
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = LENLENS;
                case LENLENS:
                  while (state.have < state.ncode) {
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  }
                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = CODELENS;
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (here_val < 16) {
                      hold >>>= here_bits;
                      bits -= here_bits;
                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        n = here_bits + 2;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        if (state.have === 0) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 3);
                        hold >>>= 2;
                        bits -= 2;
                      } else if (here_val === 17) {
                        n = here_bits + 3;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 3 + (hold & 7);
                        hold >>>= 3;
                        bits -= 3;
                      } else {
                        n = here_bits + 7;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 11 + (hold & 127);
                        hold >>>= 7;
                        bits -= 7;
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      while (copy--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  if (state.mode === BAD) {
                    break;
                  }
                  if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                  }
                  state.lenbits = 9;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.distbits = 6;
                  state.distcode = state.distdyn;
                  opts = { bits: state.distbits };
                  ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                  state.distbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                      state.back = -1;
                    }
                    break;
                  }
                  state.back = 0;
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  state.length = here_val;
                  if (here_op === 0) {
                    state.mode = LIT;
                    break;
                  }
                  if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }
                  if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                  }
                  state.extra = here_op & 15;
                  state.mode = LENEXT;
                case LENEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  state.was = state.length;
                  state.mode = DIST;
                case DIST:
                  for (; ; ) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                  }
                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;
                case DISTEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }
                  copy = _out - left;
                  if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                      }
                    }
                    if (copy > state.wnext) {
                      copy -= state.wnext;
                      from = state.wsize - copy;
                    } else {
                      from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                      copy = state.length;
                    }
                    from_source = state.window;
                  } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  left -= copy;
                  state.length -= copy;
                  do {
                    output[put++] = from_source[from++];
                  } while (--copy);
                  if (state.length === 0) {
                    state.mode = LEN;
                  }
                  break;
                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }
                  output[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;
                case CHECK:
                  if (state.wrap) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold |= input[next++] << bits;
                      bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
                      strm.msg = "incorrect data check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                      strm.msg = "incorrect length check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR;
                case SYNC:
                default:
                  return Z_STREAM_ERROR;
              }
            }
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
              state.mode = MEM;
              return Z_MEM_ERROR;
            }
          }
          _in -= strm.avail_in;
          _out -= strm.avail_out;
          strm.total_in += _in;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap && _out) {
            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
          }
          strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
          if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
            ret = Z_BUF_ERROR;
          }
          return ret;
        }
        function inflateEnd(strm) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          var state = strm.state;
          if (state.window) {
            state.window = null;
          }
          strm.state = null;
          return Z_OK;
        }
        function inflateGetHeader(strm, head) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR;
          }
          state.head = head;
          head.done = false;
          return Z_OK;
        }
        exports3.inflateReset = inflateReset;
        exports3.inflateReset2 = inflateReset2;
        exports3.inflateResetKeep = inflateResetKeep;
        exports3.inflateInit = inflateInit;
        exports3.inflateInit2 = inflateInit2;
        exports3.inflate = inflate;
        exports3.inflateEnd = inflateEnd;
        exports3.inflateGetHeader = inflateGetHeader;
        exports3.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 40, "./adler32": 42, "./crc32": 44, "./inffast": 47, "./inftrees": 49 }], 49: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var MAXBITS = 15;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var lbase = [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ];
        var lext = [
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ];
        var dbase = [
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ];
        var dext = [
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        module3.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
          var bits = opts.bits;
          var len = 0;
          var sym = 0;
          var min = 0, max = 0;
          var root = 0;
          var curr = 0;
          var drop = 0;
          var left = 0;
          var used = 0;
          var huff = 0;
          var incr;
          var fill;
          var low;
          var mask;
          var next;
          var base = null;
          var base_index = 0;
          var end;
          var count = new utils.Buf16(MAXBITS + 1);
          var offs = new utils.Buf16(MAXBITS + 1);
          var extra = null;
          var extra_index = 0;
          var here_bits, here_op, here_val;
          for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
          }
          for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
          }
          root = bits;
          for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
              break;
            }
          }
          if (root > max) {
            root = max;
          }
          if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
          }
          for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
              break;
            }
          }
          if (root < min) {
            root = min;
          }
          left = 1;
          for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
              return -1;
            }
          }
          if (left > 0 && (type === CODES || max !== 1)) {
            return -1;
          }
          offs[1] = 0;
          for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
          }
          for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
              work[offs[lens[lens_index + sym]]++] = sym;
            }
          }
          if (type === CODES) {
            base = extra = work;
            end = 19;
          } else if (type === LENS) {
            base = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end = 256;
          } else {
            base = dbase;
            extra = dext;
            end = -1;
          }
          huff = 0;
          sym = 0;
          len = min;
          next = table_index;
          curr = root;
          drop = 0;
          low = -1;
          used = 1 << root;
          mask = used - 1;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          var i = 0;
          for (; ; ) {
            i++;
            here_bits = len - drop;
            if (work[sym] < end) {
              here_op = 0;
              here_val = work[sym];
            } else if (work[sym] > end) {
              here_op = extra[extra_index + work[sym]];
              here_val = base[base_index + work[sym]];
            } else {
              here_op = 32 + 64;
              here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
              fill -= incr;
              table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
              incr >>= 1;
            }
            if (incr !== 0) {
              huff &= incr - 1;
              huff += incr;
            } else {
              huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
              if (len === max) {
                break;
              }
              len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
              if (drop === 0) {
                drop = root;
              }
              next += min;
              curr = len - drop;
              left = 1 << curr;
              while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) {
                  break;
                }
                curr++;
                left <<= 1;
              }
              used += 1 << curr;
              if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                return 1;
              }
              low = huff & mask;
              table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
          }
          if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
          }
          opts.bits = root;
          return 0;
        };
      }, { "../utils/common": 40 }], 50: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = {
          "2": "need dictionary",
          "1": "stream end",
          "0": "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
      }, {}], 51: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var Z_FIXED = 4;
        var Z_BINARY = 0;
        var Z_TEXT = 1;
        var Z_UNKNOWN = 2;
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES = 2;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var Buf_size = 16;
        var MAX_BL_BITS = 7;
        var END_BLOCK = 256;
        var REP_3_6 = 16;
        var REPZ_3_10 = 17;
        var REPZ_11_138 = 18;
        var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
        var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
        var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
        var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        var DIST_CODE_LEN = 512;
        var static_ltree = new Array((L_CODES + 2) * 2);
        zero(static_ltree);
        var static_dtree = new Array(D_CODES * 2);
        zero(static_dtree);
        var _dist_code = new Array(DIST_CODE_LEN);
        zero(_dist_code);
        var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
        zero(_length_code);
        var base_length = new Array(LENGTH_CODES);
        zero(base_length);
        var base_dist = new Array(D_CODES);
        zero(base_dist);
        var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {
          this.static_tree = static_tree;
          this.extra_bits = extra_bits;
          this.extra_base = extra_base;
          this.elems = elems;
          this.max_length = max_length;
          this.has_stree = static_tree && static_tree.length;
        };
        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;
        var TreeDesc = function(dyn_tree, stat_desc) {
          this.dyn_tree = dyn_tree;
          this.max_code = 0;
          this.stat_desc = stat_desc;
        };
        function d_code(dist) {
          return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }
        function put_short(s, w) {
          s.pending_buf[s.pending++] = w & 255;
          s.pending_buf[s.pending++] = w >>> 8 & 255;
        }
        function send_bits(s, value, length) {
          if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
          } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
          }
        }
        function send_code(s, c, tree) {
          send_bits(s, tree[c * 2], tree[c * 2 + 1]);
        }
        function bi_reverse(code, len) {
          var res = 0;
          do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
          } while (--len > 0);
          return res >>> 1;
        }
        function bi_flush(s) {
          if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
          } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
          }
        }
        function gen_bitlen(s, desc) {
          var tree = desc.dyn_tree;
          var max_code = desc.max_code;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var extra = desc.stat_desc.extra_bits;
          var base = desc.stat_desc.extra_base;
          var max_length = desc.stat_desc.max_length;
          var h;
          var n, m;
          var bits;
          var xbits;
          var f;
          var overflow = 0;
          for (bits = 0; bits <= MAX_BITS; bits++) {
            s.bl_count[bits] = 0;
          }
          tree[s.heap[s.heap_max] * 2 + 1] = 0;
          for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
              bits = max_length;
              overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
              continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
              xbits = extra[n - base];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
              s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
          }
          if (overflow === 0) {
            return;
          }
          do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) {
              bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
          } while (overflow > 0);
          for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
              m = s.heap[--h];
              if (m > max_code) {
                continue;
              }
              if (tree[m * 2 + 1] !== bits) {
                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
              }
              n--;
            }
          }
        }
        function gen_codes(tree, max_code, bl_count) {
          var next_code = new Array(MAX_BITS + 1);
          var code = 0;
          var bits;
          var n;
          for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
          }
          for (n = 0; n <= max_code; n++) {
            var len = tree[n * 2 + 1];
            if (len === 0) {
              continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
          }
        }
        function tr_static_init() {
          var n;
          var bits;
          var length;
          var code;
          var dist;
          var bl_count = new Array(MAX_BITS + 1);
          length = 0;
          for (code = 0; code < LENGTH_CODES - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < 1 << extra_lbits[code]; n++) {
              _length_code[length++] = code;
            }
          }
          _length_code[length - 1] = code;
          dist = 0;
          for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < 1 << extra_dbits[code]; n++) {
              _dist_code[dist++] = code;
            }
          }
          dist >>= 7;
          for (; code < D_CODES; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
              _dist_code[256 + dist++] = code;
            }
          }
          for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
          }
          n = 0;
          while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
          }
          while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
          }
          while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          gen_codes(static_ltree, L_CODES + 1, bl_count);
          for (n = 0; n < D_CODES; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
          }
          static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
          static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
          static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
        }
        function init_block(s) {
          var n;
          for (n = 0; n < L_CODES; n++) {
            s.dyn_ltree[n * 2] = 0;
          }
          for (n = 0; n < D_CODES; n++) {
            s.dyn_dtree[n * 2] = 0;
          }
          for (n = 0; n < BL_CODES; n++) {
            s.bl_tree[n * 2] = 0;
          }
          s.dyn_ltree[END_BLOCK * 2] = 1;
          s.opt_len = s.static_len = 0;
          s.last_lit = s.matches = 0;
        }
        function bi_windup(s) {
          if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
          } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
          }
          s.bi_buf = 0;
          s.bi_valid = 0;
        }
        function copy_block(s, buf, len, header) {
          bi_windup(s);
          if (header) {
            put_short(s, len);
            put_short(s, ~len);
          }
          utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
          s.pending += len;
        }
        function smaller(tree, n, m, depth) {
          var _n2 = n * 2;
          var _m2 = m * 2;
          return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
        }
        function pqdownheap(s, tree, k) {
          var v = s.heap[k];
          var j = k << 1;
          while (j <= s.heap_len) {
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
              j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
              break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
          }
          s.heap[k] = v;
        }
        function compress_block(s, ltree, dtree) {
          var dist;
          var lc;
          var lx = 0;
          var code;
          var extra;
          if (s.last_lit !== 0) {
            do {
              dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
              lc = s.pending_buf[s.l_buf + lx];
              lx++;
              if (dist === 0) {
                send_code(s, lc, ltree);
              } else {
                code = _length_code[lc];
                send_code(s, code + LITERALS + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                  lc -= base_length[code];
                  send_bits(s, lc, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                  dist -= base_dist[code];
                  send_bits(s, dist, extra);
                }
              }
            } while (lx < s.last_lit);
          }
          send_code(s, END_BLOCK, ltree);
        }
        function build_tree(s, desc) {
          var tree = desc.dyn_tree;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var elems = desc.stat_desc.elems;
          var n, m;
          var max_code = -1;
          var node;
          s.heap_len = 0;
          s.heap_max = HEAP_SIZE;
          for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
              s.heap[++s.heap_len] = max_code = n;
              s.depth[n] = 0;
            } else {
              tree[n * 2 + 1] = 0;
            }
          }
          while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
              s.static_len -= stree[node * 2 + 1];
            }
          }
          desc.max_code = max_code;
          for (n = s.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s, tree, n);
          }
          node = elems;
          do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            pqdownheap(s, tree, 1);
          } while (s.heap_len >= 2);
          s.heap[--s.heap_max] = s.heap[1];
          gen_bitlen(s, desc);
          gen_codes(tree, max_code, s.bl_count);
        }
        function scan_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          tree[(max_code + 1) * 2 + 1] = 65535;
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                s.bl_tree[curlen * 2]++;
              }
              s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
              s.bl_tree[REPZ_3_10 * 2]++;
            } else {
              s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function send_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              do {
                send_code(s, curlen, s.bl_tree);
              } while (--count !== 0);
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                send_code(s, curlen, s.bl_tree);
                count--;
              }
              send_code(s, REP_3_6, s.bl_tree);
              send_bits(s, count - 3, 2);
            } else if (count <= 10) {
              send_code(s, REPZ_3_10, s.bl_tree);
              send_bits(s, count - 3, 3);
            } else {
              send_code(s, REPZ_11_138, s.bl_tree);
              send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function build_bl_tree(s) {
          var max_blindex;
          scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
          scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
          build_tree(s, s.bl_desc);
          for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
              break;
            }
          }
          s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
          return max_blindex;
        }
        function send_all_trees(s, lcodes, dcodes, blcodes) {
          var rank;
          send_bits(s, lcodes - 257, 5);
          send_bits(s, dcodes - 1, 5);
          send_bits(s, blcodes - 4, 4);
          for (rank = 0; rank < blcodes; rank++) {
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
          }
          send_tree(s, s.dyn_ltree, lcodes - 1);
          send_tree(s, s.dyn_dtree, dcodes - 1);
        }
        function detect_data_type(s) {
          var black_mask = 4093624447;
          var n;
          for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
              return Z_BINARY;
            }
          }
          if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
          }
          for (n = 32; n < LITERALS; n++) {
            if (s.dyn_ltree[n * 2] !== 0) {
              return Z_TEXT;
            }
          }
          return Z_BINARY;
        }
        var static_init_done = false;
        function _tr_init(s) {
          if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
          }
          s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
          s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
          s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
          s.bi_buf = 0;
          s.bi_valid = 0;
          init_block(s);
        }
        function _tr_stored_block(s, buf, stored_len, last) {
          send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
          copy_block(s, buf, stored_len, true);
        }
        function _tr_align(s) {
          send_bits(s, STATIC_TREES << 1, 3);
          send_code(s, END_BLOCK, static_ltree);
          bi_flush(s);
        }
        function _tr_flush_block(s, buf, stored_len, last) {
          var opt_lenb, static_lenb;
          var max_blindex = 0;
          if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN) {
              s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
              opt_lenb = static_lenb;
            }
          } else {
            opt_lenb = static_lenb = stored_len + 5;
          }
          if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block(s, buf, stored_len, last);
          } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
          } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
          }
          init_block(s);
          if (last) {
            bi_windup(s);
          }
        }
        function _tr_tally(s, dist, lc) {
          s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
          s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
          s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
          s.last_lit++;
          if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
          } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
          }
          return s.last_lit === s.lit_bufsize - 1;
        }
        exports3._tr_init = _tr_init;
        exports3._tr_stored_block = _tr_stored_block;
        exports3._tr_flush_block = _tr_flush_block;
        exports3._tr_tally = _tr_tally;
        exports3._tr_align = _tr_align;
      }, { "../utils/common": 40 }], 52: [function(require2, module3, exports3) {
        "use strict";
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        module3.exports = ZStream;
      }, {}], 53: [function(require2, module3, exports3) {
        function dbfHeader(buffer) {
          var data = new DataView(buffer);
          var out = {};
          out.lastUpdated = new Date(data.getUint8(1, true) + 1900, data.getUint8(2, true), data.getUint8(3, true));
          out.records = data.getUint32(4, true);
          out.headerLen = data.getUint16(8, true);
          out.recLen = data.getUint16(10, true);
          return out;
        }
        function dbfRowHeader(buffer, headerLen) {
          var data = new DataView(buffer);
          var out = [];
          var offset = 32;
          while (offset < headerLen) {
            out.push({
              name: String.fromCharCode.apply(this, new Uint8Array(buffer, offset, 11)).replace(/\0|\s+$/g, ""),
              dataType: String.fromCharCode(data.getUint8(offset + 11)),
              len: data.getUint8(offset + 16),
              decimal: data.getUint8(offset + 17)
            });
            if (data.getUint8(offset + 32) === 13) {
              break;
            } else {
              offset += 32;
            }
          }
          return out;
        }
        function rowFuncs(buffer, offset, len, type) {
          var data = new Uint8Array(buffer, offset, len);
          var textData = String.fromCharCode.apply(this, data).replace(/\0|\s+$/g, "");
          switch (type) {
            case "N":
            case "F":
            case "O":
              return parseFloat(textData, 10);
            case "D":
              return new Date(textData.slice(0, 4), parseInt(textData.slice(4, 6), 10) - 1, textData.slice(6, 8));
            case "L":
              return textData.toLowerCase() === "y" || textData.toLowerCase() === "t";
            default:
              return textData;
          }
        }
        function parseRow(buffer, offset, rowHeaders) {
          var out = {};
          var i = 0;
          var len = rowHeaders.length;
          var field;
          var header;
          while (i < len) {
            header = rowHeaders[i];
            field = rowFuncs(buffer, offset, header.len, header.dataType);
            offset += header.len;
            if (typeof field !== "undefined") {
              out[header.name] = field;
            }
            i++;
          }
          return out;
        }
        module3.exports = function(buffer) {
          var header = dbfHeader(buffer);
          var rowHeaders = dbfRowHeader(buffer, header.headerLen - 1);
          var offset = (rowHeaders.length + 1 << 5) + 2;
          var recLen = header.recLen;
          var records = header.records;
          var out = [];
          while (records) {
            out.push(parseRow(buffer, offset, rowHeaders));
            offset += recLen;
            records--;
          }
          return out;
        };
      }, {}], 54: [function(require2, module3, exports3) {
        var mgrs = require2("mgrs");
        function Point(x, y, z) {
          if (!(this instanceof Point)) {
            return new Point(x, y, z);
          }
          if (Array.isArray(x)) {
            this.x = x[0];
            this.y = x[1];
            this.z = x[2] || 0;
          } else if (typeof x === "object") {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z || 0;
          } else if (typeof x === "string" && typeof y === "undefined") {
            var coords = x.split(",");
            this.x = parseFloat(coords[0], 10);
            this.y = parseFloat(coords[1], 10);
            this.z = parseFloat(coords[2], 10) || 0;
          } else {
            this.x = x;
            this.y = y;
            this.z = z || 0;
          }
          console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
        }
        Point.fromMGRS = function(mgrsStr) {
          return new Point(mgrs.toPoint(mgrsStr));
        };
        Point.prototype.toMGRS = function(accuracy) {
          return mgrs.forward([this.x, this.y], accuracy);
        };
        module3.exports = Point;
      }, { "mgrs": 36 }], 55: [function(require2, module3, exports3) {
        var parseCode = require2("./parseCode");
        var extend = require2("./extend");
        var projections = require2("./projections");
        var deriveConstants = require2("./deriveConstants");
        function Projection(srsCode, callback) {
          if (!(this instanceof Projection)) {
            return new Projection(srsCode);
          }
          callback = callback || function(error) {
            if (error) {
              throw error;
            }
          };
          var json = parseCode(srsCode);
          if (typeof json !== "object") {
            callback(srsCode);
            return;
          }
          var modifiedJSON = deriveConstants(json);
          var ourProj = Projection.projections.get(modifiedJSON.projName);
          if (ourProj) {
            extend(this, modifiedJSON);
            extend(this, ourProj);
            this.init();
            callback(null, this);
          } else {
            callback(srsCode);
          }
        }
        Projection.projections = projections;
        Projection.projections.start();
        module3.exports = Projection;
      }, { "./deriveConstants": 86, "./extend": 87, "./parseCode": 91, "./projections": 93 }], 56: [function(require2, module3, exports3) {
        module3.exports = function(crs, denorm, point) {
          var xin = point.x, yin = point.y, zin = point.z || 0;
          var v, t, i;
          for (i = 0; i < 3; i++) {
            if (denorm && i === 2 && point.z === void 0) {
              continue;
            }
            if (i === 0) {
              v = xin;
              t = "x";
            } else if (i === 1) {
              v = yin;
              t = "y";
            } else {
              v = zin;
              t = "z";
            }
            switch (crs.axis[i]) {
              case "e":
                point[t] = v;
                break;
              case "w":
                point[t] = -v;
                break;
              case "n":
                point[t] = v;
                break;
              case "s":
                point[t] = -v;
                break;
              case "u":
                if (point[t] !== void 0) {
                  point.z = v;
                }
                break;
              case "d":
                if (point[t] !== void 0) {
                  point.z = -v;
                }
                break;
              default:
                return null;
            }
          }
          return point;
        };
      }, {}], 57: [function(require2, module3, exports3) {
        var HALF_PI = Math.PI / 2;
        var sign = require2("./sign");
        module3.exports = function(x) {
          return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
        };
      }, { "./sign": 74 }], 58: [function(require2, module3, exports3) {
        var TWO_PI = Math.PI * 2;
        var SPI = 3.14159265359;
        var sign = require2("./sign");
        module3.exports = function(x) {
          return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
        };
      }, { "./sign": 74 }], 59: [function(require2, module3, exports3) {
        module3.exports = function(x) {
          if (Math.abs(x) > 1) {
            x = x > 1 ? 1 : -1;
          }
          return Math.asin(x);
        };
      }, {}], 60: [function(require2, module3, exports3) {
        module3.exports = function(x) {
          return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
        };
      }, {}], 61: [function(require2, module3, exports3) {
        module3.exports = function(x) {
          return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
        };
      }, {}], 62: [function(require2, module3, exports3) {
        module3.exports = function(x) {
          return 0.05859375 * x * x * (1 + 0.75 * x);
        };
      }, {}], 63: [function(require2, module3, exports3) {
        module3.exports = function(x) {
          return x * x * x * (35 / 3072);
        };
      }, {}], 64: [function(require2, module3, exports3) {
        module3.exports = function(a, e, sinphi) {
          var temp = e * sinphi;
          return a / Math.sqrt(1 - temp * temp);
        };
      }, {}], 65: [function(require2, module3, exports3) {
        module3.exports = function(ml, e0, e1, e2, e3) {
          var phi;
          var dphi;
          phi = ml / e0;
          for (var i = 0; i < 15; i++) {
            dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return NaN;
        };
      }, {}], 66: [function(require2, module3, exports3) {
        var HALF_PI = Math.PI / 2;
        module3.exports = function(eccent, q) {
          var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
          if (Math.abs(Math.abs(q) - temp) < 1e-6) {
            if (q < 0) {
              return -1 * HALF_PI;
            } else {
              return HALF_PI;
            }
          }
          var phi = Math.asin(0.5 * q);
          var dphi;
          var sin_phi;
          var cos_phi;
          var con;
          for (var i = 0; i < 30; i++) {
            sin_phi = Math.sin(phi);
            cos_phi = Math.cos(phi);
            con = eccent * sin_phi;
            dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return NaN;
        };
      }, {}], 67: [function(require2, module3, exports3) {
        module3.exports = function(e0, e1, e2, e3, phi) {
          return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
        };
      }, {}], 68: [function(require2, module3, exports3) {
        module3.exports = function(eccent, sinphi, cosphi) {
          var con = eccent * sinphi;
          return cosphi / Math.sqrt(1 - con * con);
        };
      }, {}], 69: [function(require2, module3, exports3) {
        var HALF_PI = Math.PI / 2;
        module3.exports = function(eccent, ts) {
          var eccnth = 0.5 * eccent;
          var con, dphi;
          var phi = HALF_PI - 2 * Math.atan(ts);
          for (var i = 0; i <= 15; i++) {
            con = eccent * Math.sin(phi);
            dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return -9999;
        };
      }, {}], 70: [function(require2, module3, exports3) {
        var C00 = 1;
        var C02 = 0.25;
        var C04 = 0.046875;
        var C06 = 0.01953125;
        var C08 = 0.01068115234375;
        var C22 = 0.75;
        var C44 = 0.46875;
        var C46 = 0.013020833333333334;
        var C48 = 0.007120768229166667;
        var C66 = 0.3645833333333333;
        var C68 = 0.005696614583333333;
        var C88 = 0.3076171875;
        module3.exports = function(es) {
          var en = [];
          en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
          en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
          var t = es * es;
          en[2] = t * (C44 - es * (C46 + es * C48));
          t *= es;
          en[3] = t * (C66 - es * C68);
          en[4] = t * es * C88;
          return en;
        };
      }, {}], 71: [function(require2, module3, exports3) {
        var pj_mlfn = require2("./pj_mlfn");
        var EPSLN = 1e-10;
        var MAX_ITER = 20;
        module3.exports = function(arg, es, en) {
          var k = 1 / (1 - es);
          var phi = arg;
          for (var i = MAX_ITER; i; --i) {
            var s = Math.sin(phi);
            var t = 1 - es * s * s;
            t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
            phi -= t;
            if (Math.abs(t) < EPSLN) {
              return phi;
            }
          }
          return phi;
        };
      }, { "./pj_mlfn": 72 }], 72: [function(require2, module3, exports3) {
        module3.exports = function(phi, sphi, cphi, en) {
          cphi *= sphi;
          sphi *= sphi;
          return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
        };
      }, {}], 73: [function(require2, module3, exports3) {
        module3.exports = function(eccent, sinphi) {
          var con;
          if (eccent > 1e-7) {
            con = eccent * sinphi;
            return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
          } else {
            return 2 * sinphi;
          }
        };
      }, {}], 74: [function(require2, module3, exports3) {
        module3.exports = function(x) {
          return x < 0 ? -1 : 1;
        };
      }, {}], 75: [function(require2, module3, exports3) {
        module3.exports = function(esinp, exp) {
          return Math.pow((1 - esinp) / (1 + esinp), exp);
        };
      }, {}], 76: [function(require2, module3, exports3) {
        module3.exports = function(array) {
          var out = {
            x: array[0],
            y: array[1]
          };
          if (array.length > 2) {
            out.z = array[2];
          }
          if (array.length > 3) {
            out.m = array[3];
          }
          return out;
        };
      }, {}], 77: [function(require2, module3, exports3) {
        var HALF_PI = Math.PI / 2;
        module3.exports = function(eccent, phi, sinphi) {
          var con = eccent * sinphi;
          var com = 0.5 * eccent;
          con = Math.pow((1 - con) / (1 + con), com);
          return Math.tan(0.5 * (HALF_PI - phi)) / con;
        };
      }, {}], 78: [function(require2, module3, exports3) {
        exports3.wgs84 = {
          towgs84: "0,0,0",
          ellipse: "WGS84",
          datumName: "WGS84"
        };
        exports3.ch1903 = {
          towgs84: "674.374,15.056,405.346",
          ellipse: "bessel",
          datumName: "swiss"
        };
        exports3.ggrs87 = {
          towgs84: "-199.87,74.79,246.62",
          ellipse: "GRS80",
          datumName: "Greek_Geodetic_Reference_System_1987"
        };
        exports3.nad83 = {
          towgs84: "0,0,0",
          ellipse: "GRS80",
          datumName: "North_American_Datum_1983"
        };
        exports3.nad27 = {
          nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
          ellipse: "clrk66",
          datumName: "North_American_Datum_1927"
        };
        exports3.potsdam = {
          towgs84: "606.0,23.0,413.0",
          ellipse: "bessel",
          datumName: "Potsdam Rauenberg 1950 DHDN"
        };
        exports3.carthage = {
          towgs84: "-263.0,6.0,431.0",
          ellipse: "clark80",
          datumName: "Carthage 1934 Tunisia"
        };
        exports3.hermannskogel = {
          towgs84: "653.0,-212.0,449.0",
          ellipse: "bessel",
          datumName: "Hermannskogel"
        };
        exports3.ire65 = {
          towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
          ellipse: "mod_airy",
          datumName: "Ireland 1965"
        };
        exports3.rassadiran = {
          towgs84: "-133.63,-157.5,-158.62",
          ellipse: "intl",
          datumName: "Rassadiran"
        };
        exports3.nzgd49 = {
          towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
          ellipse: "intl",
          datumName: "New Zealand Geodetic Datum 1949"
        };
        exports3.osgb36 = {
          towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
          ellipse: "airy",
          datumName: "Airy 1830"
        };
        exports3.s_jtsk = {
          towgs84: "589,76,480",
          ellipse: "bessel",
          datumName: "S-JTSK (Ferro)"
        };
        exports3.beduaram = {
          towgs84: "-106,-87,188",
          ellipse: "clrk80",
          datumName: "Beduaram"
        };
        exports3.gunung_segara = {
          towgs84: "-403,684,41",
          ellipse: "bessel",
          datumName: "Gunung Segara Jakarta"
        };
        exports3.rnb72 = {
          towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
          ellipse: "intl",
          datumName: "Reseau National Belge 1972"
        };
      }, {}], 79: [function(require2, module3, exports3) {
        exports3.MERIT = {
          a: 6378137,
          rf: 298.257,
          ellipseName: "MERIT 1983"
        };
        exports3.SGS85 = {
          a: 6378136,
          rf: 298.257,
          ellipseName: "Soviet Geodetic System 85"
        };
        exports3.GRS80 = {
          a: 6378137,
          rf: 298.257222101,
          ellipseName: "GRS 1980(IUGG, 1980)"
        };
        exports3.IAU76 = {
          a: 6378140,
          rf: 298.257,
          ellipseName: "IAU 1976"
        };
        exports3.airy = {
          a: 6377563396e-3,
          b: 635625691e-2,
          ellipseName: "Airy 1830"
        };
        exports3.APL4 = {
          a: 6378137,
          rf: 298.25,
          ellipseName: "Appl. Physics. 1965"
        };
        exports3.NWL9D = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "Naval Weapons Lab., 1965"
        };
        exports3.mod_airy = {
          a: 6377340189e-3,
          b: 6356034446e-3,
          ellipseName: "Modified Airy"
        };
        exports3.andrae = {
          a: 637710443e-2,
          rf: 300,
          ellipseName: "Andrae 1876 (Den., Iclnd.)"
        };
        exports3.aust_SA = {
          a: 6378160,
          rf: 298.25,
          ellipseName: "Australian Natl & S. Amer. 1969"
        };
        exports3.GRS67 = {
          a: 6378160,
          rf: 298.247167427,
          ellipseName: "GRS 67(IUGG 1967)"
        };
        exports3.bessel = {
          a: 6377397155e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841"
        };
        exports3.bess_nam = {
          a: 6377483865e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841 (Namibia)"
        };
        exports3.clrk66 = {
          a: 63782064e-1,
          b: 63565838e-1,
          ellipseName: "Clarke 1866"
        };
        exports3.clrk80 = {
          a: 6378249145e-3,
          rf: 293.4663,
          ellipseName: "Clarke 1880 mod."
        };
        exports3.clrk58 = {
          a: 6378293645208759e-9,
          rf: 294.2606763692654,
          ellipseName: "Clarke 1858"
        };
        exports3.CPM = {
          a: 63757387e-1,
          rf: 334.29,
          ellipseName: "Comm. des Poids et Mesures 1799"
        };
        exports3.delmbr = {
          a: 6376428,
          rf: 311.5,
          ellipseName: "Delambre 1810 (Belgium)"
        };
        exports3.engelis = {
          a: 637813605e-2,
          rf: 298.2566,
          ellipseName: "Engelis 1985"
        };
        exports3.evrst30 = {
          a: 6377276345e-3,
          rf: 300.8017,
          ellipseName: "Everest 1830"
        };
        exports3.evrst48 = {
          a: 6377304063e-3,
          rf: 300.8017,
          ellipseName: "Everest 1948"
        };
        exports3.evrst56 = {
          a: 6377301243e-3,
          rf: 300.8017,
          ellipseName: "Everest 1956"
        };
        exports3.evrst69 = {
          a: 6377295664e-3,
          rf: 300.8017,
          ellipseName: "Everest 1969"
        };
        exports3.evrstSS = {
          a: 6377298556e-3,
          rf: 300.8017,
          ellipseName: "Everest (Sabah & Sarawak)"
        };
        exports3.fschr60 = {
          a: 6378166,
          rf: 298.3,
          ellipseName: "Fischer (Mercury Datum) 1960"
        };
        exports3.fschr60m = {
          a: 6378155,
          rf: 298.3,
          ellipseName: "Fischer 1960"
        };
        exports3.fschr68 = {
          a: 6378150,
          rf: 298.3,
          ellipseName: "Fischer 1968"
        };
        exports3.helmert = {
          a: 6378200,
          rf: 298.3,
          ellipseName: "Helmert 1906"
        };
        exports3.hough = {
          a: 6378270,
          rf: 297,
          ellipseName: "Hough"
        };
        exports3.intl = {
          a: 6378388,
          rf: 297,
          ellipseName: "International 1909 (Hayford)"
        };
        exports3.kaula = {
          a: 6378163,
          rf: 298.24,
          ellipseName: "Kaula 1961"
        };
        exports3.lerch = {
          a: 6378139,
          rf: 298.257,
          ellipseName: "Lerch 1979"
        };
        exports3.mprts = {
          a: 6397300,
          rf: 191,
          ellipseName: "Maupertius 1738"
        };
        exports3.new_intl = {
          a: 63781575e-1,
          b: 63567722e-1,
          ellipseName: "New International 1967"
        };
        exports3.plessis = {
          a: 6376523,
          rf: 6355863,
          ellipseName: "Plessis 1817 (France)"
        };
        exports3.krass = {
          a: 6378245,
          rf: 298.3,
          ellipseName: "Krassovsky, 1942"
        };
        exports3.SEasia = {
          a: 6378155,
          b: 63567733205e-4,
          ellipseName: "Southeast Asia"
        };
        exports3.walbeck = {
          a: 6376896,
          b: 63558348467e-4,
          ellipseName: "Walbeck"
        };
        exports3.WGS60 = {
          a: 6378165,
          rf: 298.3,
          ellipseName: "WGS 60"
        };
        exports3.WGS66 = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "WGS 66"
        };
        exports3.WGS7 = {
          a: 6378135,
          rf: 298.26,
          ellipseName: "WGS 72"
        };
        exports3.WGS84 = {
          a: 6378137,
          rf: 298.257223563,
          ellipseName: "WGS 84"
        };
        exports3.sphere = {
          a: 6370997,
          b: 6370997,
          ellipseName: "Normal Sphere (r=6370997)"
        };
      }, {}], 80: [function(require2, module3, exports3) {
        exports3.greenwich = 0;
        exports3.lisbon = -9.131906111111;
        exports3.paris = 2.337229166667;
        exports3.bogota = -74.080916666667;
        exports3.madrid = -3.687938888889;
        exports3.rome = 12.452333333333;
        exports3.bern = 7.439583333333;
        exports3.jakarta = 106.807719444444;
        exports3.ferro = -17.666666666667;
        exports3.brussels = 4.367975;
        exports3.stockholm = 18.058277777778;
        exports3.athens = 23.7163375;
        exports3.oslo = 10.722916666667;
      }, {}], 81: [function(require2, module3, exports3) {
        exports3.ft = { to_meter: 0.3048 };
        exports3["us-ft"] = { to_meter: 1200 / 3937 };
      }, {}], 82: [function(require2, module3, exports3) {
        var proj = require2("./Proj");
        var transform = require2("./transform");
        var wgs84 = proj("WGS84");
        function transformer(from, to, coords) {
          var transformedArray;
          if (Array.isArray(coords)) {
            transformedArray = transform(from, to, coords);
            if (coords.length === 3) {
              return [transformedArray.x, transformedArray.y, transformedArray.z];
            } else {
              return [transformedArray.x, transformedArray.y];
            }
          } else {
            return transform(from, to, coords);
          }
        }
        function checkProj(item) {
          if (item instanceof proj) {
            return item;
          }
          if (item.oProj) {
            return item.oProj;
          }
          return proj(item);
        }
        function proj4(fromProj, toProj, coord) {
          fromProj = checkProj(fromProj);
          var single = false;
          var obj;
          if (typeof toProj === "undefined") {
            toProj = fromProj;
            fromProj = wgs84;
            single = true;
          } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
            coord = toProj;
            toProj = fromProj;
            fromProj = wgs84;
            single = true;
          }
          toProj = checkProj(toProj);
          if (coord) {
            return transformer(fromProj, toProj, coord);
          } else {
            obj = {
              forward: function(coords) {
                return transformer(fromProj, toProj, coords);
              },
              inverse: function(coords) {
                return transformer(toProj, fromProj, coords);
              }
            };
            if (single) {
              obj.oProj = toProj;
            }
            return obj;
          }
        }
        module3.exports = proj4;
      }, { "./Proj": 55, "./transform": 119 }], 83: [function(require2, module3, exports3) {
        var HALF_PI = Math.PI / 2;
        var PJD_3PARAM = 1;
        var PJD_7PARAM = 2;
        var PJD_GRIDSHIFT = 3;
        var PJD_WGS84 = 4;
        var PJD_NODATUM = 5;
        var SEC_TO_RAD = 484813681109536e-20;
        var AD_C = 1.0026;
        var COS_67P5 = 0.3826834323650898;
        var datum = function(proj) {
          if (!(this instanceof datum)) {
            return new datum(proj);
          }
          this.datum_type = PJD_WGS84;
          if (!proj) {
            return;
          }
          if (proj.datumCode && proj.datumCode === "none") {
            this.datum_type = PJD_NODATUM;
          }
          if (proj.datum_params) {
            this.datum_params = proj.datum_params.map(parseFloat);
            if (this.datum_params[0] !== 0 || this.datum_params[1] !== 0 || this.datum_params[2] !== 0) {
              this.datum_type = PJD_3PARAM;
            }
            if (this.datum_params.length > 3) {
              if (this.datum_params[3] !== 0 || this.datum_params[4] !== 0 || this.datum_params[5] !== 0 || this.datum_params[6] !== 0) {
                this.datum_type = PJD_7PARAM;
                this.datum_params[3] *= SEC_TO_RAD;
                this.datum_params[4] *= SEC_TO_RAD;
                this.datum_params[5] *= SEC_TO_RAD;
                this.datum_params[6] = this.datum_params[6] / 1e6 + 1;
              }
            }
          }
          this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;
          this.a = proj.a;
          this.b = proj.b;
          this.es = proj.es;
          this.ep2 = proj.ep2;
          if (this.datum_type === PJD_GRIDSHIFT) {
            this.grids = proj.grids;
          }
        };
        datum.prototype = {
          compare_datums: function(dest) {
            if (this.datum_type !== dest.datum_type) {
              return false;
            } else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 5e-11) {
              return false;
            } else if (this.datum_type === PJD_3PARAM) {
              return this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2];
            } else if (this.datum_type === PJD_7PARAM) {
              return this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6];
            } else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {
              return this.nadgrids === dest.nadgrids;
            } else {
              return true;
            }
          },
          geodetic_to_geocentric: function(p) {
            var Longitude = p.x;
            var Latitude = p.y;
            var Height = p.z ? p.z : 0;
            var X;
            var Y;
            var Z;
            var Error_Code = 0;
            var Rn;
            var Sin_Lat;
            var Sin2_Lat;
            var Cos_Lat;
            if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
              Latitude = -HALF_PI;
            } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
              Latitude = HALF_PI;
            } else if (Latitude < -HALF_PI || Latitude > HALF_PI) {
              return null;
            }
            if (Longitude > Math.PI) {
              Longitude -= 2 * Math.PI;
            }
            Sin_Lat = Math.sin(Latitude);
            Cos_Lat = Math.cos(Latitude);
            Sin2_Lat = Sin_Lat * Sin_Lat;
            Rn = this.a / Math.sqrt(1 - this.es * Sin2_Lat);
            X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);
            Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);
            Z = (Rn * (1 - this.es) + Height) * Sin_Lat;
            p.x = X;
            p.y = Y;
            p.z = Z;
            return Error_Code;
          },
          geocentric_to_geodetic: function(p) {
            var genau = 1e-12;
            var genau2 = genau * genau;
            var maxiter = 30;
            var P;
            var RR;
            var CT;
            var ST;
            var RX;
            var RK;
            var RN;
            var CPHI0;
            var SPHI0;
            var CPHI;
            var SPHI;
            var SDPHI;
            var At_Pole;
            var iter;
            var X = p.x;
            var Y = p.y;
            var Z = p.z ? p.z : 0;
            var Longitude;
            var Latitude;
            var Height;
            At_Pole = false;
            P = Math.sqrt(X * X + Y * Y);
            RR = Math.sqrt(X * X + Y * Y + Z * Z);
            if (P / this.a < genau) {
              At_Pole = true;
              Longitude = 0;
              if (RR / this.a < genau) {
                Latitude = HALF_PI;
                Height = -this.b;
                return;
              }
            } else {
              Longitude = Math.atan2(Y, X);
            }
            CT = Z / RR;
            ST = P / RR;
            RX = 1 / Math.sqrt(1 - this.es * (2 - this.es) * ST * ST);
            CPHI0 = ST * (1 - this.es) * RX;
            SPHI0 = CT * RX;
            iter = 0;
            do {
              iter++;
              RN = this.a / Math.sqrt(1 - this.es * SPHI0 * SPHI0);
              Height = P * CPHI0 + Z * SPHI0 - RN * (1 - this.es * SPHI0 * SPHI0);
              RK = this.es * RN / (RN + Height);
              RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
              CPHI = ST * (1 - RK) * RX;
              SPHI = CT * RX;
              SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
              CPHI0 = CPHI;
              SPHI0 = SPHI;
            } while (SDPHI * SDPHI > genau2 && iter < maxiter);
            Latitude = Math.atan(SPHI / Math.abs(CPHI));
            p.x = Longitude;
            p.y = Latitude;
            p.z = Height;
            return p;
          },
          geocentric_to_geodetic_noniter: function(p) {
            var X = p.x;
            var Y = p.y;
            var Z = p.z ? p.z : 0;
            var Longitude;
            var Latitude;
            var Height;
            var W;
            var W2;
            var T0;
            var T1;
            var S0;
            var S1;
            var Sin_B0;
            var Sin3_B0;
            var Cos_B0;
            var Sin_p1;
            var Cos_p1;
            var Rn;
            var Sum;
            var At_Pole;
            X = parseFloat(X);
            Y = parseFloat(Y);
            Z = parseFloat(Z);
            At_Pole = false;
            if (X !== 0) {
              Longitude = Math.atan2(Y, X);
            } else {
              if (Y > 0) {
                Longitude = HALF_PI;
              } else if (Y < 0) {
                Longitude = -HALF_PI;
              } else {
                At_Pole = true;
                Longitude = 0;
                if (Z > 0) {
                  Latitude = HALF_PI;
                } else if (Z < 0) {
                  Latitude = -HALF_PI;
                } else {
                  Latitude = HALF_PI;
                  Height = -this.b;
                  return;
                }
              }
            }
            W2 = X * X + Y * Y;
            W = Math.sqrt(W2);
            T0 = Z * AD_C;
            S0 = Math.sqrt(T0 * T0 + W2);
            Sin_B0 = T0 / S0;
            Cos_B0 = W / S0;
            Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;
            T1 = Z + this.b * this.ep2 * Sin3_B0;
            Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;
            S1 = Math.sqrt(T1 * T1 + Sum * Sum);
            Sin_p1 = T1 / S1;
            Cos_p1 = Sum / S1;
            Rn = this.a / Math.sqrt(1 - this.es * Sin_p1 * Sin_p1);
            if (Cos_p1 >= COS_67P5) {
              Height = W / Cos_p1 - Rn;
            } else if (Cos_p1 <= -COS_67P5) {
              Height = W / -Cos_p1 - Rn;
            } else {
              Height = Z / Sin_p1 + Rn * (this.es - 1);
            }
            if (At_Pole === false) {
              Latitude = Math.atan(Sin_p1 / Cos_p1);
            }
            p.x = Longitude;
            p.y = Latitude;
            p.z = Height;
            return p;
          },
          geocentric_to_wgs84: function(p) {
            if (this.datum_type === PJD_3PARAM) {
              p.x += this.datum_params[0];
              p.y += this.datum_params[1];
              p.z += this.datum_params[2];
            } else if (this.datum_type === PJD_7PARAM) {
              var Dx_BF = this.datum_params[0];
              var Dy_BF = this.datum_params[1];
              var Dz_BF = this.datum_params[2];
              var Rx_BF = this.datum_params[3];
              var Ry_BF = this.datum_params[4];
              var Rz_BF = this.datum_params[5];
              var M_BF = this.datum_params[6];
              var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;
              var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;
              var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;
              p.x = x_out;
              p.y = y_out;
              p.z = z_out;
            }
          },
          geocentric_from_wgs84: function(p) {
            if (this.datum_type === PJD_3PARAM) {
              p.x -= this.datum_params[0];
              p.y -= this.datum_params[1];
              p.z -= this.datum_params[2];
            } else if (this.datum_type === PJD_7PARAM) {
              var Dx_BF = this.datum_params[0];
              var Dy_BF = this.datum_params[1];
              var Dz_BF = this.datum_params[2];
              var Rx_BF = this.datum_params[3];
              var Ry_BF = this.datum_params[4];
              var Rz_BF = this.datum_params[5];
              var M_BF = this.datum_params[6];
              var x_tmp = (p.x - Dx_BF) / M_BF;
              var y_tmp = (p.y - Dy_BF) / M_BF;
              var z_tmp = (p.z - Dz_BF) / M_BF;
              p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;
              p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;
              p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;
            }
          }
        };
        module3.exports = datum;
      }, {}], 84: [function(require2, module3, exports3) {
        var PJD_3PARAM = 1;
        var PJD_7PARAM = 2;
        var PJD_GRIDSHIFT = 3;
        var PJD_NODATUM = 5;
        var SRS_WGS84_SEMIMAJOR = 6378137;
        var SRS_WGS84_ESQUARED = 0.006694379990141316;
        module3.exports = function(source, dest, point) {
          var wp, i, l;
          function checkParams(fallback2) {
            return fallback2 === PJD_3PARAM || fallback2 === PJD_7PARAM;
          }
          if (source.compare_datums(dest)) {
            return point;
          }
          if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
            return point;
          }
          var src_a = source.a;
          var src_es = source.es;
          var dst_a = dest.a;
          var dst_es = dest.es;
          var fallback = source.datum_type;
          if (fallback === PJD_GRIDSHIFT) {
            if (this.apply_gridshift(source, 0, point) === 0) {
              source.a = SRS_WGS84_SEMIMAJOR;
              source.es = SRS_WGS84_ESQUARED;
            } else {
              if (!source.datum_params) {
                source.a = src_a;
                source.es = source.es;
                return point;
              }
              wp = 1;
              for (i = 0, l = source.datum_params.length; i < l; i++) {
                wp *= source.datum_params[i];
              }
              if (wp === 0) {
                source.a = src_a;
                source.es = source.es;
                return point;
              }
              if (source.datum_params.length > 3) {
                fallback = PJD_7PARAM;
              } else {
                fallback = PJD_3PARAM;
              }
            }
          }
          if (dest.datum_type === PJD_GRIDSHIFT) {
            dest.a = SRS_WGS84_SEMIMAJOR;
            dest.es = SRS_WGS84_ESQUARED;
          }
          if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {
            source.geodetic_to_geocentric(point);
            if (checkParams(source.datum_type)) {
              source.geocentric_to_wgs84(point);
            }
            if (checkParams(dest.datum_type)) {
              dest.geocentric_from_wgs84(point);
            }
            dest.geocentric_to_geodetic(point);
          }
          if (dest.datum_type === PJD_GRIDSHIFT) {
            this.apply_gridshift(dest, 1, point);
          }
          source.a = src_a;
          source.es = src_es;
          dest.a = dst_a;
          dest.es = dst_es;
          return point;
        };
      }, {}], 85: [function(require2, module3, exports3) {
        var globals = require2("./global");
        var parseProj = require2("./projString");
        var wkt = require2("./wkt");
        function defs(name) {
          var that = this;
          if (arguments.length === 2) {
            var def = arguments[1];
            if (typeof def === "string") {
              if (def.charAt(0) === "+") {
                defs[name] = parseProj(arguments[1]);
              } else {
                defs[name] = wkt(arguments[1]);
              }
            } else {
              defs[name] = def;
            }
          } else if (arguments.length === 1) {
            if (Array.isArray(name)) {
              return name.map(function(v) {
                if (Array.isArray(v)) {
                  defs.apply(that, v);
                } else {
                  defs(v);
                }
              });
            } else if (typeof name === "string") {
              if (name in defs) {
                return defs[name];
              }
            } else if ("EPSG" in name) {
              defs["EPSG:" + name.EPSG] = name;
            } else if ("ESRI" in name) {
              defs["ESRI:" + name.ESRI] = name;
            } else if ("IAU2000" in name) {
              defs["IAU2000:" + name.IAU2000] = name;
            } else {
              console.log(name);
            }
            return;
          }
        }
        globals(defs);
        module3.exports = defs;
      }, { "./global": 88, "./projString": 92, "./wkt": 120 }], 86: [function(require2, module3, exports3) {
        var Datum = require2("./constants/Datum");
        var Ellipsoid = require2("./constants/Ellipsoid");
        var extend = require2("./extend");
        var datum = require2("./datum");
        var EPSLN = 1e-10;
        var SIXTH = 0.16666666666666666;
        var RA4 = 0.04722222222222222;
        var RA6 = 0.022156084656084655;
        module3.exports = function(json) {
          if (json.datumCode && json.datumCode !== "none") {
            var datumDef = Datum[json.datumCode];
            if (datumDef) {
              json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(",") : null;
              json.ellps = datumDef.ellipse;
              json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
            }
          }
          if (!json.a) {
            var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;
            extend(json, ellipse);
          }
          if (json.rf && !json.b) {
            json.b = (1 - 1 / json.rf) * json.a;
          }
          if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {
            json.sphere = true;
            json.b = json.a;
          }
          json.a2 = json.a * json.a;
          json.b2 = json.b * json.b;
          json.es = (json.a2 - json.b2) / json.a2;
          json.e = Math.sqrt(json.es);
          if (json.R_A) {
            json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));
            json.a2 = json.a * json.a;
            json.b2 = json.b * json.b;
            json.es = 0;
          }
          json.ep2 = (json.a2 - json.b2) / json.b2;
          if (!json.k0) {
            json.k0 = 1;
          }
          if (!json.axis) {
            json.axis = "enu";
          }
          if (!json.datum) {
            json.datum = datum(json);
          }
          return json;
        };
      }, { "./constants/Datum": 78, "./constants/Ellipsoid": 79, "./datum": 83, "./extend": 87 }], 87: [function(require2, module3, exports3) {
        module3.exports = function(destination, source) {
          destination = destination || {};
          var value, property;
          if (!source) {
            return destination;
          }
          for (property in source) {
            value = source[property];
            if (value !== void 0) {
              destination[property] = value;
            }
          }
          return destination;
        };
      }, {}], 88: [function(require2, module3, exports3) {
        module3.exports = function(defs) {
          defs("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
          defs("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
          defs("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
          defs.WGS84 = defs["EPSG:4326"];
          defs["EPSG:3785"] = defs["EPSG:3857"];
          defs.GOOGLE = defs["EPSG:3857"];
          defs["EPSG:900913"] = defs["EPSG:3857"];
          defs["EPSG:102113"] = defs["EPSG:3857"];
        };
      }, {}], 89: [function(require2, module3, exports3) {
        var projs = [
          require2("./projections/tmerc"),
          require2("./projections/utm"),
          require2("./projections/sterea"),
          require2("./projections/stere"),
          require2("./projections/somerc"),
          require2("./projections/omerc"),
          require2("./projections/lcc"),
          require2("./projections/krovak"),
          require2("./projections/cass"),
          require2("./projections/laea"),
          require2("./projections/aea"),
          require2("./projections/gnom"),
          require2("./projections/cea"),
          require2("./projections/eqc"),
          require2("./projections/poly"),
          require2("./projections/nzmg"),
          require2("./projections/mill"),
          require2("./projections/sinu"),
          require2("./projections/moll"),
          require2("./projections/eqdc"),
          require2("./projections/vandg"),
          require2("./projections/aeqd")
        ];
        module3.exports = function(proj4) {
          projs.forEach(function(proj) {
            proj4.Proj.projections.add(proj);
          });
        };
      }, { "./projections/aea": 94, "./projections/aeqd": 95, "./projections/cass": 96, "./projections/cea": 97, "./projections/eqc": 98, "./projections/eqdc": 99, "./projections/gnom": 101, "./projections/krovak": 102, "./projections/laea": 103, "./projections/lcc": 104, "./projections/mill": 107, "./projections/moll": 108, "./projections/nzmg": 109, "./projections/omerc": 110, "./projections/poly": 111, "./projections/sinu": 112, "./projections/somerc": 113, "./projections/stere": 114, "./projections/sterea": 115, "./projections/tmerc": 116, "./projections/utm": 117, "./projections/vandg": 118 }], 90: [function(require2, module3, exports3) {
        var proj4 = require2("./core");
        proj4.defaultDatum = "WGS84";
        proj4.Proj = require2("./Proj");
        proj4.WGS84 = new proj4.Proj("WGS84");
        proj4.Point = require2("./Point");
        proj4.toPoint = require2("./common/toPoint");
        proj4.defs = require2("./defs");
        proj4.transform = require2("./transform");
        proj4.mgrs = require2("mgrs");
        proj4.version = require2("../package.json").version;
        require2("./includedProjections")(proj4);
        module3.exports = proj4;
      }, { "../package.json": 121, "./Point": 54, "./Proj": 55, "./common/toPoint": 76, "./core": 82, "./defs": 85, "./includedProjections": 89, "./transform": 119, "mgrs": 36 }], 91: [function(require2, module3, exports3) {
        var defs = require2("./defs");
        var wkt = require2("./wkt");
        var projStr = require2("./projString");
        function testObj(code) {
          return typeof code === "string";
        }
        function testDef(code) {
          return code in defs;
        }
        function testWKT(code) {
          var codeWords = ["GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS"];
          return codeWords.reduce(function(a, b) {
            return a + 1 + code.indexOf(b);
          }, 0);
        }
        function testProj(code) {
          return code[0] === "+";
        }
        function parse(code) {
          if (testObj(code)) {
            if (testDef(code)) {
              return defs[code];
            } else if (testWKT(code)) {
              return wkt(code);
            } else if (testProj(code)) {
              return projStr(code);
            }
          } else {
            return code;
          }
        }
        module3.exports = parse;
      }, { "./defs": 85, "./projString": 92, "./wkt": 120 }], 92: [function(require2, module3, exports3) {
        var D2R = 0.017453292519943295;
        var PrimeMeridian = require2("./constants/PrimeMeridian");
        var units = require2("./constants/units");
        module3.exports = function(defData) {
          var self2 = {};
          var paramObj = {};
          defData.split("+").map(function(v) {
            return v.trim();
          }).filter(function(a) {
            return a;
          }).forEach(function(a) {
            var split = a.split("=");
            split.push(true);
            paramObj[split[0].toLowerCase()] = split[1];
          });
          var paramName, paramVal, paramOutname;
          var params = {
            proj: "projName",
            datum: "datumCode",
            rf: function(v) {
              self2.rf = parseFloat(v);
            },
            lat_0: function(v) {
              self2.lat0 = v * D2R;
            },
            lat_1: function(v) {
              self2.lat1 = v * D2R;
            },
            lat_2: function(v) {
              self2.lat2 = v * D2R;
            },
            lat_ts: function(v) {
              self2.lat_ts = v * D2R;
            },
            lon_0: function(v) {
              self2.long0 = v * D2R;
            },
            lon_1: function(v) {
              self2.long1 = v * D2R;
            },
            lon_2: function(v) {
              self2.long2 = v * D2R;
            },
            alpha: function(v) {
              self2.alpha = parseFloat(v) * D2R;
            },
            lonc: function(v) {
              self2.longc = v * D2R;
            },
            x_0: function(v) {
              self2.x0 = parseFloat(v);
            },
            y_0: function(v) {
              self2.y0 = parseFloat(v);
            },
            k_0: function(v) {
              self2.k0 = parseFloat(v);
            },
            k: function(v) {
              self2.k0 = parseFloat(v);
            },
            a: function(v) {
              self2.a = parseFloat(v);
            },
            b: function(v) {
              self2.b = parseFloat(v);
            },
            r_a: function() {
              self2.R_A = true;
            },
            zone: function(v) {
              self2.zone = parseInt(v, 10);
            },
            south: function() {
              self2.utmSouth = true;
            },
            towgs84: function(v) {
              self2.datum_params = v.split(",").map(function(a) {
                return parseFloat(a);
              });
            },
            to_meter: function(v) {
              self2.to_meter = parseFloat(v);
            },
            units: function(v) {
              self2.units = v;
              if (units[v]) {
                self2.to_meter = units[v].to_meter;
              }
            },
            from_greenwich: function(v) {
              self2.from_greenwich = v * D2R;
            },
            pm: function(v) {
              self2.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
            },
            nadgrids: function(v) {
              if (v === "@null") {
                self2.datumCode = "none";
              } else {
                self2.nadgrids = v;
              }
            },
            axis: function(v) {
              var legalAxis = "ewnsud";
              if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
                self2.axis = v;
              }
            }
          };
          for (paramName in paramObj) {
            paramVal = paramObj[paramName];
            if (paramName in params) {
              paramOutname = params[paramName];
              if (typeof paramOutname === "function") {
                paramOutname(paramVal);
              } else {
                self2[paramOutname] = paramVal;
              }
            } else {
              self2[paramName] = paramVal;
            }
          }
          if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
            self2.datumCode = self2.datumCode.toLowerCase();
          }
          return self2;
        };
      }, { "./constants/PrimeMeridian": 80, "./constants/units": 81 }], 93: [function(require2, module3, exports3) {
        var projs = [
          require2("./projections/merc"),
          require2("./projections/longlat")
        ];
        var names = {};
        var projStore = [];
        function add(proj, i) {
          var len = projStore.length;
          if (!proj.names) {
            console.log(i);
            return true;
          }
          projStore[len] = proj;
          proj.names.forEach(function(n) {
            names[n.toLowerCase()] = len;
          });
          return this;
        }
        exports3.add = add;
        exports3.get = function(name) {
          if (!name) {
            return false;
          }
          var n = name.toLowerCase();
          if (typeof names[n] !== "undefined" && projStore[names[n]]) {
            return projStore[names[n]];
          }
        };
        exports3.start = function() {
          projs.forEach(add);
        };
      }, { "./projections/longlat": 105, "./projections/merc": 106 }], 94: [function(require2, module3, exports3) {
        var EPSLN = 1e-10;
        var msfnz = require2("../common/msfnz");
        var qsfnz = require2("../common/qsfnz");
        var adjust_lon = require2("../common/adjust_lon");
        var asinz = require2("../common/asinz");
        exports3.init = function() {
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e3 = Math.sqrt(this.es);
          this.sin_po = Math.sin(this.lat1);
          this.cos_po = Math.cos(this.lat1);
          this.t1 = this.sin_po;
          this.con = this.sin_po;
          this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
          this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
          this.sin_po = Math.sin(this.lat2);
          this.cos_po = Math.cos(this.lat2);
          this.t2 = this.sin_po;
          this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
          this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
          this.sin_po = Math.sin(this.lat0);
          this.cos_po = Math.cos(this.lat0);
          this.t3 = this.sin_po;
          this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
          if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
            this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
          } else {
            this.ns0 = this.con;
          }
          this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
          this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          this.sin_phi = Math.sin(lat);
          this.cos_phi = Math.cos(lat);
          var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
          var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
          var theta = this.ns0 * adjust_lon(lon - this.long0);
          var x = rh1 * Math.sin(theta) + this.x0;
          var y = this.rh - rh1 * Math.cos(theta) + this.y0;
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          var rh1, qs, con, theta, lon, lat;
          p.x -= this.x0;
          p.y = this.rh - p.y + this.y0;
          if (this.ns0 >= 0) {
            rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
            con = -1;
          }
          theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * p.x, con * p.y);
          }
          con = rh1 * this.ns0 / this.a;
          if (this.sphere) {
            lat = Math.asin((this.c - con * con) / (2 * this.ns0));
          } else {
            qs = (this.c - con * con) / this.ns0;
            lat = this.phi1z(this.e3, qs);
          }
          lon = adjust_lon(theta / this.ns0 + this.long0);
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.phi1z = function(eccent, qs) {
          var sinphi, cosphi, con, com, dphi;
          var phi = asinz(0.5 * qs);
          if (eccent < EPSLN) {
            return phi;
          }
          var eccnts = eccent * eccent;
          for (var i = 1; i <= 25; i++) {
            sinphi = Math.sin(phi);
            cosphi = Math.cos(phi);
            con = eccent * sinphi;
            com = 1 - con * con;
            dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
            phi = phi + dphi;
            if (Math.abs(dphi) <= 1e-7) {
              return phi;
            }
          }
          return null;
        };
        exports3.names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
      }, { "../common/adjust_lon": 58, "../common/asinz": 59, "../common/msfnz": 68, "../common/qsfnz": 73 }], 95: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        var HALF_PI = Math.PI / 2;
        var EPSLN = 1e-10;
        var mlfn = require2("../common/mlfn");
        var e0fn = require2("../common/e0fn");
        var e1fn = require2("../common/e1fn");
        var e2fn = require2("../common/e2fn");
        var e3fn = require2("../common/e3fn");
        var gN = require2("../common/gN");
        var asinz = require2("../common/asinz");
        var imlfn = require2("../common/imlfn");
        exports3.init = function() {
          this.sin_p12 = Math.sin(this.lat0);
          this.cos_p12 = Math.cos(this.lat0);
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var sinphi = Math.sin(p.y);
          var cosphi = Math.cos(p.y);
          var dlon = adjust_lon(lon - this.long0);
          var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
          if (this.sphere) {
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
              p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
              p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
              return p;
            } else {
              cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
              c = Math.acos(cos_c);
              kp = c / Math.sin(c);
              p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
              p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
              return p;
            }
          } else {
            e0 = e0fn(this.es);
            e1 = e1fn(this.es);
            e2 = e2fn(this.es);
            e3 = e3fn(this.es);
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              Ml = this.a * mlfn(e0, e1, e2, e3, lat);
              p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
              p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              Ml = this.a * mlfn(e0, e1, e2, e3, lat);
              p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
              p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
              return p;
            } else {
              tanphi = sinphi / cosphi;
              Nl1 = gN(this.a, this.e, this.sin_p12);
              Nl = gN(this.a, this.e, sinphi);
              psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
              Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
              if (Az === 0) {
                s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
              } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
                s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
              } else {
                s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
              }
              G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
              H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
              GH = G * H;
              Hs = H * H;
              s2 = s * s;
              s3 = s2 * s;
              s4 = s3 * s;
              s5 = s4 * s;
              c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
              p.x = this.x0 + c * Math.sin(Az);
              p.y = this.y0 + c * Math.cos(Az);
              return p;
            }
          }
        };
        exports3.inverse = function(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
          if (this.sphere) {
            rh = Math.sqrt(p.x * p.x + p.y * p.y);
            if (rh > 2 * HALF_PI * this.a) {
              return;
            }
            z = rh / this.a;
            sinz = Math.sin(z);
            cosz = Math.cos(z);
            lon = this.long0;
            if (Math.abs(rh) <= EPSLN) {
              lat = this.lat0;
            } else {
              lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
              con = Math.abs(this.lat0) - HALF_PI;
              if (Math.abs(con) <= EPSLN) {
                if (this.lat0 >= 0) {
                  lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
                } else {
                  lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
                }
              } else {
                lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
              }
            }
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            e0 = e0fn(this.es);
            e1 = e1fn(this.es);
            e2 = e2fn(this.es);
            e3 = e3fn(this.es);
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              M = Mlp - rh;
              lat = imlfn(M / this.a, e0, e1, e2, e3);
              lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
              p.x = lon;
              p.y = lat;
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              M = rh - Mlp;
              lat = imlfn(M / this.a, e0, e1, e2, e3);
              lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
              p.x = lon;
              p.y = lat;
              return p;
            } else {
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              Az = Math.atan2(p.x, p.y);
              N1 = gN(this.a, this.e, this.sin_p12);
              cosAz = Math.cos(Az);
              tmp = this.e * this.cos_p12 * cosAz;
              A = -tmp * tmp / (1 - this.es);
              B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
              D = rh / N1;
              Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
              F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
              psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
              lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
              lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
              p.x = lon;
              p.y = lat;
              return p;
            }
          }
        };
        exports3.names = ["Azimuthal_Equidistant", "aeqd"];
      }, { "../common/adjust_lon": 58, "../common/asinz": 59, "../common/e0fn": 60, "../common/e1fn": 61, "../common/e2fn": 62, "../common/e3fn": 63, "../common/gN": 64, "../common/imlfn": 65, "../common/mlfn": 67 }], 96: [function(require2, module3, exports3) {
        var mlfn = require2("../common/mlfn");
        var e0fn = require2("../common/e0fn");
        var e1fn = require2("../common/e1fn");
        var e2fn = require2("../common/e2fn");
        var e3fn = require2("../common/e3fn");
        var gN = require2("../common/gN");
        var adjust_lon = require2("../common/adjust_lon");
        var adjust_lat = require2("../common/adjust_lat");
        var imlfn = require2("../common/imlfn");
        var HALF_PI = Math.PI / 2;
        var EPSLN = 1e-10;
        exports3.init = function() {
          if (!this.sphere) {
            this.e0 = e0fn(this.es);
            this.e1 = e1fn(this.es);
            this.e2 = e2fn(this.es);
            this.e3 = e3fn(this.es);
            this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
          }
        };
        exports3.forward = function(p) {
          var x, y;
          var lam = p.x;
          var phi = p.y;
          lam = adjust_lon(lam - this.long0);
          if (this.sphere) {
            x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
            y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
          } else {
            var sinphi = Math.sin(phi);
            var cosphi = Math.cos(phi);
            var nl = gN(this.a, this.e, sinphi);
            var tl = Math.tan(phi) * Math.tan(phi);
            var al = lam * Math.cos(phi);
            var asq = al * al;
            var cl = this.es * cosphi * cosphi / (1 - this.es);
            var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
            x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
            y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
          }
          p.x = x + this.x0;
          p.y = y + this.y0;
          return p;
        };
        exports3.inverse = function(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var x = p.x / this.a;
          var y = p.y / this.a;
          var phi, lam;
          if (this.sphere) {
            var dd = y + this.lat0;
            phi = Math.asin(Math.sin(dd) * Math.cos(x));
            lam = Math.atan2(Math.tan(x), Math.cos(dd));
          } else {
            var ml1 = this.ml0 / this.a + y;
            var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
            if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
              p.x = this.long0;
              p.y = HALF_PI;
              if (y < 0) {
                p.y *= -1;
              }
              return p;
            }
            var nl1 = gN(this.a, this.e, Math.sin(phi1));
            var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
            var tl1 = Math.pow(Math.tan(phi1), 2);
            var dl = x * this.a / nl1;
            var dsq = dl * dl;
            phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
            lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
          }
          p.x = adjust_lon(lam + this.long0);
          p.y = adjust_lat(phi);
          return p;
        };
        exports3.names = ["Cassini", "Cassini_Soldner", "cass"];
      }, { "../common/adjust_lat": 57, "../common/adjust_lon": 58, "../common/e0fn": 60, "../common/e1fn": 61, "../common/e2fn": 62, "../common/e3fn": 63, "../common/gN": 64, "../common/imlfn": 65, "../common/mlfn": 67 }], 97: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        var qsfnz = require2("../common/qsfnz");
        var msfnz = require2("../common/msfnz");
        var iqsfnz = require2("../common/iqsfnz");
        exports3.init = function() {
          if (!this.sphere) {
            this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
          }
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var x, y;
          var dlon = adjust_lon(lon - this.long0);
          if (this.sphere) {
            x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
            y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
          } else {
            var qs = qsfnz(this.e, Math.sin(lat));
            x = this.x0 + this.a * this.k0 * dlon;
            y = this.y0 + this.a * qs * 0.5 / this.k0;
          }
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon, lat;
          if (this.sphere) {
            lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
            lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
          } else {
            lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
            lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
          }
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["cea"];
      }, { "../common/adjust_lon": 58, "../common/iqsfnz": 66, "../common/msfnz": 68, "../common/qsfnz": 73 }], 98: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        var adjust_lat = require2("../common/adjust_lat");
        exports3.init = function() {
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          this.lat0 = this.lat0 || 0;
          this.long0 = this.long0 || 0;
          this.lat_ts = this.lat_ts || 0;
          this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
          this.rc = Math.cos(this.lat_ts);
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var dlat = adjust_lat(lat - this.lat0);
          p.x = this.x0 + this.a * dlon * this.rc;
          p.y = this.y0 + this.a * dlat;
          return p;
        };
        exports3.inverse = function(p) {
          var x = p.x;
          var y = p.y;
          p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
          p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
          return p;
        };
        exports3.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
      }, { "../common/adjust_lat": 57, "../common/adjust_lon": 58 }], 99: [function(require2, module3, exports3) {
        var e0fn = require2("../common/e0fn");
        var e1fn = require2("../common/e1fn");
        var e2fn = require2("../common/e2fn");
        var e3fn = require2("../common/e3fn");
        var msfnz = require2("../common/msfnz");
        var mlfn = require2("../common/mlfn");
        var adjust_lon = require2("../common/adjust_lon");
        var adjust_lat = require2("../common/adjust_lat");
        var imlfn = require2("../common/imlfn");
        var EPSLN = 1e-10;
        exports3.init = function() {
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          this.lat2 = this.lat2 || this.lat1;
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e = Math.sqrt(this.es);
          this.e0 = e0fn(this.es);
          this.e1 = e1fn(this.es);
          this.e2 = e2fn(this.es);
          this.e3 = e3fn(this.es);
          this.sinphi = Math.sin(this.lat1);
          this.cosphi = Math.cos(this.lat1);
          this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
          this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
          if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
            this.ns = this.sinphi;
          } else {
            this.sinphi = Math.sin(this.lat2);
            this.cosphi = Math.cos(this.lat2);
            this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
            this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
            this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
          }
          this.g = this.ml1 + this.ms1 / this.ns;
          this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
          this.rh = this.a * (this.g - this.ml0);
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var rh1;
          if (this.sphere) {
            rh1 = this.a * (this.g - lat);
          } else {
            var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
            rh1 = this.a * (this.g - ml);
          }
          var theta = this.ns * adjust_lon(lon - this.long0);
          var x = this.x0 + rh1 * Math.sin(theta);
          var y = this.y0 + this.rh - rh1 * Math.cos(theta);
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          p.x -= this.x0;
          p.y = this.rh - p.y + this.y0;
          var con, rh1, lat, lon;
          if (this.ns >= 0) {
            rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
            con = -1;
          }
          var theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * p.x, con * p.y);
          }
          if (this.sphere) {
            lon = adjust_lon(this.long0 + theta / this.ns);
            lat = adjust_lat(this.g - rh1 / this.a);
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            var ml = this.g - rh1 / this.a;
            lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
            lon = adjust_lon(this.long0 + theta / this.ns);
            p.x = lon;
            p.y = lat;
            return p;
          }
        };
        exports3.names = ["Equidistant_Conic", "eqdc"];
      }, { "../common/adjust_lat": 57, "../common/adjust_lon": 58, "../common/e0fn": 60, "../common/e1fn": 61, "../common/e2fn": 62, "../common/e3fn": 63, "../common/imlfn": 65, "../common/mlfn": 67, "../common/msfnz": 68 }], 100: [function(require2, module3, exports3) {
        var FORTPI = Math.PI / 4;
        var srat = require2("../common/srat");
        var HALF_PI = Math.PI / 2;
        var MAX_ITER = 20;
        exports3.init = function() {
          var sphi = Math.sin(this.lat0);
          var cphi = Math.cos(this.lat0);
          cphi *= cphi;
          this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
          this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
          this.phic0 = Math.asin(sphi / this.C);
          this.ratexp = 0.5 * this.C * this.e;
          this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
          p.x = this.C * lon;
          return p;
        };
        exports3.inverse = function(p) {
          var DEL_TOL = 1e-14;
          var lon = p.x / this.C;
          var lat = p.y;
          var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
          for (var i = MAX_ITER; i > 0; --i) {
            lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
            if (Math.abs(lat - p.y) < DEL_TOL) {
              break;
            }
            p.y = lat;
          }
          if (!i) {
            return null;
          }
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["gauss"];
      }, { "../common/srat": 75 }], 101: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        var EPSLN = 1e-10;
        var asinz = require2("../common/asinz");
        exports3.init = function() {
          this.sin_p14 = Math.sin(this.lat0);
          this.cos_p14 = Math.cos(this.lat0);
          this.infinity_dist = 1e3 * this.a;
          this.rc = 1;
        };
        exports3.forward = function(p) {
          var sinphi, cosphi;
          var dlon;
          var coslon;
          var ksp;
          var g;
          var x, y;
          var lon = p.x;
          var lat = p.y;
          dlon = adjust_lon(lon - this.long0);
          sinphi = Math.sin(lat);
          cosphi = Math.cos(lat);
          coslon = Math.cos(dlon);
          g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
          ksp = 1;
          if (g > 0 || Math.abs(g) <= EPSLN) {
            x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
            y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
          } else {
            x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
            y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
          }
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          var rh;
          var sinc, cosc;
          var c;
          var lon, lat;
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          p.x /= this.k0;
          p.y /= this.k0;
          if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
            c = Math.atan2(rh, this.rc);
            sinc = Math.sin(c);
            cosc = Math.cos(c);
            lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
            lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
            lon = adjust_lon(this.long0 + lon);
          } else {
            lat = this.phic0;
            lon = 0;
          }
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["gnom"];
      }, { "../common/adjust_lon": 58, "../common/asinz": 59 }], 102: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        exports3.init = function() {
          this.a = 6377397155e-3;
          this.es = 0.006674372230614;
          this.e = Math.sqrt(this.es);
          if (!this.lat0) {
            this.lat0 = 0.863937979737193;
          }
          if (!this.long0) {
            this.long0 = 0.7417649320975901 - 0.308341501185665;
          }
          if (!this.k0) {
            this.k0 = 0.9999;
          }
          this.s45 = 0.785398163397448;
          this.s90 = 2 * this.s45;
          this.fi0 = this.lat0;
          this.e2 = this.es;
          this.e = Math.sqrt(this.e2);
          this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
          this.uq = 1.04216856380474;
          this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
          this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
          this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
          this.k1 = this.k0;
          this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
          this.s0 = 1.37008346281555;
          this.n = Math.sin(this.s0);
          this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
          this.ad = this.s90 - this.uq;
        };
        exports3.forward = function(p) {
          var gfi, u, deltav, s, d, eps, ro;
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
          u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
          deltav = -delta_lon * this.alfa;
          s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
          d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
          eps = this.n * d;
          ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
          p.y = ro * Math.cos(eps) / 1;
          p.x = ro * Math.sin(eps) / 1;
          if (!this.czech) {
            p.y *= -1;
            p.x *= -1;
          }
          return p;
        };
        exports3.inverse = function(p) {
          var u, deltav, s, d, eps, ro, fi1;
          var ok;
          var tmp = p.x;
          p.x = p.y;
          p.y = tmp;
          if (!this.czech) {
            p.y *= -1;
            p.x *= -1;
          }
          ro = Math.sqrt(p.x * p.x + p.y * p.y);
          eps = Math.atan2(p.y, p.x);
          d = eps / Math.sin(this.s0);
          s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
          u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
          deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
          p.x = this.long0 - deltav / this.alfa;
          fi1 = u;
          ok = 0;
          var iter = 0;
          do {
            p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
            if (Math.abs(fi1 - p.y) < 1e-10) {
              ok = 1;
            }
            fi1 = p.y;
            iter += 1;
          } while (ok === 0 && iter < 15);
          if (iter >= 15) {
            return null;
          }
          return p;
        };
        exports3.names = ["Krovak", "krovak"];
      }, { "../common/adjust_lon": 58 }], 103: [function(require2, module3, exports3) {
        var HALF_PI = Math.PI / 2;
        var FORTPI = Math.PI / 4;
        var EPSLN = 1e-10;
        var qsfnz = require2("../common/qsfnz");
        var adjust_lon = require2("../common/adjust_lon");
        exports3.S_POLE = 1;
        exports3.N_POLE = 2;
        exports3.EQUIT = 3;
        exports3.OBLIQ = 4;
        exports3.init = function() {
          var t = Math.abs(this.lat0);
          if (Math.abs(t - HALF_PI) < EPSLN) {
            this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
          } else if (Math.abs(t) < EPSLN) {
            this.mode = this.EQUIT;
          } else {
            this.mode = this.OBLIQ;
          }
          if (this.es > 0) {
            var sinphi;
            this.qp = qsfnz(this.e, 1);
            this.mmf = 0.5 / (1 - this.es);
            this.apa = this.authset(this.es);
            switch (this.mode) {
              case this.N_POLE:
                this.dd = 1;
                break;
              case this.S_POLE:
                this.dd = 1;
                break;
              case this.EQUIT:
                this.rq = Math.sqrt(0.5 * this.qp);
                this.dd = 1 / this.rq;
                this.xmf = 1;
                this.ymf = 0.5 * this.qp;
                break;
              case this.OBLIQ:
                this.rq = Math.sqrt(0.5 * this.qp);
                sinphi = Math.sin(this.lat0);
                this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
                this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
                this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
                this.ymf = (this.xmf = this.rq) / this.dd;
                this.xmf *= this.dd;
                break;
            }
          } else {
            if (this.mode === this.OBLIQ) {
              this.sinph0 = Math.sin(this.lat0);
              this.cosph0 = Math.cos(this.lat0);
            }
          }
        };
        exports3.forward = function(p) {
          var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
          var lam = p.x;
          var phi = p.y;
          lam = adjust_lon(lam - this.long0);
          if (this.sphere) {
            sinphi = Math.sin(phi);
            cosphi = Math.cos(phi);
            coslam = Math.cos(lam);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
              if (y <= EPSLN) {
                return null;
              }
              y = Math.sqrt(2 / y);
              x = y * cosphi * Math.sin(lam);
              y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
              if (this.mode === this.N_POLE) {
                coslam = -coslam;
              }
              if (Math.abs(phi + this.phi0) < EPSLN) {
                return null;
              }
              y = FORTPI - phi * 0.5;
              y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
              x = y * Math.sin(lam);
              y *= coslam;
            }
          } else {
            sinb = 0;
            cosb = 0;
            b = 0;
            coslam = Math.cos(lam);
            sinlam = Math.sin(lam);
            sinphi = Math.sin(phi);
            q = qsfnz(this.e, sinphi);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              sinb = q / this.qp;
              cosb = Math.sqrt(1 - sinb * sinb);
            }
            switch (this.mode) {
              case this.OBLIQ:
                b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
                break;
              case this.EQUIT:
                b = 1 + cosb * coslam;
                break;
              case this.N_POLE:
                b = HALF_PI + phi;
                q = this.qp - q;
                break;
              case this.S_POLE:
                b = phi - HALF_PI;
                q = this.qp + q;
                break;
            }
            if (Math.abs(b) < EPSLN) {
              return null;
            }
            switch (this.mode) {
              case this.OBLIQ:
              case this.EQUIT:
                b = Math.sqrt(2 / b);
                if (this.mode === this.OBLIQ) {
                  y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
                } else {
                  y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
                }
                x = this.xmf * b * cosb * sinlam;
                break;
              case this.N_POLE:
              case this.S_POLE:
                if (q >= 0) {
                  x = (b = Math.sqrt(q)) * sinlam;
                  y = coslam * (this.mode === this.S_POLE ? b : -b);
                } else {
                  x = y = 0;
                }
                break;
            }
          }
          p.x = this.a * x + this.x0;
          p.y = this.a * y + this.y0;
          return p;
        };
        exports3.inverse = function(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var x = p.x / this.a;
          var y = p.y / this.a;
          var lam, phi, cCe, sCe, q, rho, ab;
          if (this.sphere) {
            var cosz = 0, rh, sinz = 0;
            rh = Math.sqrt(x * x + y * y);
            phi = rh * 0.5;
            if (phi > 1) {
              return null;
            }
            phi = 2 * Math.asin(phi);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              sinz = Math.sin(phi);
              cosz = Math.cos(phi);
            }
            switch (this.mode) {
              case this.EQUIT:
                phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
                x *= sinz;
                y = cosz * rh;
                break;
              case this.OBLIQ:
                phi = Math.abs(rh) <= EPSLN ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
                x *= sinz * this.cosph0;
                y = (cosz - Math.sin(phi) * this.sinph0) * rh;
                break;
              case this.N_POLE:
                y = -y;
                phi = HALF_PI - phi;
                break;
              case this.S_POLE:
                phi -= HALF_PI;
                break;
            }
            lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
          } else {
            ab = 0;
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              x /= this.dd;
              y *= this.dd;
              rho = Math.sqrt(x * x + y * y);
              if (rho < EPSLN) {
                p.x = 0;
                p.y = this.phi0;
                return p;
              }
              sCe = 2 * Math.asin(0.5 * rho / this.rq);
              cCe = Math.cos(sCe);
              x *= sCe = Math.sin(sCe);
              if (this.mode === this.OBLIQ) {
                ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
                q = this.qp * ab;
                y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
              } else {
                ab = y * sCe / rho;
                q = this.qp * ab;
                y = rho * cCe;
              }
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
              if (this.mode === this.N_POLE) {
                y = -y;
              }
              q = x * x + y * y;
              if (!q) {
                p.x = 0;
                p.y = this.phi0;
                return p;
              }
              ab = 1 - q / this.qp;
              if (this.mode === this.S_POLE) {
                ab = -ab;
              }
            }
            lam = Math.atan2(x, y);
            phi = this.authlat(Math.asin(ab), this.apa);
          }
          p.x = adjust_lon(this.long0 + lam);
          p.y = phi;
          return p;
        };
        exports3.P00 = 0.3333333333333333;
        exports3.P01 = 0.17222222222222222;
        exports3.P02 = 0.10257936507936508;
        exports3.P10 = 0.06388888888888888;
        exports3.P11 = 0.0664021164021164;
        exports3.P20 = 0.016415012942191543;
        exports3.authset = function(es) {
          var t;
          var APA = [];
          APA[0] = es * this.P00;
          t = es * es;
          APA[0] += t * this.P01;
          APA[1] = t * this.P10;
          t *= es;
          APA[0] += t * this.P02;
          APA[1] += t * this.P11;
          APA[2] = t * this.P20;
          return APA;
        };
        exports3.authlat = function(beta, APA) {
          var t = beta + beta;
          return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
        };
        exports3.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
      }, { "../common/adjust_lon": 58, "../common/qsfnz": 73 }], 104: [function(require2, module3, exports3) {
        var EPSLN = 1e-10;
        var msfnz = require2("../common/msfnz");
        var tsfnz = require2("../common/tsfnz");
        var HALF_PI = Math.PI / 2;
        var sign = require2("../common/sign");
        var adjust_lon = require2("../common/adjust_lon");
        var phi2z = require2("../common/phi2z");
        exports3.init = function() {
          if (!this.lat2) {
            this.lat2 = this.lat1;
          }
          if (!this.k0) {
            this.k0 = 1;
          }
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          var temp = this.b / this.a;
          this.e = Math.sqrt(1 - temp * temp);
          var sin1 = Math.sin(this.lat1);
          var cos1 = Math.cos(this.lat1);
          var ms1 = msfnz(this.e, sin1, cos1);
          var ts1 = tsfnz(this.e, this.lat1, sin1);
          var sin2 = Math.sin(this.lat2);
          var cos2 = Math.cos(this.lat2);
          var ms2 = msfnz(this.e, sin2, cos2);
          var ts2 = tsfnz(this.e, this.lat2, sin2);
          var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
          if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
            this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
          } else {
            this.ns = sin1;
          }
          if (isNaN(this.ns)) {
            this.ns = sin1;
          }
          this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
          this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
          if (!this.title) {
            this.title = "Lambert Conformal Conic";
          }
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
            lat = sign(lat) * (HALF_PI - 2 * EPSLN);
          }
          var con = Math.abs(Math.abs(lat) - HALF_PI);
          var ts, rh1;
          if (con > EPSLN) {
            ts = tsfnz(this.e, lat, Math.sin(lat));
            rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
          } else {
            con = lat * this.ns;
            if (con <= 0) {
              return null;
            }
            rh1 = 0;
          }
          var theta = this.ns * adjust_lon(lon - this.long0);
          p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
          p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
          return p;
        };
        exports3.inverse = function(p) {
          var rh1, con, ts;
          var lat, lon;
          var x = (p.x - this.x0) / this.k0;
          var y = this.rh - (p.y - this.y0) / this.k0;
          if (this.ns > 0) {
            rh1 = Math.sqrt(x * x + y * y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(x * x + y * y);
            con = -1;
          }
          var theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * x, con * y);
          }
          if (rh1 !== 0 || this.ns > 0) {
            con = 1 / this.ns;
            ts = Math.pow(rh1 / (this.a * this.f0), con);
            lat = phi2z(this.e, ts);
            if (lat === -9999) {
              return null;
            }
          } else {
            lat = -HALF_PI;
          }
          lon = adjust_lon(theta / this.ns + this.long0);
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
      }, { "../common/adjust_lon": 58, "../common/msfnz": 68, "../common/phi2z": 69, "../common/sign": 74, "../common/tsfnz": 77 }], 105: [function(require2, module3, exports3) {
        exports3.init = function() {
        };
        function identity(pt) {
          return pt;
        }
        exports3.forward = identity;
        exports3.inverse = identity;
        exports3.names = ["longlat", "identity"];
      }, {}], 106: [function(require2, module3, exports3) {
        var msfnz = require2("../common/msfnz");
        var HALF_PI = Math.PI / 2;
        var EPSLN = 1e-10;
        var R2D = 57.29577951308232;
        var adjust_lon = require2("../common/adjust_lon");
        var FORTPI = Math.PI / 4;
        var tsfnz = require2("../common/tsfnz");
        var phi2z = require2("../common/phi2z");
        exports3.init = function() {
          var con = this.b / this.a;
          this.es = 1 - con * con;
          if (!("x0" in this)) {
            this.x0 = 0;
          }
          if (!("y0" in this)) {
            this.y0 = 0;
          }
          this.e = Math.sqrt(this.es);
          if (this.lat_ts) {
            if (this.sphere) {
              this.k0 = Math.cos(this.lat_ts);
            } else {
              this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
            }
          } else {
            if (!this.k0) {
              if (this.k) {
                this.k0 = this.k;
              } else {
                this.k0 = 1;
              }
            }
          }
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
            return null;
          }
          var x, y;
          if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
            return null;
          } else {
            if (this.sphere) {
              x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
              y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
            } else {
              var sinphi = Math.sin(lat);
              var ts = tsfnz(this.e, lat, sinphi);
              x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
              y = this.y0 - this.a * this.k0 * Math.log(ts);
            }
            p.x = x;
            p.y = y;
            return p;
          }
        };
        exports3.inverse = function(p) {
          var x = p.x - this.x0;
          var y = p.y - this.y0;
          var lon, lat;
          if (this.sphere) {
            lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
          } else {
            var ts = Math.exp(-y / (this.a * this.k0));
            lat = phi2z(this.e, ts);
            if (lat === -9999) {
              return null;
            }
          }
          lon = adjust_lon(this.long0 + x / (this.a * this.k0));
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
      }, { "../common/adjust_lon": 58, "../common/msfnz": 68, "../common/phi2z": 69, "../common/tsfnz": 77 }], 107: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        exports3.init = function() {
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var x = this.x0 + this.a * dlon;
          var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon = adjust_lon(this.long0 + p.x / this.a);
          var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["Miller_Cylindrical", "mill"];
      }, { "../common/adjust_lon": 58 }], 108: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        var EPSLN = 1e-10;
        exports3.init = function() {
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          var theta = lat;
          var con = Math.PI * Math.sin(lat);
          for (var i = 0; true; i++) {
            var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
            theta += delta_theta;
            if (Math.abs(delta_theta) < EPSLN) {
              break;
            }
          }
          theta /= 2;
          if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
            delta_lon = 0;
          }
          var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
          var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          var theta;
          var arg;
          p.x -= this.x0;
          p.y -= this.y0;
          arg = p.y / (1.4142135623731 * this.a);
          if (Math.abs(arg) > 0.999999999999) {
            arg = 0.999999999999;
          }
          theta = Math.asin(arg);
          var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
          if (lon < -Math.PI) {
            lon = -Math.PI;
          }
          if (lon > Math.PI) {
            lon = Math.PI;
          }
          arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
          if (Math.abs(arg) > 1) {
            arg = 1;
          }
          var lat = Math.asin(arg);
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["Mollweide", "moll"];
      }, { "../common/adjust_lon": 58 }], 109: [function(require2, module3, exports3) {
        var SEC_TO_RAD = 484813681109536e-20;
        exports3.iterations = 1;
        exports3.init = function() {
          this.A = [];
          this.A[1] = 0.6399175073;
          this.A[2] = -0.1358797613;
          this.A[3] = 0.063294409;
          this.A[4] = -0.02526853;
          this.A[5] = 0.0117879;
          this.A[6] = -55161e-7;
          this.A[7] = 26906e-7;
          this.A[8] = -1333e-6;
          this.A[9] = 67e-5;
          this.A[10] = -34e-5;
          this.B_re = [];
          this.B_im = [];
          this.B_re[1] = 0.7557853228;
          this.B_im[1] = 0;
          this.B_re[2] = 0.249204646;
          this.B_im[2] = 3371507e-9;
          this.B_re[3] = -1541739e-9;
          this.B_im[3] = 0.04105856;
          this.B_re[4] = -0.10162907;
          this.B_im[4] = 0.01727609;
          this.B_re[5] = -0.26623489;
          this.B_im[5] = -0.36249218;
          this.B_re[6] = -0.6870983;
          this.B_im[6] = -1.1651967;
          this.C_re = [];
          this.C_im = [];
          this.C_re[1] = 1.3231270439;
          this.C_im[1] = 0;
          this.C_re[2] = -0.577245789;
          this.C_im[2] = -7809598e-9;
          this.C_re[3] = 0.508307513;
          this.C_im[3] = -0.112208952;
          this.C_re[4] = -0.15094762;
          this.C_im[4] = 0.18200602;
          this.C_re[5] = 1.01418179;
          this.C_im[5] = 1.64497696;
          this.C_re[6] = 1.9660549;
          this.C_im[6] = 2.5127645;
          this.D = [];
          this.D[1] = 1.5627014243;
          this.D[2] = 0.5185406398;
          this.D[3] = -0.03333098;
          this.D[4] = -0.1052906;
          this.D[5] = -0.0368594;
          this.D[6] = 7317e-6;
          this.D[7] = 0.0122;
          this.D[8] = 394e-5;
          this.D[9] = -13e-4;
        };
        exports3.forward = function(p) {
          var n;
          var lon = p.x;
          var lat = p.y;
          var delta_lat = lat - this.lat0;
          var delta_lon = lon - this.long0;
          var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
          var d_lambda = delta_lon;
          var d_phi_n = 1;
          var d_psi = 0;
          for (n = 1; n <= 10; n++) {
            d_phi_n = d_phi_n * d_phi;
            d_psi = d_psi + this.A[n] * d_phi_n;
          }
          var th_re = d_psi;
          var th_im = d_lambda;
          var th_n_re = 1;
          var th_n_im = 0;
          var th_n_re1;
          var th_n_im1;
          var z_re = 0;
          var z_im = 0;
          for (n = 1; n <= 6; n++) {
            th_n_re1 = th_n_re * th_re - th_n_im * th_im;
            th_n_im1 = th_n_im * th_re + th_n_re * th_im;
            th_n_re = th_n_re1;
            th_n_im = th_n_im1;
            z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
            z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
          }
          p.x = z_im * this.a + this.x0;
          p.y = z_re * this.a + this.y0;
          return p;
        };
        exports3.inverse = function(p) {
          var n;
          var x = p.x;
          var y = p.y;
          var delta_x = x - this.x0;
          var delta_y = y - this.y0;
          var z_re = delta_y / this.a;
          var z_im = delta_x / this.a;
          var z_n_re = 1;
          var z_n_im = 0;
          var z_n_re1;
          var z_n_im1;
          var th_re = 0;
          var th_im = 0;
          for (n = 1; n <= 6; n++) {
            z_n_re1 = z_n_re * z_re - z_n_im * z_im;
            z_n_im1 = z_n_im * z_re + z_n_re * z_im;
            z_n_re = z_n_re1;
            z_n_im = z_n_im1;
            th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
            th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
          }
          for (var i = 0; i < this.iterations; i++) {
            var th_n_re = th_re;
            var th_n_im = th_im;
            var th_n_re1;
            var th_n_im1;
            var num_re = z_re;
            var num_im = z_im;
            for (n = 2; n <= 6; n++) {
              th_n_re1 = th_n_re * th_re - th_n_im * th_im;
              th_n_im1 = th_n_im * th_re + th_n_re * th_im;
              th_n_re = th_n_re1;
              th_n_im = th_n_im1;
              num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
              num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
            }
            th_n_re = 1;
            th_n_im = 0;
            var den_re = this.B_re[1];
            var den_im = this.B_im[1];
            for (n = 2; n <= 6; n++) {
              th_n_re1 = th_n_re * th_re - th_n_im * th_im;
              th_n_im1 = th_n_im * th_re + th_n_re * th_im;
              th_n_re = th_n_re1;
              th_n_im = th_n_im1;
              den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
              den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
            }
            var den2 = den_re * den_re + den_im * den_im;
            th_re = (num_re * den_re + num_im * den_im) / den2;
            th_im = (num_im * den_re - num_re * den_im) / den2;
          }
          var d_psi = th_re;
          var d_lambda = th_im;
          var d_psi_n = 1;
          var d_phi = 0;
          for (n = 1; n <= 9; n++) {
            d_psi_n = d_psi_n * d_psi;
            d_phi = d_phi + this.D[n] * d_psi_n;
          }
          var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
          var lon = this.long0 + d_lambda;
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["New_Zealand_Map_Grid", "nzmg"];
      }, {}], 110: [function(require2, module3, exports3) {
        var tsfnz = require2("../common/tsfnz");
        var adjust_lon = require2("../common/adjust_lon");
        var phi2z = require2("../common/phi2z");
        var HALF_PI = Math.PI / 2;
        var FORTPI = Math.PI / 4;
        var EPSLN = 1e-10;
        exports3.init = function() {
          this.no_off = this.no_off || false;
          this.no_rot = this.no_rot || false;
          if (isNaN(this.k0)) {
            this.k0 = 1;
          }
          var sinlat = Math.sin(this.lat0);
          var coslat = Math.cos(this.lat0);
          var con = this.e * sinlat;
          this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
          this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
          var t0 = tsfnz(this.e, this.lat0, sinlat);
          var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
          if (dl * dl < 1) {
            dl = 1;
          }
          var fl;
          var gl;
          if (!isNaN(this.longc)) {
            if (this.lat0 >= 0) {
              fl = dl + Math.sqrt(dl * dl - 1);
            } else {
              fl = dl - Math.sqrt(dl * dl - 1);
            }
            this.el = fl * Math.pow(t0, this.bl);
            gl = 0.5 * (fl - 1 / fl);
            this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
            this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;
          } else {
            var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
            var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
            if (this.lat0 >= 0) {
              this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
            } else {
              this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
            }
            var hl = Math.pow(t1, this.bl);
            var ll = Math.pow(t2, this.bl);
            fl = this.el / hl;
            gl = 0.5 * (fl - 1 / fl);
            var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
            var pl = (ll - hl) / (ll + hl);
            var dlon12 = adjust_lon(this.long1 - this.long2);
            this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * dlon12) / pl) / this.bl;
            this.long0 = adjust_lon(this.long0);
            var dlon10 = adjust_lon(this.long1 - this.long0);
            this.gamma0 = Math.atan(Math.sin(this.bl * dlon10) / gl);
            this.alpha = Math.asin(dl * Math.sin(this.gamma0));
          }
          if (this.no_off) {
            this.uc = 0;
          } else {
            if (this.lat0 >= 0) {
              this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
            } else {
              this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
            }
          }
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var us, vs;
          var con;
          if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
            if (lat > 0) {
              con = -1;
            } else {
              con = 1;
            }
            vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
            us = -1 * con * HALF_PI * this.al / this.bl;
          } else {
            var t = tsfnz(this.e, lat, Math.sin(lat));
            var ql = this.el / Math.pow(t, this.bl);
            var sl = 0.5 * (ql - 1 / ql);
            var tl = 0.5 * (ql + 1 / ql);
            var vl = Math.sin(this.bl * dlon);
            var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
            if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
              vs = Number.POSITIVE_INFINITY;
            } else {
              vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
            }
            if (Math.abs(Math.cos(this.bl * dlon)) <= EPSLN) {
              us = this.al * this.bl * dlon;
            } else {
              us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
            }
          }
          if (this.no_rot) {
            p.x = this.x0 + us;
            p.y = this.y0 + vs;
          } else {
            us -= this.uc;
            p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
            p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
          }
          return p;
        };
        exports3.inverse = function(p) {
          var us, vs;
          if (this.no_rot) {
            vs = p.y - this.y0;
            us = p.x - this.x0;
          } else {
            vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
            us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
            us += this.uc;
          }
          var qp = Math.exp(-1 * this.bl * vs / this.al);
          var sp = 0.5 * (qp - 1 / qp);
          var tp = 0.5 * (qp + 1 / qp);
          var vp = Math.sin(this.bl * us / this.al);
          var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
          var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
          if (Math.abs(up - 1) < EPSLN) {
            p.x = this.long0;
            p.y = HALF_PI;
          } else if (Math.abs(up + 1) < EPSLN) {
            p.x = this.long0;
            p.y = -1 * HALF_PI;
          } else {
            p.y = phi2z(this.e, ts);
            p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
          }
          return p;
        };
        exports3.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
      }, { "../common/adjust_lon": 58, "../common/phi2z": 69, "../common/tsfnz": 77 }], 111: [function(require2, module3, exports3) {
        var e0fn = require2("../common/e0fn");
        var e1fn = require2("../common/e1fn");
        var e2fn = require2("../common/e2fn");
        var e3fn = require2("../common/e3fn");
        var adjust_lon = require2("../common/adjust_lon");
        var adjust_lat = require2("../common/adjust_lat");
        var mlfn = require2("../common/mlfn");
        var EPSLN = 1e-10;
        var gN = require2("../common/gN");
        var MAX_ITER = 20;
        exports3.init = function() {
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e = Math.sqrt(this.es);
          this.e0 = e0fn(this.es);
          this.e1 = e1fn(this.es);
          this.e2 = e2fn(this.es);
          this.e3 = e3fn(this.es);
          this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var x, y, el;
          var dlon = adjust_lon(lon - this.long0);
          el = dlon * Math.sin(lat);
          if (this.sphere) {
            if (Math.abs(lat) <= EPSLN) {
              x = this.a * dlon;
              y = -1 * this.a * this.lat0;
            } else {
              x = this.a * Math.sin(el) / Math.tan(lat);
              y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
            }
          } else {
            if (Math.abs(lat) <= EPSLN) {
              x = this.a * dlon;
              y = -1 * this.ml0;
            } else {
              var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
              x = nl * Math.sin(el);
              y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
            }
          }
          p.x = x + this.x0;
          p.y = y + this.y0;
          return p;
        };
        exports3.inverse = function(p) {
          var lon, lat, x, y, i;
          var al, bl;
          var phi, dphi;
          x = p.x - this.x0;
          y = p.y - this.y0;
          if (this.sphere) {
            if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
              lon = adjust_lon(x / this.a + this.long0);
              lat = 0;
            } else {
              al = this.lat0 + y / this.a;
              bl = x * x / this.a / this.a + al * al;
              phi = al;
              var tanphi;
              for (i = MAX_ITER; i; --i) {
                tanphi = Math.tan(phi);
                dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
                phi += dphi;
                if (Math.abs(dphi) <= EPSLN) {
                  lat = phi;
                  break;
                }
              }
              lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
            }
          } else {
            if (Math.abs(y + this.ml0) <= EPSLN) {
              lat = 0;
              lon = adjust_lon(this.long0 + x / this.a);
            } else {
              al = (this.ml0 + y) / this.a;
              bl = x * x / this.a / this.a + al * al;
              phi = al;
              var cl, mln, mlnp, ma;
              var con;
              for (i = MAX_ITER; i; --i) {
                con = this.e * Math.sin(phi);
                cl = Math.sqrt(1 - con * con) * Math.tan(phi);
                mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
                mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
                ma = mln / this.a;
                dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
                phi -= dphi;
                if (Math.abs(dphi) <= EPSLN) {
                  lat = phi;
                  break;
                }
              }
              cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
              lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["Polyconic", "poly"];
      }, { "../common/adjust_lat": 57, "../common/adjust_lon": 58, "../common/e0fn": 60, "../common/e1fn": 61, "../common/e2fn": 62, "../common/e3fn": 63, "../common/gN": 64, "../common/mlfn": 67 }], 112: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        var adjust_lat = require2("../common/adjust_lat");
        var pj_enfn = require2("../common/pj_enfn");
        var MAX_ITER = 20;
        var pj_mlfn = require2("../common/pj_mlfn");
        var pj_inv_mlfn = require2("../common/pj_inv_mlfn");
        var HALF_PI = Math.PI / 2;
        var EPSLN = 1e-10;
        var asinz = require2("../common/asinz");
        exports3.init = function() {
          if (!this.sphere) {
            this.en = pj_enfn(this.es);
          } else {
            this.n = 1;
            this.m = 0;
            this.es = 0;
            this.C_y = Math.sqrt((this.m + 1) / this.n);
            this.C_x = this.C_y / (this.m + 1);
          }
        };
        exports3.forward = function(p) {
          var x, y;
          var lon = p.x;
          var lat = p.y;
          lon = adjust_lon(lon - this.long0);
          if (this.sphere) {
            if (!this.m) {
              lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
            } else {
              var k = this.n * Math.sin(lat);
              for (var i = MAX_ITER; i; --i) {
                var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
                lat -= V;
                if (Math.abs(V) < EPSLN) {
                  break;
                }
              }
            }
            x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
            y = this.a * this.C_y * lat;
          } else {
            var s = Math.sin(lat);
            var c = Math.cos(lat);
            y = this.a * pj_mlfn(lat, s, c, this.en);
            x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
          }
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          var lat, temp, lon, s;
          p.x -= this.x0;
          lon = p.x / this.a;
          p.y -= this.y0;
          lat = p.y / this.a;
          if (this.sphere) {
            lat /= this.C_y;
            lon = lon / (this.C_x * (this.m + Math.cos(lat)));
            if (this.m) {
              lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
            } else if (this.n !== 1) {
              lat = asinz(Math.sin(lat) / this.n);
            }
            lon = adjust_lon(lon + this.long0);
            lat = adjust_lat(lat);
          } else {
            lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
            s = Math.abs(lat);
            if (s < HALF_PI) {
              s = Math.sin(lat);
              temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
              lon = adjust_lon(temp);
            } else if (s - EPSLN < HALF_PI) {
              lon = this.long0;
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["Sinusoidal", "sinu"];
      }, { "../common/adjust_lat": 57, "../common/adjust_lon": 58, "../common/asinz": 59, "../common/pj_enfn": 70, "../common/pj_inv_mlfn": 71, "../common/pj_mlfn": 72 }], 113: [function(require2, module3, exports3) {
        exports3.init = function() {
          var phy0 = this.lat0;
          this.lambda0 = this.long0;
          var sinPhy0 = Math.sin(phy0);
          var semiMajorAxis = this.a;
          var invF = this.rf;
          var flattening = 1 / invF;
          var e2 = 2 * flattening - Math.pow(flattening, 2);
          var e = this.e = Math.sqrt(e2);
          this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
          this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
          this.b0 = Math.asin(sinPhy0 / this.alpha);
          var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
          var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
          var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
          this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
        };
        exports3.forward = function(p) {
          var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
          var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
          var S = -this.alpha * (Sa1 + Sa2) + this.K;
          var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
          var I = this.alpha * (p.x - this.lambda0);
          var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
          var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
          p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
          p.x = this.R * rotI + this.x0;
          return p;
        };
        exports3.inverse = function(p) {
          var Y = p.x - this.x0;
          var X = p.y - this.y0;
          var rotI = Y / this.R;
          var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
          var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
          var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
          var lambda = this.lambda0 + I / this.alpha;
          var S = 0;
          var phy = b;
          var prevPhy = -1e3;
          var iteration = 0;
          while (Math.abs(phy - prevPhy) > 1e-7) {
            if (++iteration > 20) {
              return;
            }
            S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
            prevPhy = phy;
            phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
          }
          p.x = lambda;
          p.y = phy;
          return p;
        };
        exports3.names = ["somerc"];
      }, {}], 114: [function(require2, module3, exports3) {
        var HALF_PI = Math.PI / 2;
        var EPSLN = 1e-10;
        var sign = require2("../common/sign");
        var msfnz = require2("../common/msfnz");
        var tsfnz = require2("../common/tsfnz");
        var phi2z = require2("../common/phi2z");
        var adjust_lon = require2("../common/adjust_lon");
        exports3.ssfn_ = function(phit, sinphi, eccen) {
          sinphi *= eccen;
          return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
        };
        exports3.init = function() {
          this.coslat0 = Math.cos(this.lat0);
          this.sinlat0 = Math.sin(this.lat0);
          if (this.sphere) {
            if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
              this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
            }
          } else {
            if (Math.abs(this.coslat0) <= EPSLN) {
              if (this.lat0 > 0) {
                this.con = 1;
              } else {
                this.con = -1;
              }
            }
            this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
            if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
              this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
            }
            this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
            this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
            this.cosX0 = Math.cos(this.X0);
            this.sinX0 = Math.sin(this.X0);
          }
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var sinlat = Math.sin(lat);
          var coslat = Math.cos(lat);
          var A, X, sinX, cosX, ts, rh;
          var dlon = adjust_lon(lon - this.long0);
          if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
            p.x = NaN;
            p.y = NaN;
            return p;
          }
          if (this.sphere) {
            A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
            p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
            p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
            return p;
          } else {
            X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
            cosX = Math.cos(X);
            sinX = Math.sin(X);
            if (Math.abs(this.coslat0) <= EPSLN) {
              ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
              rh = 2 * this.a * this.k0 * ts / this.cons;
              p.x = this.x0 + rh * Math.sin(lon - this.long0);
              p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
              return p;
            } else if (Math.abs(this.sinlat0) < EPSLN) {
              A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
              p.y = A * sinX;
            } else {
              A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
              p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
            }
            p.x = A * cosX * Math.sin(dlon) + this.x0;
          }
          return p;
        };
        exports3.inverse = function(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon, lat, ts, ce, Chi;
          var rh = Math.sqrt(p.x * p.x + p.y * p.y);
          if (this.sphere) {
            var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
            lon = this.long0;
            lat = this.lat0;
            if (rh <= EPSLN) {
              p.x = lon;
              p.y = lat;
              return p;
            }
            lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
            if (Math.abs(this.coslat0) < EPSLN) {
              if (this.lat0 > 0) {
                lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
              } else {
                lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
              }
            } else {
              lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
            }
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            if (Math.abs(this.coslat0) <= EPSLN) {
              if (rh <= EPSLN) {
                lat = this.lat0;
                lon = this.long0;
                p.x = lon;
                p.y = lat;
                return p;
              }
              p.x *= this.con;
              p.y *= this.con;
              ts = rh * this.cons / (2 * this.a * this.k0);
              lat = this.con * phi2z(this.e, ts);
              lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
            } else {
              ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
              lon = this.long0;
              if (rh <= EPSLN) {
                Chi = this.X0;
              } else {
                Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
                lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
              }
              lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
      }, { "../common/adjust_lon": 58, "../common/msfnz": 68, "../common/phi2z": 69, "../common/sign": 74, "../common/tsfnz": 77 }], 115: [function(require2, module3, exports3) {
        var gauss = require2("./gauss");
        var adjust_lon = require2("../common/adjust_lon");
        exports3.init = function() {
          gauss.init.apply(this);
          if (!this.rc) {
            return;
          }
          this.sinc0 = Math.sin(this.phic0);
          this.cosc0 = Math.cos(this.phic0);
          this.R2 = 2 * this.rc;
          if (!this.title) {
            this.title = "Oblique Stereographic Alternative";
          }
        };
        exports3.forward = function(p) {
          var sinc, cosc, cosl, k;
          p.x = adjust_lon(p.x - this.long0);
          gauss.forward.apply(this, [p]);
          sinc = Math.sin(p.y);
          cosc = Math.cos(p.y);
          cosl = Math.cos(p.x);
          k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
          p.x = k * cosc * Math.sin(p.x);
          p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
          p.x = this.a * p.x + this.x0;
          p.y = this.a * p.y + this.y0;
          return p;
        };
        exports3.inverse = function(p) {
          var sinc, cosc, lon, lat, rho;
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          p.x /= this.k0;
          p.y /= this.k0;
          if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
            var c = 2 * Math.atan2(rho, this.R2);
            sinc = Math.sin(c);
            cosc = Math.cos(c);
            lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
            lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
          } else {
            lat = this.phic0;
            lon = 0;
          }
          p.x = lon;
          p.y = lat;
          gauss.inverse.apply(this, [p]);
          p.x = adjust_lon(p.x + this.long0);
          return p;
        };
        exports3.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative"];
      }, { "../common/adjust_lon": 58, "./gauss": 100 }], 116: [function(require2, module3, exports3) {
        var e0fn = require2("../common/e0fn");
        var e1fn = require2("../common/e1fn");
        var e2fn = require2("../common/e2fn");
        var e3fn = require2("../common/e3fn");
        var mlfn = require2("../common/mlfn");
        var adjust_lon = require2("../common/adjust_lon");
        var HALF_PI = Math.PI / 2;
        var EPSLN = 1e-10;
        var sign = require2("../common/sign");
        var asinz = require2("../common/asinz");
        exports3.init = function() {
          this.e0 = e0fn(this.es);
          this.e1 = e1fn(this.es);
          this.e2 = e2fn(this.es);
          this.e3 = e3fn(this.es);
          this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          var con;
          var x, y;
          var sin_phi = Math.sin(lat);
          var cos_phi = Math.cos(lat);
          if (this.sphere) {
            var b = cos_phi * Math.sin(delta_lon);
            if (Math.abs(Math.abs(b) - 1) < 1e-10) {
              return 93;
            } else {
              x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));
              con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));
              if (lat < 0) {
                con = -con;
              }
              y = this.a * this.k0 * (con - this.lat0);
            }
          } else {
            var al = cos_phi * delta_lon;
            var als = Math.pow(al, 2);
            var c = this.ep2 * Math.pow(cos_phi, 2);
            var tq = Math.tan(lat);
            var t = Math.pow(tq, 2);
            con = 1 - this.es * Math.pow(sin_phi, 2);
            var n = this.a / Math.sqrt(con);
            var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);
            x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;
            y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;
          }
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          var con, phi;
          var delta_phi;
          var i;
          var max_iter = 6;
          var lat, lon;
          if (this.sphere) {
            var f = Math.exp(p.x / (this.a * this.k0));
            var g = 0.5 * (f - 1 / f);
            var temp = this.lat0 + p.y / (this.a * this.k0);
            var h = Math.cos(temp);
            con = Math.sqrt((1 - h * h) / (1 + g * g));
            lat = asinz(con);
            if (temp < 0) {
              lat = -lat;
            }
            if (g === 0 && h === 0) {
              lon = this.long0;
            } else {
              lon = adjust_lon(Math.atan2(g, h) + this.long0);
            }
          } else {
            var x = p.x - this.x0;
            var y = p.y - this.y0;
            con = (this.ml0 + y / this.k0) / this.a;
            phi = con;
            for (i = 0; true; i++) {
              delta_phi = (con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0 - phi;
              phi += delta_phi;
              if (Math.abs(delta_phi) <= EPSLN) {
                break;
              }
              if (i >= max_iter) {
                return 95;
              }
            }
            if (Math.abs(phi) < HALF_PI) {
              var sin_phi = Math.sin(phi);
              var cos_phi = Math.cos(phi);
              var tan_phi = Math.tan(phi);
              var c = this.ep2 * Math.pow(cos_phi, 2);
              var cs = Math.pow(c, 2);
              var t = Math.pow(tan_phi, 2);
              var ts = Math.pow(t, 2);
              con = 1 - this.es * Math.pow(sin_phi, 2);
              var n = this.a / Math.sqrt(con);
              var r = n * (1 - this.es) / con;
              var d = x / (n * this.k0);
              var ds = Math.pow(d, 2);
              lat = phi - n * tan_phi * ds / r * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));
              lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi);
            } else {
              lat = HALF_PI * sign(y);
              lon = this.long0;
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
      }, { "../common/adjust_lon": 58, "../common/asinz": 59, "../common/e0fn": 60, "../common/e1fn": 61, "../common/e2fn": 62, "../common/e3fn": 63, "../common/mlfn": 67, "../common/sign": 74 }], 117: [function(require2, module3, exports3) {
        var D2R = 0.017453292519943295;
        var tmerc = require2("./tmerc");
        exports3.dependsOn = "tmerc";
        exports3.init = function() {
          if (!this.zone) {
            return;
          }
          this.lat0 = 0;
          this.long0 = (6 * Math.abs(this.zone) - 183) * D2R;
          this.x0 = 5e5;
          this.y0 = this.utmSouth ? 1e7 : 0;
          this.k0 = 0.9996;
          tmerc.init.apply(this);
          this.forward = tmerc.forward;
          this.inverse = tmerc.inverse;
        };
        exports3.names = ["Universal Transverse Mercator System", "utm"];
      }, { "./tmerc": 116 }], 118: [function(require2, module3, exports3) {
        var adjust_lon = require2("../common/adjust_lon");
        var HALF_PI = Math.PI / 2;
        var EPSLN = 1e-10;
        var asinz = require2("../common/asinz");
        exports3.init = function() {
          this.R = this.a;
        };
        exports3.forward = function(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var x, y;
          if (Math.abs(lat) <= EPSLN) {
            x = this.x0 + this.R * dlon;
            y = this.y0;
          }
          var theta = asinz(2 * Math.abs(lat / Math.PI));
          if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
            x = this.x0;
            if (lat >= 0) {
              y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
            } else {
              y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
            }
          }
          var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
          var asq = al * al;
          var sinth = Math.sin(theta);
          var costh = Math.cos(theta);
          var g = costh / (sinth + costh - 1);
          var gsq = g * g;
          var m = g * (2 / sinth - 1);
          var msq = m * m;
          var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
          if (dlon < 0) {
            con = -con;
          }
          x = this.x0 + con;
          var q = asq + g;
          con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
          if (lat >= 0) {
            y = this.y0 + con;
          } else {
            y = this.y0 - con;
          }
          p.x = x;
          p.y = y;
          return p;
        };
        exports3.inverse = function(p) {
          var lon, lat;
          var xx, yy, xys, c1, c2, c3;
          var a1;
          var m1;
          var con;
          var th1;
          var d;
          p.x -= this.x0;
          p.y -= this.y0;
          con = Math.PI * this.R;
          xx = p.x / con;
          yy = p.y / con;
          xys = xx * xx + yy * yy;
          c1 = -Math.abs(yy) * (1 + xys);
          c2 = c1 - 2 * yy * yy + xx * xx;
          c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
          d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
          a1 = (c1 - c2 * c2 / 3 / c3) / c3;
          m1 = 2 * Math.sqrt(-a1 / 3);
          con = 3 * d / a1 / m1;
          if (Math.abs(con) > 1) {
            if (con >= 0) {
              con = 1;
            } else {
              con = -1;
            }
          }
          th1 = Math.acos(con) / 3;
          if (p.y >= 0) {
            lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
          } else {
            lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
          }
          if (Math.abs(xx) < EPSLN) {
            lon = this.long0;
          } else {
            lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
          }
          p.x = lon;
          p.y = lat;
          return p;
        };
        exports3.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
      }, { "../common/adjust_lon": 58, "../common/asinz": 59 }], 119: [function(require2, module3, exports3) {
        var D2R = 0.017453292519943295;
        var R2D = 57.29577951308232;
        var PJD_3PARAM = 1;
        var PJD_7PARAM = 2;
        var datum_transform = require2("./datum_transform");
        var adjust_axis = require2("./adjust_axis");
        var proj = require2("./Proj");
        var toPoint = require2("./common/toPoint");
        module3.exports = function transform(source, dest, point) {
          var wgs84;
          if (Array.isArray(point)) {
            point = toPoint(point);
          }
          function checkNotWGS(source2, dest2) {
            return (source2.datum.datum_type === PJD_3PARAM || source2.datum.datum_type === PJD_7PARAM) && dest2.datumCode !== "WGS84";
          }
          if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {
            wgs84 = new proj("WGS84");
            transform(source, wgs84, point);
            source = wgs84;
          }
          if (source.axis !== "enu") {
            adjust_axis(source, false, point);
          }
          if (source.projName === "longlat") {
            point.x *= D2R;
            point.y *= D2R;
          } else {
            if (source.to_meter) {
              point.x *= source.to_meter;
              point.y *= source.to_meter;
            }
            source.inverse(point);
          }
          if (source.from_greenwich) {
            point.x += source.from_greenwich;
          }
          point = datum_transform(source.datum, dest.datum, point);
          if (dest.from_greenwich) {
            point.x -= dest.from_greenwich;
          }
          if (dest.projName === "longlat") {
            point.x *= R2D;
            point.y *= R2D;
          } else {
            dest.forward(point);
            if (dest.to_meter) {
              point.x /= dest.to_meter;
              point.y /= dest.to_meter;
            }
          }
          if (dest.axis !== "enu") {
            adjust_axis(dest, true, point);
          }
          return point;
        };
      }, { "./Proj": 55, "./adjust_axis": 56, "./common/toPoint": 76, "./datum_transform": 84 }], 120: [function(require2, module3, exports3) {
        var D2R = 0.017453292519943295;
        var extend = require2("./extend");
        function mapit(obj, key, v) {
          obj[key] = v.map(function(aa) {
            var o = {};
            sExpr(aa, o);
            return o;
          }).reduce(function(a, b) {
            return extend(a, b);
          }, {});
        }
        function sExpr(v, obj) {
          var key;
          if (!Array.isArray(v)) {
            obj[v] = true;
            return;
          } else {
            key = v.shift();
            if (key === "PARAMETER") {
              key = v.shift();
            }
            if (v.length === 1) {
              if (Array.isArray(v[0])) {
                obj[key] = {};
                sExpr(v[0], obj[key]);
              } else {
                obj[key] = v[0];
              }
            } else if (!v.length) {
              obj[key] = true;
            } else if (key === "TOWGS84") {
              obj[key] = v;
            } else {
              obj[key] = {};
              if (["UNIT", "PRIMEM", "VERT_DATUM"].indexOf(key) > -1) {
                obj[key] = {
                  name: v[0].toLowerCase(),
                  convert: v[1]
                };
                if (v.length === 3) {
                  obj[key].auth = v[2];
                }
              } else if (key === "SPHEROID") {
                obj[key] = {
                  name: v[0],
                  a: v[1],
                  rf: v[2]
                };
                if (v.length === 4) {
                  obj[key].auth = v[3];
                }
              } else if (["GEOGCS", "GEOCCS", "DATUM", "VERT_CS", "COMPD_CS", "LOCAL_CS", "FITTED_CS", "LOCAL_DATUM"].indexOf(key) > -1) {
                v[0] = ["name", v[0]];
                mapit(obj, key, v);
              } else if (v.every(function(aa) {
                return Array.isArray(aa);
              })) {
                mapit(obj, key, v);
              } else {
                sExpr(v, obj[key]);
              }
            }
          }
        }
        function rename(obj, params) {
          var outName = params[0];
          var inName = params[1];
          if (!(outName in obj) && inName in obj) {
            obj[outName] = obj[inName];
            if (params.length === 3) {
              obj[outName] = params[2](obj[outName]);
            }
          }
        }
        function d2r(input) {
          return input * D2R;
        }
        function cleanWKT(wkt) {
          if (wkt.type === "GEOGCS") {
            wkt.projName = "longlat";
          } else if (wkt.type === "LOCAL_CS") {
            wkt.projName = "identity";
            wkt.local = true;
          } else {
            if (typeof wkt.PROJECTION === "object") {
              wkt.projName = Object.keys(wkt.PROJECTION)[0];
            } else {
              wkt.projName = wkt.PROJECTION;
            }
          }
          if (wkt.UNIT) {
            wkt.units = wkt.UNIT.name.toLowerCase();
            if (wkt.units === "metre") {
              wkt.units = "meter";
            }
            if (wkt.UNIT.convert) {
              if (wkt.type === "GEOGCS") {
                if (wkt.DATUM && wkt.DATUM.SPHEROID) {
                  wkt.to_meter = parseFloat(wkt.UNIT.convert, 10) * wkt.DATUM.SPHEROID.a;
                }
              } else {
                wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
              }
            }
          }
          if (wkt.GEOGCS) {
            if (wkt.GEOGCS.DATUM) {
              wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
            } else {
              wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
            }
            if (wkt.datumCode.slice(0, 2) === "d_") {
              wkt.datumCode = wkt.datumCode.slice(2);
            }
            if (wkt.datumCode === "new_zealand_geodetic_datum_1949" || wkt.datumCode === "new_zealand_1949") {
              wkt.datumCode = "nzgd49";
            }
            if (wkt.datumCode === "wgs_1984") {
              if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
                wkt.sphere = true;
              }
              wkt.datumCode = "wgs84";
            }
            if (wkt.datumCode.slice(-6) === "_ferro") {
              wkt.datumCode = wkt.datumCode.slice(0, -6);
            }
            if (wkt.datumCode.slice(-8) === "_jakarta") {
              wkt.datumCode = wkt.datumCode.slice(0, -8);
            }
            if (~wkt.datumCode.indexOf("belge")) {
              wkt.datumCode = "rnb72";
            }
            if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
              wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
              if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
                wkt.ellps = "intl";
              }
              wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
              wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
            }
            if (~wkt.datumCode.indexOf("osgb_1936")) {
              wkt.datumCode = "osgb36";
            }
          }
          if (wkt.b && !isFinite(wkt.b)) {
            wkt.b = wkt.a;
          }
          function toMeter(input) {
            var ratio = wkt.to_meter || 1;
            return parseFloat(input, 10) * ratio;
          }
          var renamer = function(a) {
            return rename(wkt, a);
          };
          var list = [
            ["standard_parallel_1", "Standard_Parallel_1"],
            ["standard_parallel_2", "Standard_Parallel_2"],
            ["false_easting", "False_Easting"],
            ["false_northing", "False_Northing"],
            ["central_meridian", "Central_Meridian"],
            ["latitude_of_origin", "Latitude_Of_Origin"],
            ["latitude_of_origin", "Central_Parallel"],
            ["scale_factor", "Scale_Factor"],
            ["k0", "scale_factor"],
            ["latitude_of_center", "Latitude_of_center"],
            ["lat0", "latitude_of_center", d2r],
            ["longitude_of_center", "Longitude_Of_Center"],
            ["longc", "longitude_of_center", d2r],
            ["x0", "false_easting", toMeter],
            ["y0", "false_northing", toMeter],
            ["long0", "central_meridian", d2r],
            ["lat0", "latitude_of_origin", d2r],
            ["lat0", "standard_parallel_1", d2r],
            ["lat1", "standard_parallel_1", d2r],
            ["lat2", "standard_parallel_2", d2r],
            ["alpha", "azimuth", d2r],
            ["srsCode", "name"]
          ];
          list.forEach(renamer);
          if (!wkt.long0 && wkt.longc && (wkt.projName === "Albers_Conic_Equal_Area" || wkt.projName === "Lambert_Azimuthal_Equal_Area")) {
            wkt.long0 = wkt.longc;
          }
          if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === "Stereographic_South_Pole" || wkt.projName === "Polar Stereographic (variant B)")) {
            wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
            wkt.lat_ts = wkt.lat1;
          }
        }
        module3.exports = function(wkt, self2) {
          var lisp = JSON.parse(("," + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/, ""));
          var type = lisp.shift();
          var name = lisp.shift();
          lisp.unshift(["name", name]);
          lisp.unshift(["type", type]);
          lisp.unshift("output");
          var obj = {};
          sExpr(lisp, obj);
          cleanWKT(obj.output);
          return extend(self2, obj.output);
        };
      }, { "./extend": 87 }], 121: [function(require2, module3, exports3) {
        module3.exports = {
          "_args": [
            [
              "proj4@^2.1.4",
              "/Users/cmetcalf/projects/shapefile-js"
            ]
          ],
          "_from": "proj4@>=2.1.4 <3.0.0",
          "_id": "proj4@2.3.14",
          "_inCache": true,
          "_installable": true,
          "_location": "/proj4",
          "_nodeVersion": "4.2.6",
          "_npmOperationalInternal": {
            "host": "packages-13-west.internal.npmjs.com",
            "tmp": "tmp/proj4-2.3.14.tgz_1457689264880_0.9409773757215589"
          },
          "_npmUser": {
            "email": "andreas.hocevar@gmail.com",
            "name": "ahocevar"
          },
          "_npmVersion": "2.14.12",
          "_phantomChildren": {},
          "_requested": {
            "name": "proj4",
            "raw": "proj4@^2.1.4",
            "rawSpec": "^2.1.4",
            "scope": null,
            "spec": ">=2.1.4 <3.0.0",
            "type": "range"
          },
          "_requiredBy": [
            "/"
          ],
          "_resolved": "https://registry.npmjs.org/proj4/-/proj4-2.3.14.tgz",
          "_shasum": "928906144388980c914c5a357fc493aba59a747a",
          "_shrinkwrap": null,
          "_spec": "proj4@^2.1.4",
          "_where": "/Users/cmetcalf/projects/shapefile-js",
          "author": "",
          "bugs": {
            "url": "https://github.com/proj4js/proj4js/issues"
          },
          "contributors": [
            {
              "name": "Mike Adair",
              "email": "madair@dmsolutions.ca"
            },
            {
              "name": "Richard Greenwood",
              "email": "rich@greenwoodmap.com"
            },
            {
              "name": "Calvin Metcalf",
              "email": "calvin.metcalf@gmail.com"
            },
            {
              "name": "Richard Marsden",
              "url": "http://www.winwaed.com"
            },
            {
              "name": "T. Mittan"
            },
            {
              "name": "D. Steinwand"
            },
            {
              "name": "S. Nelson"
            }
          ],
          "dependencies": {
            "mgrs": "~0.0.2"
          },
          "description": "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",
          "devDependencies": {
            "browserify": "~12.0.1",
            "chai": "~1.8.1",
            "curl": "git://github.com/cujojs/curl.git",
            "grunt": "~0.4.2",
            "grunt-browserify": "~4.0.1",
            "grunt-cli": "~0.1.13",
            "grunt-contrib-connect": "~0.6.0",
            "grunt-contrib-jshint": "~0.8.0",
            "grunt-contrib-uglify": "~0.11.1",
            "grunt-mocha-phantomjs": "~0.4.0",
            "istanbul": "~0.2.4",
            "mocha": "~1.17.1",
            "tin": "~0.4.0"
          },
          "directories": {
            "doc": "docs",
            "test": "test"
          },
          "dist": {
            "shasum": "928906144388980c914c5a357fc493aba59a747a",
            "tarball": "http://registry.npmjs.org/proj4/-/proj4-2.3.14.tgz"
          },
          "gitHead": "7619c8a63df1eae5bad0b9ad31ca1d87b0549243",
          "homepage": "https://github.com/proj4js/proj4js#readme",
          "jam": {
            "include": [
              "AUTHORS",
              "LICENSE.md",
              "README.md",
              "dist/proj4.js"
            ],
            "main": "dist/proj4.js"
          },
          "license": "MIT",
          "main": "lib/index.js",
          "maintainers": [
            {
              "name": "cwmma",
              "email": "calvin.metcalf@gmail.com"
            },
            {
              "name": "ahocevar",
              "email": "andreas.hocevar@gmail.com"
            }
          ],
          "name": "proj4",
          "optionalDependencies": {},
          "readme": "ERROR: No README data found!",
          "repository": {
            "type": "git",
            "url": "git://github.com/proj4js/proj4js.git"
          },
          "scripts": {
            "test": "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"
          },
          "version": "2.3.14"
        };
      }, {}], 122: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var proj4 = require2("proj4");
          var unzip = require2("./unzip");
          var binaryAjax = require2("./binaryajax");
          var parseShp = require2("./parseShp");
          var toArrayBuffer = require2("./toArrayBuffer");
          var parseDbf = require2("parsedbf");
          var Promise2 = require2("lie");
          var Cache = require2("lru-cache");
          var cache = new Cache({
            max: 20
          });
          function shp(base, whiteList) {
            if (typeof base === "string" && cache.has(base)) {
              return Promise2.resolve(cache.get(base));
            }
            return shp.getShapefile(base, whiteList).then(function(resp) {
              if (typeof base === "string") {
                cache.set(base, resp);
              }
              return resp;
            });
          }
          shp.combine = function(arr) {
            var out = {};
            out.type = "FeatureCollection";
            out.features = [];
            var i = 0;
            var len = arr[0].length;
            while (i < len) {
              out.features.push({
                "type": "Feature",
                "geometry": arr[0][i],
                "properties": arr[1][i]
              });
              i++;
            }
            return out;
          };
          shp.parseZip = function(buffer, whiteList) {
            var key;
            var zip = unzip(buffer);
            var names = [];
            whiteList = whiteList || [];
            for (key in zip) {
              if (key.indexOf("__MACOSX") !== -1) {
                continue;
              }
              if (key.slice(-3).toLowerCase() === "shp") {
                names.push(key.slice(0, -4));
                zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = zip[key];
              } else if (key.slice(-3).toLowerCase() === "dbf") {
                zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = parseDbf(zip[key]);
              } else if (key.slice(-3).toLowerCase() === "prj") {
                zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);
              } else if (key.slice(-4).toLowerCase() === "json" || whiteList.indexOf(key.split(".").pop()) > -1) {
                names.push(key.slice(0, -3) + key.slice(-3).toLowerCase());
              }
            }
            if (!names.length) {
              throw new Error("no layers founds");
            }
            var geojson = names.map(function(name) {
              var parsed;
              var lastDotIdx = name.lastIndexOf(".");
              if (lastDotIdx > -1 && name.slice(lastDotIdx).indexOf("json") > -1) {
                parsed = JSON.parse(zip[name]);
                parsed.fileName = name.slice(0, lastDotIdx);
              } else if (whiteList.indexOf(name.slice(lastDotIdx + 1)) > -1) {
                parsed = zip[name];
                parsed.fileName = name;
              } else {
                parsed = shp.combine([parseShp(zip[name + ".shp"], zip[name + ".prj"]), zip[name + ".dbf"]]);
                parsed.fileName = name;
              }
              return parsed;
            });
            if (geojson.length === 1) {
              return geojson[0];
            } else {
              return geojson;
            }
          };
          function getZip(base, whiteList) {
            return binaryAjax(base).then(function(a) {
              return shp.parseZip(a, whiteList);
            });
          }
          shp.getShapefile = function(base, whiteList) {
            if (typeof base === "string") {
              if (base.slice(-4) === ".zip") {
                return getZip(base, whiteList);
              } else {
                return Promise2.all([
                  Promise2.all([
                    binaryAjax(base + ".shp"),
                    binaryAjax(base + ".prj")
                  ]).then(function(args) {
                    return parseShp(args[0], args[1] ? proj4(args[1]) : false);
                  }),
                  binaryAjax(base + ".dbf").then(parseDbf)
                ]).then(shp.combine);
              }
            } else {
              return new Promise2(function(resolve) {
                resolve(shp.parseZip(base));
              });
            }
          };
          shp.parseShp = function(shp2, prj) {
            if (Buffer.isBuffer(shp2)) {
              shp2 = toArrayBuffer(shp2);
            }
            if (Buffer.isBuffer(prj)) {
              prj = prj.toString();
            }
            if (typeof prj === "string") {
              prj = proj4(prj);
              return parseShp(shp2, prj);
            } else {
              return parseShp(shp2);
            }
          };
          shp.parseDbf = function(dbf) {
            if (Buffer.isBuffer(dbf)) {
              dbf = toArrayBuffer(dbf);
            }
            return parseDbf(dbf);
          };
          module3.exports = shp;
          console.log(shp, "shp");
        }).call(this, { "isBuffer": require2("../node_modules/is-buffer/index.js") });
      }, { "../node_modules/is-buffer/index.js": 10, "./binaryajax": 1, "./parseShp": 2, "./toArrayBuffer": 3, "./unzip": 4, "lie": 34, "lru-cache": 35, "parsedbf": 53, "proj4": 90 }] }, {}, [122])(122);
    });
  }
});

// dep:shpjs_dist_shp
var shpjs_dist_shp_default = require_shp();
export {
  shpjs_dist_shp_default as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
//# sourceMappingURL=shpjs_dist_shp.js.map
